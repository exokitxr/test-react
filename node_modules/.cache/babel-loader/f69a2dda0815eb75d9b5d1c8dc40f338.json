{"ast":null,"code":"/* eslint-disable */\nimport THREE from 'three.js';\n/**\n* Takes in a rootBone and recursively traverses the bone heirarchy,\n* setting each bone's +Z axis to face it's child bones. The IK system follows this\n* convention, so this step is necessary to update the bindings of a skinned mesh.\n*\n* Must rebind the model to it's skeleton after this function.\n*\n* @param {THREE.Bone} rootBone\n* @param {Object} context - options and buffer for stateful bone calculations\n*                 context.exclude: [ boneNames to exclude ]\n*                 context.preRotations: { boneName: THREE.Quaternion, ... }\n*/\n\nfunction fixSkeletonZForward(rootBone, context) {\n  context = context || {};\n  precalculateZForwards(rootBone, context);\n\n  if (context.exclude) {\n    var bones = [rootBone];\n    rootBone.traverse(b => bones.push(b));\n    bones.forEach(b => {\n      if (~context.exclude.indexOf(b.id) || ~context.exclude.indexOf(b.name)) {\n        delete context.averagedDirs[b.id];\n      }\n    });\n  }\n\n  return setZForward(rootBone, context);\n}\n\nconst RESETQUAT = new THREE.Quaternion();\nconst Y_AXIS = new THREE.Vector3(0, 1, 0);\n/**\n* Takes in a rootBone and recursively traverses the bone heirarchy,\n* setting each bone's +Z axis to face it's child bones. The IK system follows this\n* convention, so this step is necessary to update the bindings of a skinned mesh.\n*\n* Must rebind the model to it's skeleton after this function.\n*\n* @param {THREE.BONE} rootBone\n*/\n\nfunction precalculateZForwards(rootBone, context) {\n  context = context || rootBone;\n  context.worldPos = context.worldPos || {};\n  context.averagedDirs = context.averagedDirs || {};\n  context.preRotations = context.preRotations || {};\n  getOriginalWorldPositions(rootBone, context.worldPos);\n  calculateAverages(rootBone, context.worldPos, context.averagedDirs);\n  return context;\n}\n\nfunction setZForward(rootBone, context) {\n  if (!context || !context.worldPos) {\n    context = context || {};\n    precalculateZForwards(rootBone, context);\n  }\n\n  updateTransformations(rootBone, context.worldPos, context.averagedDirs, context.preRotations);\n  return context;\n}\n\nfunction calculateAverages(parentBone, worldPos, averagedDirs) {\n  var averagedDir = new THREE.Vector3();\n  parentBone.children.forEach(childBone => {\n    //average the child bone world pos\n    var childBonePosWorld = worldPos[childBone.id][0];\n    averagedDir.add(childBonePosWorld);\n  });\n  averagedDir.multiplyScalar(1 / parentBone.children.length);\n  averagedDirs[parentBone.id] = averagedDir;\n  parentBone.children.forEach(childBone => {\n    calculateAverages(childBone, worldPos, averagedDirs);\n  });\n}\n\nfunction updateTransformations(parentBone, worldPos, averagedDirs, preRotations) {\n  var averagedDir = averagedDirs[parentBone.id];\n\n  if (averagedDir) {\n    //set quaternion\n    parentBone.quaternion.copy(RESETQUAT); // parentBone.quaternion.premultiply(new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), Math.PI*2));\n\n    parentBone.updateMatrixWorld(); //get the child bone position in local coordinates\n    // var childBoneDir = parentBone.worldToLocal(averagedDir.clone()).normalize();\n    //set direction to face child\n    // setQuaternionFromDirection(childBoneDir, Y_AXIS, parentBone.quaternion)\n    // console.log('new quaternion', parentBone.quaternion.toArray().join(','));\n  }\n\n  var preRot = preRotations[parentBone.id] || preRotations[parentBone.name];\n  if (preRot) parentBone.quaternion.multiply(preRot); // parentBone.quaternion.multiply(new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), Math.PI));\n\n  parentBone.updateMatrixWorld(); //set child bone position relative to the new parent matrix.\n\n  parentBone.children.forEach(childBone => {\n    var childBonePosWorld = worldPos[childBone.id][0].clone();\n    parentBone.worldToLocal(childBonePosWorld);\n    childBone.position.copy(childBonePosWorld);\n  });\n  parentBone.children.forEach(childBone => {\n    updateTransformations(childBone, worldPos, averagedDirs, preRotations);\n  });\n} //borrowing this from utils.js , not sure how to import it\n\n\nconst t1 = new THREE.Vector3();\nconst t2 = new THREE.Vector3();\nconst t3 = new THREE.Vector3();\nconst m1 = new THREE.Matrix4();\n\nfunction setQuaternionFromDirection(direction, up, target) {\n  const x = t1;\n  const y = t2;\n  const z = t3;\n  const m = m1;\n  const el = m1.elements;\n  z.copy(direction);\n  x.crossVectors(up, z);\n\n  if (x.lengthSq() === 0) {\n    // parallel\n    if (Math.abs(up.z) === 1) {\n      z.x += 0.0001;\n    } else {\n      z.z += 0.0001;\n    }\n\n    z.normalize();\n    x.crossVectors(up, z);\n  }\n\n  x.normalize();\n  y.crossVectors(z, x);\n  el[0] = x.x;\n  el[4] = y.x;\n  el[8] = z.x;\n  el[1] = x.y;\n  el[5] = y.y;\n  el[9] = z.y;\n  el[2] = x.z;\n  el[6] = y.z;\n  el[10] = z.z;\n  return target.setFromRotationMatrix(m);\n}\n\nfunction getOriginalWorldPositions(rootBone, worldPos) {\n  var rootBoneWorldPos = rootBone.getWorldPosition(new THREE.Vector3());\n  worldPos[rootBone.id] = [rootBoneWorldPos];\n  rootBone.children.forEach(child => {\n    getOriginalWorldPositions(child, worldPos);\n  });\n}\n\nfunction _worldToLocalDirection(direction, parent) {\n  const inverseParent = new THREE.Matrix4().getInverse(parent.matrixWorld);\n  direction.transformDirection(inverseParent);\n  return direction;\n}\n\nfunction _localToWorldDirection(direction, parent) {\n  const parentMat = parent.matrixWorld;\n  direction.transformDirection(parentMat);\n  return direction;\n}\n\nexport { fixSkeletonZForward, setQuaternionFromDirection };","map":{"version":3,"sources":["/Users/chris/Documents/Github/test-react/src/WebXRApps/Avatars/vrarmik/SkeletonUtils.js"],"names":["THREE","fixSkeletonZForward","rootBone","context","precalculateZForwards","exclude","bones","traverse","b","push","forEach","indexOf","id","name","averagedDirs","setZForward","RESETQUAT","Quaternion","Y_AXIS","Vector3","worldPos","preRotations","getOriginalWorldPositions","calculateAverages","updateTransformations","parentBone","averagedDir","children","childBone","childBonePosWorld","add","multiplyScalar","length","quaternion","copy","updateMatrixWorld","preRot","multiply","clone","worldToLocal","position","t1","t2","t3","m1","Matrix4","setQuaternionFromDirection","direction","up","target","x","y","z","m","el","elements","crossVectors","lengthSq","Math","abs","normalize","setFromRotationMatrix","rootBoneWorldPos","getWorldPosition","child","_worldToLocalDirection","parent","inverseParent","getInverse","matrixWorld","transformDirection","_localToWorldDirection","parentMat"],"mappings":"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","sourcesContent":["/* eslint-disable */\n\nimport THREE from 'three.js'\n\n/**\n* Takes in a rootBone and recursively traverses the bone heirarchy,\n* setting each bone's +Z axis to face it's child bones. The IK system follows this\n* convention, so this step is necessary to update the bindings of a skinned mesh.\n*\n* Must rebind the model to it's skeleton after this function.\n*\n* @param {THREE.Bone} rootBone\n* @param {Object} context - options and buffer for stateful bone calculations\n*                 context.exclude: [ boneNames to exclude ]\n*                 context.preRotations: { boneName: THREE.Quaternion, ... }\n*/\n\nfunction fixSkeletonZForward(rootBone, context) {\n  context = context || {};\n  precalculateZForwards(rootBone, context);\n  if (context.exclude) {\n    var bones = [rootBone];\n    rootBone.traverse((b) => bones.push(b));\n    bones.forEach((b) => {\n      if (~context.exclude.indexOf(b.id) || ~context.exclude.indexOf(b.name)) {\n        delete context.averagedDirs[b.id];\n      }\n    });\n  }\n  return setZForward(rootBone, context);\n}\n\nconst RESETQUAT = new THREE.Quaternion();\nconst Y_AXIS = new THREE.Vector3(0,1,0);\n\n/**\n* Takes in a rootBone and recursively traverses the bone heirarchy,\n* setting each bone's +Z axis to face it's child bones. The IK system follows this\n* convention, so this step is necessary to update the bindings of a skinned mesh.\n*\n* Must rebind the model to it's skeleton after this function.\n*\n* @param {THREE.BONE} rootBone\n*/\n\nfunction precalculateZForwards(rootBone, context) {\n  context = context || rootBone;\n  context.worldPos = context.worldPos || {};\n  context.averagedDirs = context.averagedDirs || {};\n  context.preRotations = context.preRotations || {};\n  getOriginalWorldPositions(rootBone, context.worldPos)\n  calculateAverages(rootBone, context.worldPos, context.averagedDirs);\n  return context;\n}\n\nfunction setZForward(rootBone, context) {\n  if (!context || !context.worldPos) {\n    context = context || {};\n    precalculateZForwards(rootBone, context);\n  }\n  updateTransformations(rootBone, context.worldPos, context.averagedDirs, context.preRotations);\n  return context;\n}\n\nfunction calculateAverages(parentBone, worldPos, averagedDirs) {\n  var averagedDir = new THREE.Vector3();\n  parentBone.children.forEach((childBone) => {\n    //average the child bone world pos\n    var childBonePosWorld = worldPos[childBone.id][0];\n    averagedDir.add(childBonePosWorld);\n  });\n\n  averagedDir.multiplyScalar(1/(parentBone.children.length));\n  averagedDirs[parentBone.id] = averagedDir;\n\n  parentBone.children.forEach((childBone) => {\n    calculateAverages(childBone, worldPos, averagedDirs);\n  });\n}\n\nfunction updateTransformations(parentBone, worldPos, averagedDirs, preRotations) {\n\n      var averagedDir = averagedDirs[parentBone.id];\n      if (averagedDir) {\n\n        //set quaternion\n        parentBone.quaternion.copy(RESETQUAT);\n        // parentBone.quaternion.premultiply(new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), Math.PI*2));\n        parentBone.updateMatrixWorld();\n\n        //get the child bone position in local coordinates\n        // var childBoneDir = parentBone.worldToLocal(averagedDir.clone()).normalize();\n\n        //set direction to face child\n        // setQuaternionFromDirection(childBoneDir, Y_AXIS, parentBone.quaternion)\n        // console.log('new quaternion', parentBone.quaternion.toArray().join(','));\n    }\n    var preRot = preRotations[parentBone.id] || preRotations[parentBone.name];\n    if (preRot) parentBone.quaternion.multiply(preRot);\n    // parentBone.quaternion.multiply(new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), Math.PI));\n    parentBone.updateMatrixWorld();\n\n    //set child bone position relative to the new parent matrix.\n    parentBone.children.forEach((childBone) => {\n      var childBonePosWorld = worldPos[childBone.id][0].clone();\n      parentBone.worldToLocal(childBonePosWorld);\n      childBone.position.copy(childBonePosWorld);\n    });\n\n    parentBone.children.forEach((childBone) => {\n      updateTransformations(childBone, worldPos, averagedDirs, preRotations);\n    });\n}\n\n//borrowing this from utils.js , not sure how to import it\nconst t1 = new THREE.Vector3();\nconst t2 = new THREE.Vector3();\nconst t3 = new THREE.Vector3();\nconst m1 = new THREE.Matrix4();\nfunction setQuaternionFromDirection(direction, up, target) {\n  const x = t1;\n  const y = t2;\n  const z = t3;\n  const m = m1;\n  const el = m1.elements;\n\n  z.copy(direction);\n  x.crossVectors(up, z);\n\n  if (x.lengthSq() === 0) {\n    // parallel\n    if (Math.abs(up.z) === 1) {\n      z.x += 0.0001;\n    } else {\n      z.z += 0.0001;\n    }\n    z.normalize();\n    x.crossVectors(up, z);\n  }\n\n  x.normalize();\n  y.crossVectors(z, x);\n\n  el[ 0 ] = x.x; el[ 4 ] = y.x; el[ 8 ] = z.x;\n  el[ 1 ] = x.y; el[ 5 ] = y.y; el[ 9 ] = z.y;\n  el[ 2 ] = x.z; el[ 6 ] = y.z; el[ 10 ] = z.z;\n\n  return target.setFromRotationMatrix(m);\n}\n\nfunction getOriginalWorldPositions(rootBone, worldPos) {\n  var rootBoneWorldPos = rootBone.getWorldPosition(new THREE.Vector3())\n  worldPos[rootBone.id] = [rootBoneWorldPos];\n  rootBone.children.forEach((child) => {\n    getOriginalWorldPositions(child, worldPos)\n  })\n}\n\nfunction _worldToLocalDirection(direction, parent) {\n    const inverseParent = new THREE.Matrix4().getInverse(parent.matrixWorld);\n    direction.transformDirection(inverseParent);\n  return direction;\n}\n\nfunction _localToWorldDirection(direction, parent) {\n  const parentMat = parent.matrixWorld;\n  direction.transformDirection(parentMat);\n  return direction;\n}\n\nexport {\n  fixSkeletonZForward, setQuaternionFromDirection\n};"]},"metadata":{},"sourceType":"module"}