{"ast":null,"code":"/* eslint-disable */\nimport THREE from 'three.js';\n\nvar __three_vrm__ =\n/******/\nfunction (modules) {\n  // webpackBootstrap\n\n  /******/\n  // The module cache\n\n  /******/\n  var installedModules = {};\n  /******/\n\n  /******/\n  // The require function\n\n  /******/\n\n  function __webpack_require__(moduleId) {\n    /******/\n\n    /******/\n    // Check if module is in cache\n\n    /******/\n    if (installedModules[moduleId]) {\n      /******/\n      return installedModules[moduleId].exports;\n      /******/\n    }\n    /******/\n    // Create a new module (and put it into the cache)\n\n    /******/\n\n\n    var module = installedModules[moduleId] = {\n      /******/\n      i: moduleId,\n\n      /******/\n      l: false,\n\n      /******/\n      exports: {}\n      /******/\n\n    };\n    /******/\n\n    /******/\n    // Execute the module function\n\n    /******/\n\n    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n    /******/\n\n    /******/\n    // Flag the module as loaded\n\n    /******/\n\n    module.l = true;\n    /******/\n\n    /******/\n    // Return the exports of the module\n\n    /******/\n\n    return module.exports;\n    /******/\n  }\n  /******/\n\n  /******/\n\n  /******/\n  // expose the modules object (__webpack_modules__)\n\n  /******/\n\n\n  __webpack_require__.m = modules;\n  /******/\n\n  /******/\n  // expose the module cache\n\n  /******/\n\n  __webpack_require__.c = installedModules;\n  /******/\n\n  /******/\n  // define getter function for harmony exports\n\n  /******/\n\n  __webpack_require__.d = function (exports, name, getter) {\n    /******/\n    if (!__webpack_require__.o(exports, name)) {\n      /******/\n      Object.defineProperty(exports, name, {\n        enumerable: true,\n        get: getter\n      });\n      /******/\n    }\n    /******/\n\n  };\n  /******/\n\n  /******/\n  // define __esModule on exports\n\n  /******/\n\n\n  __webpack_require__.r = function (exports) {\n    /******/\n    if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n      /******/\n      Object.defineProperty(exports, Symbol.toStringTag, {\n        value: 'Module'\n      });\n      /******/\n    }\n    /******/\n\n\n    Object.defineProperty(exports, '__esModule', {\n      value: true\n    });\n    /******/\n  };\n  /******/\n\n  /******/\n  // create a fake namespace object\n\n  /******/\n  // mode & 1: value is a module id, require it\n\n  /******/\n  // mode & 2: merge all properties of value into the ns\n\n  /******/\n  // mode & 4: return value when already ns object\n\n  /******/\n  // mode & 8|1: behave like require\n\n  /******/\n\n\n  __webpack_require__.t = function (value, mode) {\n    /******/\n    if (mode & 1) value = __webpack_require__(value);\n    /******/\n\n    if (mode & 8) return value;\n    /******/\n\n    if (mode & 4 && typeof value === 'object' && value && value.__esModule) return value;\n    /******/\n\n    var ns = Object.create(null);\n    /******/\n\n    __webpack_require__.r(ns);\n    /******/\n\n\n    Object.defineProperty(ns, 'default', {\n      enumerable: true,\n      value: value\n    });\n    /******/\n\n    if (mode & 2 && typeof value != 'string') for (var key in value) __webpack_require__.d(ns, key, function (key) {\n      return value[key];\n    }.bind(null, key));\n    /******/\n\n    return ns;\n    /******/\n  };\n  /******/\n\n  /******/\n  // getDefaultExport function for compatibility with non-harmony modules\n\n  /******/\n\n\n  __webpack_require__.n = function (module) {\n    /******/\n    var getter = module && module.__esModule ?\n    /******/\n    function getDefault() {\n      return module['default'];\n    } :\n    /******/\n    function getModuleExports() {\n      return module;\n    };\n    /******/\n\n    __webpack_require__.d(getter, 'a', getter);\n    /******/\n\n\n    return getter;\n    /******/\n  };\n  /******/\n\n  /******/\n  // Object.prototype.hasOwnProperty.call\n\n  /******/\n\n\n  __webpack_require__.o = function (object, property) {\n    return Object.prototype.hasOwnProperty.call(object, property);\n  };\n  /******/\n\n  /******/\n  // __webpack_public_path__\n\n  /******/\n\n\n  __webpack_require__.p = \"\";\n  /******/\n\n  /******/\n\n  /******/\n  // Load entry module and return exports\n\n  /******/\n\n  return __webpack_require__(__webpack_require__.s = \"./src/assign.ts\");\n  /******/\n}(\n/************************************************************************/\n\n/******/\n{\n  /***/\n  \"./src/assign.ts\":\n  /*!***********************!*\\\r\n    !*** ./src/assign.ts ***!\r\n    \\***********************/\n\n  /*! no static exports found */\n\n  /***/\n  function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n\n    var __three_vrm__ = __webpack_require__(\n    /*! . */\n    \"./src/index.ts\");\n\n    Object.assign(THREE, __three_vrm__);\n    /***/\n  },\n\n  /***/\n  \"./src/index.ts\":\n  /*!**********************!*\\\r\n    !*** ./src/index.ts ***!\r\n    \\**********************/\n\n  /*! no static exports found */\n\n  /***/\n  function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    function __export(m) {\n      for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n    }\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n\n    __export(__webpack_require__(\n    /*! ./vrm/ */\n    \"./src/vrm/index.ts\"));\n    /***/\n\n  },\n\n  /***/\n  \"./src/vrm/VRM.ts\":\n  /*!************************!*\\\r\n    !*** ./src/vrm/VRM.ts ***!\r\n    \\************************/\n\n  /*! no static exports found */\n\n  /***/\n  function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n      return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) {\n          try {\n            step(generator.next(value));\n          } catch (e) {\n            reject(e);\n          }\n        }\n\n        function rejected(value) {\n          try {\n            step(generator[\"throw\"](value));\n          } catch (e) {\n            reject(e);\n          }\n        }\n\n        function step(result) {\n          result.done ? resolve(result.value) : new P(function (resolve) {\n            resolve(result.value);\n          }).then(fulfilled, rejected);\n        }\n\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n      });\n    };\n\n    var __generator = this && this.__generator || function (thisArg, body) {\n      var _ = {\n        label: 0,\n        sent: function () {\n          if (t[0] & 1) throw t[1];\n          return t[1];\n        },\n        trys: [],\n        ops: []\n      },\n          f,\n          y,\n          t,\n          g;\n      return g = {\n        next: verb(0),\n        \"throw\": verb(1),\n        \"return\": verb(2)\n      }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n        return this;\n      }), g;\n\n      function verb(n) {\n        return function (v) {\n          return step([n, v]);\n        };\n      }\n\n      function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n\n        while (_) try {\n          if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n          if (y = 0, t) op = [op[0] & 2, t.value];\n\n          switch (op[0]) {\n            case 0:\n            case 1:\n              t = op;\n              break;\n\n            case 4:\n              _.label++;\n              return {\n                value: op[1],\n                done: false\n              };\n\n            case 5:\n              _.label++;\n              y = op[1];\n              op = [0];\n              continue;\n\n            case 7:\n              op = _.ops.pop();\n\n              _.trys.pop();\n\n              continue;\n\n            default:\n              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n                _ = 0;\n                continue;\n              }\n\n              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n                _.label = op[1];\n                break;\n              }\n\n              if (op[0] === 6 && _.label < t[1]) {\n                _.label = t[1];\n                t = op;\n                break;\n              }\n\n              if (t && _.label < t[2]) {\n                _.label = t[2];\n\n                _.ops.push(op);\n\n                break;\n              }\n\n              if (t[2]) _.ops.pop();\n\n              _.trys.pop();\n\n              continue;\n          }\n\n          op = body.call(thisArg, _);\n        } catch (e) {\n          op = [6, e];\n          y = 0;\n        } finally {\n          f = t = 0;\n        }\n\n        if (op[0] & 5) throw op[1];\n        return {\n          value: op[0] ? op[1] : void 0,\n          done: true\n        };\n      }\n    };\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n\n    var disposer_1 = __webpack_require__(\n    /*! ./utils/disposer */\n    \"./src/vrm/utils/disposer.ts\");\n\n    var VRMImporter_1 = __webpack_require__(\n    /*! ./VRMImporter */\n    \"./src/vrm/VRMImporter.ts\");\n\n    var VRM = function () {\n      function VRM(params) {\n        this.scene = params.scene;\n        this.humanoid = params.humanoid;\n        this.blendShapeProxy = params.blendShapeProxy;\n        this.firstPerson = params.firstPerson;\n        this.lookAt = params.lookAt;\n        this.materials = params.materials;\n        this.springBoneManager = params.springBoneManager;\n        this.meta = params.meta;\n      }\n\n      VRM.from = function (gltf, options) {\n        if (options === void 0) {\n          options = {};\n        }\n\n        return __awaiter(this, void 0, Promise, function () {\n          var importer;\n          return __generator(this, function (_a) {\n            switch (_a.label) {\n              case 0:\n                importer = new VRMImporter_1.VRMImporter(options);\n                return [4, importer.import(gltf)];\n\n              case 1:\n                return [2, _a.sent()];\n            }\n          });\n        });\n      };\n\n      VRM.prototype.update = function (delta) {\n        if (this.lookAt) {\n          this.lookAt.update(delta);\n        }\n\n        if (this.blendShapeProxy) {\n          this.blendShapeProxy.update();\n        }\n\n        if (this.springBoneManager) {\n          this.springBoneManager.lateUpdate(delta);\n        }\n\n        if (this.materials) {\n          this.materials.forEach(function (material) {\n            if (material.updateVRMMaterials) {\n              material.updateVRMMaterials(delta);\n            }\n          });\n        }\n      };\n\n      VRM.prototype.dispose = function () {\n        var scene = this.scene;\n\n        if (scene) {\n          while (scene.children.length > 0) {\n            var object = scene.children[scene.children.length - 1];\n            disposer_1.deepDispose(object);\n            scene.remove(object);\n          }\n        }\n      };\n\n      return VRM;\n    }();\n\n    exports.VRM = VRM;\n    /***/\n  },\n\n  /***/\n  \"./src/vrm/VRMImporter.ts\":\n  /*!********************************!*\\\r\n    !*** ./src/vrm/VRMImporter.ts ***!\r\n    \\********************************/\n\n  /*! no static exports found */\n\n  /***/\n  function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n      return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) {\n          try {\n            step(generator.next(value));\n          } catch (e) {\n            reject(e);\n          }\n        }\n\n        function rejected(value) {\n          try {\n            step(generator[\"throw\"](value));\n          } catch (e) {\n            reject(e);\n          }\n        }\n\n        function step(result) {\n          result.done ? resolve(result.value) : new P(function (resolve) {\n            resolve(result.value);\n          }).then(fulfilled, rejected);\n        }\n\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n      });\n    };\n\n    var __generator = this && this.__generator || function (thisArg, body) {\n      var _ = {\n        label: 0,\n        sent: function () {\n          if (t[0] & 1) throw t[1];\n          return t[1];\n        },\n        trys: [],\n        ops: []\n      },\n          f,\n          y,\n          t,\n          g;\n      return g = {\n        next: verb(0),\n        \"throw\": verb(1),\n        \"return\": verb(2)\n      }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n        return this;\n      }), g;\n\n      function verb(n) {\n        return function (v) {\n          return step([n, v]);\n        };\n      }\n\n      function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n\n        while (_) try {\n          if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n          if (y = 0, t) op = [op[0] & 2, t.value];\n\n          switch (op[0]) {\n            case 0:\n            case 1:\n              t = op;\n              break;\n\n            case 4:\n              _.label++;\n              return {\n                value: op[1],\n                done: false\n              };\n\n            case 5:\n              _.label++;\n              y = op[1];\n              op = [0];\n              continue;\n\n            case 7:\n              op = _.ops.pop();\n\n              _.trys.pop();\n\n              continue;\n\n            default:\n              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n                _ = 0;\n                continue;\n              }\n\n              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n                _.label = op[1];\n                break;\n              }\n\n              if (op[0] === 6 && _.label < t[1]) {\n                _.label = t[1];\n                t = op;\n                break;\n              }\n\n              if (t && _.label < t[2]) {\n                _.label = t[2];\n\n                _.ops.push(op);\n\n                break;\n              }\n\n              if (t[2]) _.ops.pop();\n\n              _.trys.pop();\n\n              continue;\n          }\n\n          op = body.call(thisArg, _);\n        } catch (e) {\n          op = [6, e];\n          y = 0;\n        } finally {\n          f = t = 0;\n        }\n\n        if (op[0] & 5) throw op[1];\n        return {\n          value: op[0] ? op[1] : void 0,\n          done: true\n        };\n      }\n    };\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n\n    var blendshape_1 = __webpack_require__(\n    /*! ./blendshape */\n    \"./src/vrm/blendshape/index.ts\");\n\n    var firstperson_1 = __webpack_require__(\n    /*! ./firstperson */\n    \"./src/vrm/firstperson/index.ts\");\n\n    var VRMHumanoidImporter_1 = __webpack_require__(\n    /*! ./humanoid/VRMHumanoidImporter */\n    \"./src/vrm/humanoid/VRMHumanoidImporter.ts\");\n\n    var VRMLookAtImporter_1 = __webpack_require__(\n    /*! ./lookat/VRMLookAtImporter */\n    \"./src/vrm/lookat/VRMLookAtImporter.ts\");\n\n    var material_1 = __webpack_require__(\n    /*! ./material */\n    \"./src/vrm/material/index.ts\");\n\n    var reduceBones_1 = __webpack_require__(\n    /*! ./reduceBones */\n    \"./src/vrm/reduceBones.ts\");\n\n    var VRMSpringBoneImporter_1 = __webpack_require__(\n    /*! ./springbone/VRMSpringBoneImporter */\n    \"./src/vrm/springbone/VRMSpringBoneImporter.ts\");\n\n    var VRM_1 = __webpack_require__(\n    /*! ./VRM */\n    \"./src/vrm/VRM.ts\");\n\n    var VRMImporter = function () {\n      function VRMImporter(options) {\n        if (options === void 0) {\n          options = {};\n        }\n\n        this._blendShapeImporter = options.blendShapeImporter || new blendshape_1.VRMBlendShapeImporter();\n        this._lookAtImporter = options.lookAtImporter || new VRMLookAtImporter_1.VRMLookAtImporter();\n        this._humanoidImporter = options.humanoidImporter || new VRMHumanoidImporter_1.VRMHumanoidImporter();\n        this._firstPersonImporter = options.firstPersonImporter || new firstperson_1.VRMFirstPersonImporter();\n        this._materialImporter = options.materialImporter || new material_1.VRMMaterialImporter();\n        this._springBoneImporter = options.springBoneImporter || new VRMSpringBoneImporter_1.VRMSpringBoneImporter();\n      }\n\n      VRMImporter.prototype.import = function (gltf) {\n        return __awaiter(this, void 0, Promise, function () {\n          var vrmExt, scene, materials, humanoid, firstPerson, _a, blendShapeProxy, lookAt, _b, springBoneManager;\n\n          return __generator(this, function (_c) {\n            switch (_c.label) {\n              case 0:\n                if (gltf.parser.json.extensions === undefined || gltf.parser.json.extensions.VRM === undefined) {\n                  throw new Error('Could not find VRM extension on the GLTF');\n                }\n\n                vrmExt = gltf.parser.json.extensions.VRM;\n                scene = gltf.scene;\n                scene.updateMatrixWorld(false);\n                scene.traverse(function (object3d) {\n                  if (object3d.isMesh) {\n                    object3d.frustumCulled = false;\n                  }\n                });\n                reduceBones_1.reduceBones(scene);\n                return [4, this._materialImporter.convertGLTFMaterials(gltf)];\n\n              case 1:\n                materials = _c.sent() || undefined;\n                return [4, this._humanoidImporter.import(gltf)];\n\n              case 2:\n                humanoid = _c.sent() || undefined;\n                if (!humanoid) return [3, 4];\n                return [4, this._firstPersonImporter.import(gltf, humanoid)];\n\n              case 3:\n                _a = _c.sent() || undefined;\n                return [3, 5];\n\n              case 4:\n                _a = undefined;\n                _c.label = 5;\n\n              case 5:\n                firstPerson = _a;\n                return [4, this._blendShapeImporter.import(gltf)];\n\n              case 6:\n                blendShapeProxy = _c.sent() || undefined;\n                if (!(firstPerson && blendShapeProxy && humanoid)) return [3, 8];\n                return [4, this._lookAtImporter.import(gltf, firstPerson, blendShapeProxy, humanoid)];\n\n              case 7:\n                _b = _c.sent() || undefined;\n                return [3, 9];\n\n              case 8:\n                _b = undefined;\n                _c.label = 9;\n\n              case 9:\n                lookAt = _b;\n                return [4, this._springBoneImporter.import(gltf)];\n\n              case 10:\n                springBoneManager = _c.sent() || undefined;\n                return [2, new VRM_1.VRM({\n                  scene: gltf.scene,\n                  meta: vrmExt.meta,\n                  materials: materials,\n                  humanoid: humanoid,\n                  firstPerson: firstPerson,\n                  blendShapeProxy: blendShapeProxy,\n                  lookAt: lookAt,\n                  springBoneManager: springBoneManager\n                })];\n            }\n          });\n        });\n      };\n\n      return VRMImporter;\n    }();\n\n    exports.VRMImporter = VRMImporter;\n    /***/\n  },\n\n  /***/\n  \"./src/vrm/blendshape/VRMBlendShapeGroup.ts\":\n  /*!**************************************************!*\\\r\n    !*** ./src/vrm/blendshape/VRMBlendShapeGroup.ts ***!\r\n    \\**************************************************/\n\n  /*! no static exports found */\n\n  /***/\n  function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    var __extends = this && this.__extends || function () {\n      var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (d, b) {\n          d.__proto__ = b;\n        } || function (d, b) {\n          for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n        };\n\n        return extendStatics(d, b);\n      };\n\n      return function (d, b) {\n        extendStatics(d, b);\n\n        function __() {\n          this.constructor = d;\n        }\n\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n      };\n    }();\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n\n    var THREE = __webpack_require__(\n    /*! three */\n    \"three\");\n\n    var VRMBlendShapeMaterialValueType;\n\n    (function (VRMBlendShapeMaterialValueType) {\n      VRMBlendShapeMaterialValueType[VRMBlendShapeMaterialValueType[\"NUMBER\"] = 0] = \"NUMBER\";\n      VRMBlendShapeMaterialValueType[VRMBlendShapeMaterialValueType[\"VECTOR2\"] = 1] = \"VECTOR2\";\n      VRMBlendShapeMaterialValueType[VRMBlendShapeMaterialValueType[\"VECTOR3\"] = 2] = \"VECTOR3\";\n      VRMBlendShapeMaterialValueType[VRMBlendShapeMaterialValueType[\"VECTOR4\"] = 3] = \"VECTOR4\";\n      VRMBlendShapeMaterialValueType[VRMBlendShapeMaterialValueType[\"COLOR\"] = 4] = \"COLOR\";\n    })(VRMBlendShapeMaterialValueType || (VRMBlendShapeMaterialValueType = {}));\n\n    var _v2 = new THREE.Vector2();\n\n    var _v3 = new THREE.Vector3();\n\n    var _v4 = new THREE.Vector4();\n\n    var _color = new THREE.Color();\n\n    var VRMBlendShapeGroup = function (_super) {\n      __extends(VRMBlendShapeGroup, _super);\n\n      function VRMBlendShapeGroup(expressionName) {\n        var _this = _super.call(this) || this;\n\n        _this.weight = 0.0;\n        _this.isBinary = false;\n        _this._binds = [];\n        _this._materialValues = [];\n        _this.name = \"BlendShapeController_\" + expressionName;\n        _this.type = 'BlendShapeController';\n        _this.visible = false;\n        return _this;\n      }\n\n      VRMBlendShapeGroup.prototype.addBind = function (args) {\n        var weight = args.weight / 100;\n\n        this._binds.push({\n          meshes: args.meshes,\n          morphTargetIndex: args.morphTargetIndex,\n          weight: weight\n        });\n      };\n\n      VRMBlendShapeGroup.prototype.addMaterialValue = function (args) {\n        var material = args.material;\n        var propertyName = args.propertyName;\n        var value = material[propertyName];\n\n        if (!value) {\n          return;\n        }\n\n        value = args.defaultValue || value;\n        var type;\n        var defaultValue;\n        var targetValue;\n        var deltaValue;\n\n        if (value.isVector2) {\n          type = VRMBlendShapeMaterialValueType.VECTOR2;\n          defaultValue = value.clone();\n          targetValue = new THREE.Vector2().fromArray(args.targetValue);\n          deltaValue = targetValue.clone().sub(defaultValue);\n        } else if (value.isVector3) {\n          type = VRMBlendShapeMaterialValueType.VECTOR3;\n          defaultValue = value.clone();\n          targetValue = new THREE.Vector3().fromArray(args.targetValue);\n          deltaValue = targetValue.clone().sub(defaultValue);\n        } else if (value.isVector4) {\n          type = VRMBlendShapeMaterialValueType.VECTOR4;\n          defaultValue = value.clone();\n          targetValue = new THREE.Vector4().fromArray([args.targetValue[2], args.targetValue[3], args.targetValue[0], args.targetValue[1]]);\n          deltaValue = targetValue.clone().sub(defaultValue);\n        } else if (value.isColor) {\n          type = VRMBlendShapeMaterialValueType.COLOR;\n          defaultValue = value.clone();\n          targetValue = new THREE.Color().fromArray(args.targetValue);\n          deltaValue = targetValue.clone().sub(defaultValue);\n        } else {\n          type = VRMBlendShapeMaterialValueType.NUMBER;\n          defaultValue = value;\n          targetValue = args.targetValue[0];\n          deltaValue = targetValue - defaultValue;\n        }\n\n        this._materialValues.push({\n          material: material,\n          propertyName: propertyName,\n          defaultValue: defaultValue,\n          targetValue: targetValue,\n          deltaValue: deltaValue,\n          type: type\n        });\n      };\n\n      VRMBlendShapeGroup.prototype.applyWeight = function () {\n        var w = this.isBinary ? this.weight < 0.5 ? 0.0 : 1.0 : this.weight;\n\n        this._binds.forEach(function (bind) {\n          bind.meshes.forEach(function (mesh) {\n            if (!mesh.morphTargetInfluences) {\n              return;\n            }\n\n            mesh.morphTargetInfluences[bind.morphTargetIndex] += w * bind.weight;\n          });\n        });\n\n        this._materialValues.forEach(function (materialValue) {\n          var prop = materialValue.material[materialValue.propertyName];\n\n          if (prop === undefined) {\n            return;\n          }\n\n          if (materialValue.type === VRMBlendShapeMaterialValueType.NUMBER) {\n            var deltaValue = materialValue.deltaValue;\n            materialValue.material[materialValue.propertyName] += deltaValue * w;\n          } else if (materialValue.type === VRMBlendShapeMaterialValueType.VECTOR2) {\n            var deltaValue = materialValue.deltaValue;\n            materialValue.material[materialValue.propertyName].add(_v2.copy(deltaValue).multiplyScalar(w));\n          } else if (materialValue.type === VRMBlendShapeMaterialValueType.VECTOR3) {\n            var deltaValue = materialValue.deltaValue;\n            materialValue.material[materialValue.propertyName].add(_v3.copy(deltaValue).multiplyScalar(w));\n          } else if (materialValue.type === VRMBlendShapeMaterialValueType.VECTOR4) {\n            var deltaValue = materialValue.deltaValue;\n            materialValue.material[materialValue.propertyName].add(_v4.copy(deltaValue).multiplyScalar(w));\n          } else if (materialValue.type === VRMBlendShapeMaterialValueType.COLOR) {\n            var deltaValue = materialValue.deltaValue;\n            materialValue.material[materialValue.propertyName].add(_color.copy(deltaValue).multiplyScalar(w));\n          }\n\n          if (typeof materialValue.material.shouldApplyUniforms === 'boolean') {\n            materialValue.material.shouldApplyUniforms = true;\n          }\n        });\n      };\n\n      VRMBlendShapeGroup.prototype.clearAppliedWeight = function () {\n        this._binds.forEach(function (bind) {\n          bind.meshes.forEach(function (mesh) {\n            if (!mesh.morphTargetInfluences) {\n              return;\n            }\n\n            mesh.morphTargetInfluences[bind.morphTargetIndex] = 0.0;\n          });\n        });\n\n        this._materialValues.forEach(function (materialValue) {\n          var prop = materialValue.material[materialValue.propertyName];\n\n          if (prop === undefined) {\n            return;\n          }\n\n          if (materialValue.type === VRMBlendShapeMaterialValueType.NUMBER) {\n            var defaultValue = materialValue.defaultValue;\n            materialValue.material[materialValue.propertyName] = defaultValue;\n          } else if (materialValue.type === VRMBlendShapeMaterialValueType.VECTOR2) {\n            var defaultValue = materialValue.defaultValue;\n            materialValue.material[materialValue.propertyName].copy(defaultValue);\n          } else if (materialValue.type === VRMBlendShapeMaterialValueType.VECTOR3) {\n            var defaultValue = materialValue.defaultValue;\n            materialValue.material[materialValue.propertyName].copy(defaultValue);\n          } else if (materialValue.type === VRMBlendShapeMaterialValueType.VECTOR4) {\n            var defaultValue = materialValue.defaultValue;\n            materialValue.material[materialValue.propertyName].copy(defaultValue);\n          } else if (materialValue.type === VRMBlendShapeMaterialValueType.COLOR) {\n            var defaultValue = materialValue.defaultValue;\n            materialValue.material[materialValue.propertyName].copy(defaultValue);\n          }\n\n          if (typeof materialValue.material.shouldApplyUniforms === 'boolean') {\n            materialValue.material.shouldApplyUniforms = true;\n          }\n        });\n      };\n\n      return VRMBlendShapeGroup;\n    }(THREE.Object3D);\n\n    exports.VRMBlendShapeGroup = VRMBlendShapeGroup;\n    /***/\n  },\n\n  /***/\n  \"./src/vrm/blendshape/VRMBlendShapeImporter.ts\":\n  /*!*****************************************************!*\\\r\n    !*** ./src/vrm/blendshape/VRMBlendShapeImporter.ts ***!\r\n    \\*****************************************************/\n\n  /*! no static exports found */\n\n  /***/\n  function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n      return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) {\n          try {\n            step(generator.next(value));\n          } catch (e) {\n            reject(e);\n          }\n        }\n\n        function rejected(value) {\n          try {\n            step(generator[\"throw\"](value));\n          } catch (e) {\n            reject(e);\n          }\n        }\n\n        function step(result) {\n          result.done ? resolve(result.value) : new P(function (resolve) {\n            resolve(result.value);\n          }).then(fulfilled, rejected);\n        }\n\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n      });\n    };\n\n    var __generator = this && this.__generator || function (thisArg, body) {\n      var _ = {\n        label: 0,\n        sent: function () {\n          if (t[0] & 1) throw t[1];\n          return t[1];\n        },\n        trys: [],\n        ops: []\n      },\n          f,\n          y,\n          t,\n          g;\n      return g = {\n        next: verb(0),\n        \"throw\": verb(1),\n        \"return\": verb(2)\n      }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n        return this;\n      }), g;\n\n      function verb(n) {\n        return function (v) {\n          return step([n, v]);\n        };\n      }\n\n      function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n\n        while (_) try {\n          if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n          if (y = 0, t) op = [op[0] & 2, t.value];\n\n          switch (op[0]) {\n            case 0:\n            case 1:\n              t = op;\n              break;\n\n            case 4:\n              _.label++;\n              return {\n                value: op[1],\n                done: false\n              };\n\n            case 5:\n              _.label++;\n              y = op[1];\n              op = [0];\n              continue;\n\n            case 7:\n              op = _.ops.pop();\n\n              _.trys.pop();\n\n              continue;\n\n            default:\n              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n                _ = 0;\n                continue;\n              }\n\n              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n                _.label = op[1];\n                break;\n              }\n\n              if (op[0] === 6 && _.label < t[1]) {\n                _.label = t[1];\n                t = op;\n                break;\n              }\n\n              if (t && _.label < t[2]) {\n                _.label = t[2];\n\n                _.ops.push(op);\n\n                break;\n              }\n\n              if (t[2]) _.ops.pop();\n\n              _.trys.pop();\n\n              continue;\n          }\n\n          op = body.call(thisArg, _);\n        } catch (e) {\n          op = [6, e];\n          y = 0;\n        } finally {\n          f = t = 0;\n        }\n\n        if (op[0] & 5) throw op[1];\n        return {\n          value: op[0] ? op[1] : void 0,\n          done: true\n        };\n      }\n    };\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n\n    var types_1 = __webpack_require__(\n    /*! ../types */\n    \"./src/vrm/types/index.ts\");\n\n    var renameMaterialProperty_1 = __webpack_require__(\n    /*! ../utils/renameMaterialProperty */\n    \"./src/vrm/utils/renameMaterialProperty.ts\");\n\n    var VRMBlendShapeGroup_1 = __webpack_require__(\n    /*! ./VRMBlendShapeGroup */\n    \"./src/vrm/blendshape/VRMBlendShapeGroup.ts\");\n\n    var VRMBlendShapeProxy_1 = __webpack_require__(\n    /*! ./VRMBlendShapeProxy */\n    \"./src/vrm/blendshape/VRMBlendShapeProxy.ts\");\n\n    var VRMBlendShapeImporter = function () {\n      function VRMBlendShapeImporter() {}\n\n      VRMBlendShapeImporter.prototype.import = function (gltf) {\n        return __awaiter(this, void 0, Promise, function () {\n          var vrmExt, schemaBlendShape, blendShape, blendShapeGroups, blendShapePresetMap;\n\n          var _this = this;\n\n          return __generator(this, function (_a) {\n            switch (_a.label) {\n              case 0:\n                vrmExt = gltf.parser.json.extensions && gltf.parser.json.extensions.VRM;\n\n                if (!vrmExt) {\n                  return [2, null];\n                }\n\n                schemaBlendShape = vrmExt.blendShapeMaster;\n\n                if (!schemaBlendShape) {\n                  return [2, null];\n                }\n\n                blendShape = new VRMBlendShapeProxy_1.VRMBlendShapeProxy();\n                blendShapeGroups = schemaBlendShape.blendShapeGroups;\n\n                if (!blendShapeGroups) {\n                  return [2, blendShape];\n                }\n\n                blendShapePresetMap = {};\n                return [4, Promise.all(blendShapeGroups.map(function (schemaGroup) {\n                  return __awaiter(_this, void 0, void 0, function () {\n                    var name, presetName, group, materialValues;\n\n                    var _this = this;\n\n                    return __generator(this, function (_a) {\n                      name = schemaGroup.name;\n\n                      if (name === undefined) {\n                        console.warn('VRMBlendShapeImporter: One of blendShapeGroups has no name');\n                        return [2];\n                      }\n\n                      if (schemaGroup.presetName && schemaGroup.presetName !== types_1.VRMSchema.BlendShapePresetName.Unknown && !blendShapePresetMap[schemaGroup.presetName]) {\n                        presetName = schemaGroup.presetName;\n                        blendShapePresetMap[schemaGroup.presetName] = name;\n                      }\n\n                      group = new VRMBlendShapeGroup_1.VRMBlendShapeGroup(name);\n                      gltf.scene.add(group);\n                      group.isBinary = schemaGroup.isBinary || false;\n\n                      if (schemaGroup.binds) {\n                        schemaGroup.binds.forEach(function (bind) {\n                          return __awaiter(_this, void 0, void 0, function () {\n                            var morphMeshes, primitives, morphTargetIndex;\n                            return __generator(this, function (_a) {\n                              switch (_a.label) {\n                                case 0:\n                                  if (bind.mesh === undefined || bind.index === undefined) {\n                                    return [2];\n                                  }\n\n                                  return [4, gltf.parser.getDependency('mesh', bind.mesh)];\n\n                                case 1:\n                                  morphMeshes = _a.sent();\n                                  primitives = morphMeshes.type === 'Group' ? morphMeshes.children : [morphMeshes];\n                                  morphTargetIndex = bind.index;\n\n                                  if (!primitives.every(function (primitive) {\n                                    return Array.isArray(primitive.morphTargetInfluences) && morphTargetIndex < primitive.morphTargetInfluences.length;\n                                  })) {\n                                    console.warn(\"VRMBlendShapeImporter: \" + schemaGroup.name + \" attempts to index \" + morphTargetIndex + \"th morph but not found.\");\n                                    return [2];\n                                  }\n\n                                  group.addBind({\n                                    meshes: primitives,\n                                    morphTargetIndex: morphTargetIndex,\n                                    weight: bind.weight || 100\n                                  });\n                                  return [2];\n                              }\n                            });\n                          });\n                        });\n                      }\n\n                      materialValues = schemaGroup.materialValues;\n\n                      if (materialValues) {\n                        materialValues.forEach(function (materialValue) {\n                          if (materialValue.materialName === undefined || materialValue.propertyName === undefined || materialValue.targetValue === undefined) {\n                            return;\n                          }\n\n                          var materials = [];\n                          gltf.scene.traverse(function (object) {\n                            if (object.material) {\n                              var material = object.material;\n\n                              if (Array.isArray(material)) {\n                                materials.push.apply(materials, material.filter(function (mtl) {\n                                  return mtl.name === materialValue.materialName && materials.indexOf(mtl) === -1;\n                                }));\n                              } else if (material.name === materialValue.materialName && materials.indexOf(material) === -1) {\n                                materials.push(material);\n                              }\n                            }\n                          });\n                          materials.forEach(function (material) {\n                            group.addMaterialValue({\n                              material: material,\n                              propertyName: renameMaterialProperty_1.renameMaterialProperty(materialValue.propertyName),\n                              targetValue: materialValue.targetValue\n                            });\n                          });\n                        });\n                      }\n\n                      blendShape.registerBlendShapeGroup(name, presetName, group);\n                      return [2];\n                    });\n                  });\n                }))];\n\n              case 1:\n                _a.sent();\n\n                return [2, blendShape];\n            }\n          });\n        });\n      };\n\n      return VRMBlendShapeImporter;\n    }();\n\n    exports.VRMBlendShapeImporter = VRMBlendShapeImporter;\n    /***/\n  },\n\n  /***/\n  \"./src/vrm/blendshape/VRMBlendShapeProxy.ts\":\n  /*!**************************************************!*\\\r\n    !*** ./src/vrm/blendshape/VRMBlendShapeProxy.ts ***!\r\n    \\**************************************************/\n\n  /*! no static exports found */\n\n  /***/\n  function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n\n    var math_1 = __webpack_require__(\n    /*! ../utils/math */\n    \"./src/vrm/utils/math.ts\");\n\n    var VRMBlendShapeProxy = function () {\n      function VRMBlendShapeProxy() {\n        this._blendShapeGroups = {};\n        this._blendShapePresetMap = {};\n      }\n\n      Object.defineProperty(VRMBlendShapeProxy.prototype, \"expressions\", {\n        get: function () {\n          return Object.keys(this._blendShapeGroups);\n        },\n        enumerable: true,\n        configurable: true\n      });\n\n      VRMBlendShapeProxy.prototype.getBlendShapeGroup = function (name) {\n        var presetName = this._blendShapePresetMap[name];\n        var controller = presetName ? this._blendShapeGroups[presetName] : this._blendShapeGroups[name];\n\n        if (!controller) {\n          console.warn(\"no blend shape found by \" + name);\n          return undefined;\n        }\n\n        return controller;\n      };\n\n      VRMBlendShapeProxy.prototype.registerBlendShapeGroup = function (name, presetName, controller) {\n        this._blendShapeGroups[name] = controller;\n\n        if (presetName) {\n          this._blendShapePresetMap[presetName] = name;\n        }\n      };\n\n      VRMBlendShapeProxy.prototype.getValue = function (name) {\n        var controller = this.getBlendShapeGroup(name);\n        return controller && controller.weight || null;\n      };\n\n      VRMBlendShapeProxy.prototype.setValue = function (name, weight) {\n        var controller = this.getBlendShapeGroup(name);\n\n        if (controller) {\n          controller.weight = math_1.saturate(weight);\n        }\n      };\n\n      VRMBlendShapeProxy.prototype.getBlendShapeTrackName = function (name) {\n        var controller = this.getBlendShapeGroup(name);\n        return controller ? controller.name + \".weight\" : null;\n      };\n\n      VRMBlendShapeProxy.prototype.update = function () {\n        var _this = this;\n\n        Object.keys(this._blendShapeGroups).forEach(function (name) {\n          var controller = _this._blendShapeGroups[name];\n          controller.clearAppliedWeight();\n        });\n        Object.keys(this._blendShapeGroups).forEach(function (name) {\n          var controller = _this._blendShapeGroups[name];\n          controller.applyWeight();\n        });\n      };\n\n      return VRMBlendShapeProxy;\n    }();\n\n    exports.VRMBlendShapeProxy = VRMBlendShapeProxy;\n    /***/\n  },\n\n  /***/\n  \"./src/vrm/blendshape/index.ts\":\n  /*!*************************************!*\\\r\n    !*** ./src/vrm/blendshape/index.ts ***!\r\n    \\*************************************/\n\n  /*! no static exports found */\n\n  /***/\n  function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    function __export(m) {\n      for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n    }\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n\n    __export(__webpack_require__(\n    /*! ./VRMBlendShapeGroup */\n    \"./src/vrm/blendshape/VRMBlendShapeGroup.ts\"));\n\n    __export(__webpack_require__(\n    /*! ./VRMBlendShapeImporter */\n    \"./src/vrm/blendshape/VRMBlendShapeImporter.ts\"));\n\n    __export(__webpack_require__(\n    /*! ./VRMBlendShapeProxy */\n    \"./src/vrm/blendshape/VRMBlendShapeProxy.ts\"));\n    /***/\n\n  },\n\n  /***/\n  \"./src/vrm/debug/VRMDebug.ts\":\n  /*!***********************************!*\\\r\n    !*** ./src/vrm/debug/VRMDebug.ts ***!\r\n    \\***********************************/\n\n  /*! no static exports found */\n\n  /***/\n  function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    var __extends = this && this.__extends || function () {\n      var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (d, b) {\n          d.__proto__ = b;\n        } || function (d, b) {\n          for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n        };\n\n        return extendStatics(d, b);\n      };\n\n      return function (d, b) {\n        extendStatics(d, b);\n\n        function __() {\n          this.constructor = d;\n        }\n\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n      };\n    }();\n\n    var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n      return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) {\n          try {\n            step(generator.next(value));\n          } catch (e) {\n            reject(e);\n          }\n        }\n\n        function rejected(value) {\n          try {\n            step(generator[\"throw\"](value));\n          } catch (e) {\n            reject(e);\n          }\n        }\n\n        function step(result) {\n          result.done ? resolve(result.value) : new P(function (resolve) {\n            resolve(result.value);\n          }).then(fulfilled, rejected);\n        }\n\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n      });\n    };\n\n    var __generator = this && this.__generator || function (thisArg, body) {\n      var _ = {\n        label: 0,\n        sent: function () {\n          if (t[0] & 1) throw t[1];\n          return t[1];\n        },\n        trys: [],\n        ops: []\n      },\n          f,\n          y,\n          t,\n          g;\n      return g = {\n        next: verb(0),\n        \"throw\": verb(1),\n        \"return\": verb(2)\n      }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n        return this;\n      }), g;\n\n      function verb(n) {\n        return function (v) {\n          return step([n, v]);\n        };\n      }\n\n      function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n\n        while (_) try {\n          if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n          if (y = 0, t) op = [op[0] & 2, t.value];\n\n          switch (op[0]) {\n            case 0:\n            case 1:\n              t = op;\n              break;\n\n            case 4:\n              _.label++;\n              return {\n                value: op[1],\n                done: false\n              };\n\n            case 5:\n              _.label++;\n              y = op[1];\n              op = [0];\n              continue;\n\n            case 7:\n              op = _.ops.pop();\n\n              _.trys.pop();\n\n              continue;\n\n            default:\n              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n                _ = 0;\n                continue;\n              }\n\n              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n                _.label = op[1];\n                break;\n              }\n\n              if (op[0] === 6 && _.label < t[1]) {\n                _.label = t[1];\n                t = op;\n                break;\n              }\n\n              if (t && _.label < t[2]) {\n                _.label = t[2];\n\n                _.ops.push(op);\n\n                break;\n              }\n\n              if (t[2]) _.ops.pop();\n\n              _.trys.pop();\n\n              continue;\n          }\n\n          op = body.call(thisArg, _);\n        } catch (e) {\n          op = [6, e];\n          y = 0;\n        } finally {\n          f = t = 0;\n        }\n\n        if (op[0] & 5) throw op[1];\n        return {\n          value: op[0] ? op[1] : void 0,\n          done: true\n        };\n      }\n    };\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n\n    var THREE = __webpack_require__(\n    /*! three */\n    \"three\");\n\n    var VRM_1 = __webpack_require__(\n    /*! ../VRM */\n    \"./src/vrm/VRM.ts\");\n\n    var VRMImporterDebug_1 = __webpack_require__(\n    /*! ./VRMImporterDebug */\n    \"./src/vrm/debug/VRMImporterDebug.ts\");\n\n    var VRMDebug = function (_super) {\n      __extends(VRMDebug, _super);\n\n      function VRMDebug(params, debugOption) {\n        if (debugOption === void 0) {\n          debugOption = {};\n        }\n\n        var _this = _super.call(this, params) || this;\n\n        if (!debugOption.disableBoxHelper) {\n          _this.scene.add(new THREE.BoxHelper(_this.scene));\n        }\n\n        if (!debugOption.disableSkeletonHelper) {\n          _this.scene.add(new THREE.SkeletonHelper(_this.scene));\n        }\n\n        return _this;\n      }\n\n      VRMDebug.from = function (gltf, options, debugOption) {\n        if (options === void 0) {\n          options = {};\n        }\n\n        if (debugOption === void 0) {\n          debugOption = {};\n        }\n\n        return __awaiter(this, void 0, Promise, function () {\n          var importer;\n          return __generator(this, function (_a) {\n            switch (_a.label) {\n              case 0:\n                importer = new VRMImporterDebug_1.VRMImporterDebug(options);\n                return [4, importer.import(gltf, debugOption)];\n\n              case 1:\n                return [2, _a.sent()];\n            }\n          });\n        });\n      };\n\n      VRMDebug.prototype.update = function (delta) {\n        _super.prototype.update.call(this, delta);\n      };\n\n      return VRMDebug;\n    }(VRM_1.VRM);\n\n    exports.VRMDebug = VRMDebug;\n    /***/\n  },\n\n  /***/\n  \"./src/vrm/debug/VRMDebugOptions.ts\":\n  /*!******************************************!*\\\r\n    !*** ./src/vrm/debug/VRMDebugOptions.ts ***!\r\n    \\******************************************/\n\n  /*! no static exports found */\n\n  /***/\n  function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n    /***/\n  },\n\n  /***/\n  \"./src/vrm/debug/VRMImporterDebug.ts\":\n  /*!*******************************************!*\\\r\n    !*** ./src/vrm/debug/VRMImporterDebug.ts ***!\r\n    \\*******************************************/\n\n  /*! no static exports found */\n\n  /***/\n  function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    var __extends = this && this.__extends || function () {\n      var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (d, b) {\n          d.__proto__ = b;\n        } || function (d, b) {\n          for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n        };\n\n        return extendStatics(d, b);\n      };\n\n      return function (d, b) {\n        extendStatics(d, b);\n\n        function __() {\n          this.constructor = d;\n        }\n\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n      };\n    }();\n\n    var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n      return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) {\n          try {\n            step(generator.next(value));\n          } catch (e) {\n            reject(e);\n          }\n        }\n\n        function rejected(value) {\n          try {\n            step(generator[\"throw\"](value));\n          } catch (e) {\n            reject(e);\n          }\n        }\n\n        function step(result) {\n          result.done ? resolve(result.value) : new P(function (resolve) {\n            resolve(result.value);\n          }).then(fulfilled, rejected);\n        }\n\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n      });\n    };\n\n    var __generator = this && this.__generator || function (thisArg, body) {\n      var _ = {\n        label: 0,\n        sent: function () {\n          if (t[0] & 1) throw t[1];\n          return t[1];\n        },\n        trys: [],\n        ops: []\n      },\n          f,\n          y,\n          t,\n          g;\n      return g = {\n        next: verb(0),\n        \"throw\": verb(1),\n        \"return\": verb(2)\n      }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n        return this;\n      }), g;\n\n      function verb(n) {\n        return function (v) {\n          return step([n, v]);\n        };\n      }\n\n      function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n\n        while (_) try {\n          if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n          if (y = 0, t) op = [op[0] & 2, t.value];\n\n          switch (op[0]) {\n            case 0:\n            case 1:\n              t = op;\n              break;\n\n            case 4:\n              _.label++;\n              return {\n                value: op[1],\n                done: false\n              };\n\n            case 5:\n              _.label++;\n              y = op[1];\n              op = [0];\n              continue;\n\n            case 7:\n              op = _.ops.pop();\n\n              _.trys.pop();\n\n              continue;\n\n            default:\n              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n                _ = 0;\n                continue;\n              }\n\n              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n                _.label = op[1];\n                break;\n              }\n\n              if (op[0] === 6 && _.label < t[1]) {\n                _.label = t[1];\n                t = op;\n                break;\n              }\n\n              if (t && _.label < t[2]) {\n                _.label = t[2];\n\n                _.ops.push(op);\n\n                break;\n              }\n\n              if (t[2]) _.ops.pop();\n\n              _.trys.pop();\n\n              continue;\n          }\n\n          op = body.call(thisArg, _);\n        } catch (e) {\n          op = [6, e];\n          y = 0;\n        } finally {\n          f = t = 0;\n        }\n\n        if (op[0] & 5) throw op[1];\n        return {\n          value: op[0] ? op[1] : void 0,\n          done: true\n        };\n      }\n    };\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n\n    var reduceBones_1 = __webpack_require__(\n    /*! ../reduceBones */\n    \"./src/vrm/reduceBones.ts\");\n\n    var VRMImporter_1 = __webpack_require__(\n    /*! ../VRMImporter */\n    \"./src/vrm/VRMImporter.ts\");\n\n    var VRMDebug_1 = __webpack_require__(\n    /*! ./VRMDebug */\n    \"./src/vrm/debug/VRMDebug.ts\");\n\n    var VRMLookAtImporterDebug_1 = __webpack_require__(\n    /*! ./VRMLookAtImporterDebug */\n    \"./src/vrm/debug/VRMLookAtImporterDebug.ts\");\n\n    var VRMSpringBoneImporterDebug_1 = __webpack_require__(\n    /*! ./VRMSpringBoneImporterDebug */\n    \"./src/vrm/debug/VRMSpringBoneImporterDebug.ts\");\n\n    var VRMImporterDebug = function (_super) {\n      __extends(VRMImporterDebug, _super);\n\n      function VRMImporterDebug(options) {\n        if (options === void 0) {\n          options = {};\n        }\n\n        var _this = this;\n\n        options.lookAtImporter = options.lookAtImporter || new VRMLookAtImporterDebug_1.VRMLookAtImporterDebug();\n        options.springBoneImporter = options.springBoneImporter || new VRMSpringBoneImporterDebug_1.VRMSpringBoneImporterDebug();\n        _this = _super.call(this, options) || this;\n        return _this;\n      }\n\n      VRMImporterDebug.prototype.import = function (gltf, debugOptions) {\n        if (debugOptions === void 0) {\n          debugOptions = {};\n        }\n\n        return __awaiter(this, void 0, Promise, function () {\n          var vrmExt, scene, materials, humanoid, firstPerson, _a, blendShapeProxy, lookAt, _b, springBoneManager;\n\n          return __generator(this, function (_c) {\n            switch (_c.label) {\n              case 0:\n                if (gltf.parser.json.extensions === undefined || gltf.parser.json.extensions.VRM === undefined) {\n                  throw new Error('Could not find VRM extension on the GLTF');\n                }\n\n                vrmExt = gltf.parser.json.extensions.VRM;\n                scene = gltf.scene;\n                scene.updateMatrixWorld(false);\n                scene.traverse(function (object3d) {\n                  if (object3d.isMesh) {\n                    object3d.frustumCulled = false;\n                  }\n                });\n                reduceBones_1.reduceBones(scene);\n                return [4, this._materialImporter.convertGLTFMaterials(gltf)];\n\n              case 1:\n                materials = _c.sent() || undefined;\n                return [4, this._humanoidImporter.import(gltf)];\n\n              case 2:\n                humanoid = _c.sent() || undefined;\n                if (!humanoid) return [3, 4];\n                return [4, this._firstPersonImporter.import(gltf, humanoid)];\n\n              case 3:\n                _a = _c.sent() || undefined;\n                return [3, 5];\n\n              case 4:\n                _a = undefined;\n                _c.label = 5;\n\n              case 5:\n                firstPerson = _a;\n                return [4, this._blendShapeImporter.import(gltf)];\n\n              case 6:\n                blendShapeProxy = _c.sent() || undefined;\n                if (!(firstPerson && blendShapeProxy && humanoid)) return [3, 8];\n                return [4, this._lookAtImporter.import(gltf, firstPerson, blendShapeProxy, humanoid)];\n\n              case 7:\n                _b = _c.sent() || undefined;\n                return [3, 9];\n\n              case 8:\n                _b = undefined;\n                _c.label = 9;\n\n              case 9:\n                lookAt = _b;\n\n                if (lookAt.setupHelper) {\n                  lookAt.setupHelper(scene, debugOptions);\n                }\n\n                return [4, this._springBoneImporter.import(gltf)];\n\n              case 10:\n                springBoneManager = _c.sent() || undefined;\n                return [2, new VRMDebug_1.VRMDebug({\n                  scene: gltf.scene,\n                  meta: vrmExt.meta,\n                  materials: materials,\n                  humanoid: humanoid,\n                  firstPerson: firstPerson,\n                  blendShapeProxy: blendShapeProxy,\n                  lookAt: lookAt,\n                  springBoneManager: springBoneManager\n                }, debugOptions)];\n            }\n          });\n        });\n      };\n\n      return VRMImporterDebug;\n    }(VRMImporter_1.VRMImporter);\n\n    exports.VRMImporterDebug = VRMImporterDebug;\n    /***/\n  },\n\n  /***/\n  \"./src/vrm/debug/VRMLookAtHeadDebug.ts\":\n  /*!*********************************************!*\\\r\n    !*** ./src/vrm/debug/VRMLookAtHeadDebug.ts ***!\r\n    \\*********************************************/\n\n  /*! no static exports found */\n\n  /***/\n  function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    var __extends = this && this.__extends || function () {\n      var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (d, b) {\n          d.__proto__ = b;\n        } || function (d, b) {\n          for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n        };\n\n        return extendStatics(d, b);\n      };\n\n      return function (d, b) {\n        extendStatics(d, b);\n\n        function __() {\n          this.constructor = d;\n        }\n\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n      };\n    }();\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n\n    var THREE = __webpack_require__(\n    /*! three */\n    \"three\");\n\n    var VRMLookAtHead_1 = __webpack_require__(\n    /*! ../lookat/VRMLookAtHead */\n    \"./src/vrm/lookat/VRMLookAtHead.ts\");\n\n    var _v3 = new THREE.Vector3();\n\n    var VRMLookAtHeadDebug = function (_super) {\n      __extends(VRMLookAtHeadDebug, _super);\n\n      function VRMLookAtHeadDebug() {\n        return _super !== null && _super.apply(this, arguments) || this;\n      }\n\n      VRMLookAtHeadDebug.prototype.setupHelper = function (scene, debugOption) {\n        if (!debugOption.disableFaceDirectionHelper) {\n          this._faceDirectionHelper = new THREE.ArrowHelper(new THREE.Vector3(0, 0, -1), new THREE.Vector3(0, 0, 0), 0.5, 0xff00ff);\n          scene.add(this._faceDirectionHelper);\n        }\n      };\n\n      VRMLookAtHeadDebug.prototype.update = function (delta) {\n        _super.prototype.update.call(this, delta);\n\n        if (this._faceDirectionHelper) {\n          this.firstPerson.getFirstPersonWorldPosition(this._faceDirectionHelper.position);\n\n          this._faceDirectionHelper.setDirection(this.getLookAtWorldDirection(_v3));\n        }\n      };\n\n      return VRMLookAtHeadDebug;\n    }(VRMLookAtHead_1.VRMLookAtHead);\n\n    exports.VRMLookAtHeadDebug = VRMLookAtHeadDebug;\n    /***/\n  },\n\n  /***/\n  \"./src/vrm/debug/VRMLookAtImporterDebug.ts\":\n  /*!*************************************************!*\\\r\n    !*** ./src/vrm/debug/VRMLookAtImporterDebug.ts ***!\r\n    \\*************************************************/\n\n  /*! no static exports found */\n\n  /***/\n  function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    var __extends = this && this.__extends || function () {\n      var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (d, b) {\n          d.__proto__ = b;\n        } || function (d, b) {\n          for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n        };\n\n        return extendStatics(d, b);\n      };\n\n      return function (d, b) {\n        extendStatics(d, b);\n\n        function __() {\n          this.constructor = d;\n        }\n\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n      };\n    }();\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n\n    var VRMLookAtImporter_1 = __webpack_require__(\n    /*! ../lookat/VRMLookAtImporter */\n    \"./src/vrm/lookat/VRMLookAtImporter.ts\");\n\n    var VRMLookAtHeadDebug_1 = __webpack_require__(\n    /*! ./VRMLookAtHeadDebug */\n    \"./src/vrm/debug/VRMLookAtHeadDebug.ts\");\n\n    var VRMLookAtImporterDebug = function (_super) {\n      __extends(VRMLookAtImporterDebug, _super);\n\n      function VRMLookAtImporterDebug() {\n        return _super !== null && _super.apply(this, arguments) || this;\n      }\n\n      VRMLookAtImporterDebug.prototype.import = function (gltf, firstPerson, blendShapeProxy, humanoid) {\n        var vrmExt = gltf.parser.json.extensions && gltf.parser.json.extensions.VRM;\n\n        if (!vrmExt) {\n          return null;\n        }\n\n        var schemaFirstPerson = vrmExt.firstPerson;\n\n        if (!schemaFirstPerson) {\n          return null;\n        }\n\n        var applyer = this._importApplyer(schemaFirstPerson, blendShapeProxy, humanoid);\n\n        return new VRMLookAtHeadDebug_1.VRMLookAtHeadDebug(firstPerson, applyer || undefined);\n      };\n\n      return VRMLookAtImporterDebug;\n    }(VRMLookAtImporter_1.VRMLookAtImporter);\n\n    exports.VRMLookAtImporterDebug = VRMLookAtImporterDebug;\n    /***/\n  },\n\n  /***/\n  \"./src/vrm/debug/VRMSpringBoneDebug.ts\":\n  /*!*********************************************!*\\\r\n    !*** ./src/vrm/debug/VRMSpringBoneDebug.ts ***!\r\n    \\*********************************************/\n\n  /*! no static exports found */\n\n  /***/\n  function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    var __extends = this && this.__extends || function () {\n      var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (d, b) {\n          d.__proto__ = b;\n        } || function (d, b) {\n          for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n        };\n\n        return extendStatics(d, b);\n      };\n\n      return function (d, b) {\n        extendStatics(d, b);\n\n        function __() {\n          this.constructor = d;\n        }\n\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n      };\n    }();\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n\n    var THREE = __webpack_require__(\n    /*! three */\n    \"three\");\n\n    var springbone_1 = __webpack_require__(\n    /*! ../springbone */\n    \"./src/vrm/springbone/index.ts\");\n\n    var _v3A = new THREE.Vector3();\n\n    var VRMSpringBoneDebug = function (_super) {\n      __extends(VRMSpringBoneDebug, _super);\n\n      function VRMSpringBoneDebug(bone, radius, stiffiness, gravityDir, gravityPower, dragForce, colliders) {\n        if (colliders === void 0) {\n          colliders = [];\n        }\n\n        return _super.call(this, bone, radius, stiffiness, gravityDir, gravityPower, dragForce, colliders) || this;\n      }\n\n      VRMSpringBoneDebug.prototype.getGizmo = function () {\n        if (this._gizmo) {\n          return this._gizmo;\n        }\n\n        var nextTailRelative = _v3A.copy(this._nextTail).sub(this._worldPosition);\n\n        var nextTailRelativeLength = nextTailRelative.length();\n        this._gizmo = new THREE.ArrowHelper(nextTailRelative.normalize(), this._worldPosition, nextTailRelativeLength, 0xffff00, this.radius, this.radius);\n        this._gizmo.line.renderOrder = springbone_1.GIZMO_RENDER_ORDER;\n        this._gizmo.cone.renderOrder = springbone_1.GIZMO_RENDER_ORDER;\n        this._gizmo.line.material.depthTest = false;\n        this._gizmo.line.material.transparent = true;\n        this._gizmo.cone.material.depthTest = false;\n        this._gizmo.cone.material.transparent = true;\n        return this._gizmo;\n      };\n\n      VRMSpringBoneDebug.prototype.update = function (delta) {\n        _super.prototype.update.call(this, delta);\n\n        this._updateGizmo();\n      };\n\n      VRMSpringBoneDebug.prototype._updateGizmo = function () {\n        if (!this._gizmo) {\n          return;\n        }\n\n        var nextTailRelative = _v3A.copy(this._currentTail).sub(this._worldPosition);\n\n        var nextTailRelativeLength = nextTailRelative.length();\n\n        this._gizmo.setDirection(nextTailRelative.normalize());\n\n        this._gizmo.setLength(nextTailRelativeLength, this.radius, this.radius);\n\n        this._gizmo.position.copy(this._worldPosition);\n      };\n\n      return VRMSpringBoneDebug;\n    }(springbone_1.VRMSpringBone);\n\n    exports.VRMSpringBoneDebug = VRMSpringBoneDebug;\n    /***/\n  },\n\n  /***/\n  \"./src/vrm/debug/VRMSpringBoneImporterDebug.ts\":\n  /*!*****************************************************!*\\\r\n    !*** ./src/vrm/debug/VRMSpringBoneImporterDebug.ts ***!\r\n    \\*****************************************************/\n\n  /*! no static exports found */\n\n  /***/\n  function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    var __extends = this && this.__extends || function () {\n      var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (d, b) {\n          d.__proto__ = b;\n        } || function (d, b) {\n          for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n        };\n\n        return extendStatics(d, b);\n      };\n\n      return function (d, b) {\n        extendStatics(d, b);\n\n        function __() {\n          this.constructor = d;\n        }\n\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n      };\n    }();\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n\n    var VRMSpringBoneImporter_1 = __webpack_require__(\n    /*! ../springbone/VRMSpringBoneImporter */\n    \"./src/vrm/springbone/VRMSpringBoneImporter.ts\");\n\n    var VRMSpringBoneDebug_1 = __webpack_require__(\n    /*! ./VRMSpringBoneDebug */\n    \"./src/vrm/debug/VRMSpringBoneDebug.ts\");\n\n    var VRMSpringBoneImporterDebug = function (_super) {\n      __extends(VRMSpringBoneImporterDebug, _super);\n\n      function VRMSpringBoneImporterDebug() {\n        return _super !== null && _super.apply(this, arguments) || this;\n      }\n\n      Object.defineProperty(VRMSpringBoneImporterDebug.prototype, \"_isColiderMeshVisible\", {\n        get: function () {\n          return true;\n        },\n        enumerable: true,\n        configurable: true\n      });\n\n      VRMSpringBoneImporterDebug.prototype._createSpringBone = function (gltf, bone, hitRadius, stiffiness, gravityDir, gravityPower, dragForce, colliders) {\n        if (colliders === void 0) {\n          colliders = [];\n        }\n\n        var springBone = new VRMSpringBoneDebug_1.VRMSpringBoneDebug(bone, hitRadius, stiffiness, gravityDir, gravityPower, dragForce, colliders);\n        gltf.scene.add(springBone.getGizmo());\n        return springBone;\n      };\n\n      return VRMSpringBoneImporterDebug;\n    }(VRMSpringBoneImporter_1.VRMSpringBoneImporter);\n\n    exports.VRMSpringBoneImporterDebug = VRMSpringBoneImporterDebug;\n    /***/\n  },\n\n  /***/\n  \"./src/vrm/debug/index.ts\":\n  /*!********************************!*\\\r\n    !*** ./src/vrm/debug/index.ts ***!\r\n    \\********************************/\n\n  /*! no static exports found */\n\n  /***/\n  function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    function __export(m) {\n      for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n    }\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n\n    __export(__webpack_require__(\n    /*! ./VRMDebugOptions */\n    \"./src/vrm/debug/VRMDebugOptions.ts\"));\n\n    __export(__webpack_require__(\n    /*! ./VRMDebug */\n    \"./src/vrm/debug/VRMDebug.ts\"));\n\n    __export(__webpack_require__(\n    /*! ./VRMSpringBoneDebug */\n    \"./src/vrm/debug/VRMSpringBoneDebug.ts\"));\n\n    __export(__webpack_require__(\n    /*! ./VRMSpringBoneImporterDebug */\n    \"./src/vrm/debug/VRMSpringBoneImporterDebug.ts\"));\n    /***/\n\n  },\n\n  /***/\n  \"./src/vrm/firstperson/VRMFirstPerson.ts\":\n  /*!***********************************************!*\\\r\n    !*** ./src/vrm/firstperson/VRMFirstPerson.ts ***!\r\n    \\***********************************************/\n\n  /*! no static exports found */\n\n  /***/\n  function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n\n    var THREE = __webpack_require__(\n    /*! three */\n    \"three\");\n\n    var math_1 = __webpack_require__(\n    /*! ../utils/math */\n    \"./src/vrm/utils/math.ts\");\n\n    var VECTOR3_FRONT = Object.freeze(new THREE.Vector3(0.0, 0.0, -1.0));\n\n    var _quat = new THREE.Quaternion();\n\n    var FirstPersonFlag;\n\n    (function (FirstPersonFlag) {\n      FirstPersonFlag[FirstPersonFlag[\"Auto\"] = 0] = \"Auto\";\n      FirstPersonFlag[FirstPersonFlag[\"Both\"] = 1] = \"Both\";\n      FirstPersonFlag[FirstPersonFlag[\"ThirdPersonOnly\"] = 2] = \"ThirdPersonOnly\";\n      FirstPersonFlag[FirstPersonFlag[\"FirstPersonOnly\"] = 3] = \"FirstPersonOnly\";\n    })(FirstPersonFlag || (FirstPersonFlag = {}));\n\n    var VRMRendererFirstPersonFlags = function () {\n      function VRMRendererFirstPersonFlags(firstPersonFlag, mesh) {\n        this.firstPersonFlag = VRMRendererFirstPersonFlags._parseFirstPersonFlag(firstPersonFlag);\n        this.mesh = mesh;\n      }\n\n      VRMRendererFirstPersonFlags._parseFirstPersonFlag = function (firstPersonFlag) {\n        switch (firstPersonFlag) {\n          case 'Both':\n            return FirstPersonFlag.Both;\n\n          case 'ThirdPersonOnly':\n            return FirstPersonFlag.ThirdPersonOnly;\n\n          case 'FirstPersonOnly':\n            return FirstPersonFlag.FirstPersonOnly;\n\n          default:\n            return FirstPersonFlag.Auto;\n        }\n      };\n\n      return VRMRendererFirstPersonFlags;\n    }();\n\n    exports.VRMRendererFirstPersonFlags = VRMRendererFirstPersonFlags;\n\n    var VRMFirstPerson = function () {\n      function VRMFirstPerson(firstPersonBone, firstPersonBoneOffset, meshAnnotations) {\n        this._meshAnnotations = [];\n        this._firstPersonOnlyLayer = VRMFirstPerson._DEFAULT_FIRSTPERSON_ONLY_LAYER;\n        this._thirdPersonOnlyLayer = VRMFirstPerson._DEFAULT_THIRDPERSON_ONLY_LAYER;\n        this._initialized = false;\n        this._firstPersonBone = firstPersonBone;\n        this._firstPersonBoneOffset = firstPersonBoneOffset;\n        this._meshAnnotations = meshAnnotations;\n      }\n\n      Object.defineProperty(VRMFirstPerson.prototype, \"firstPersonBone\", {\n        get: function () {\n          return this._firstPersonBone;\n        },\n        enumerable: true,\n        configurable: true\n      });\n      Object.defineProperty(VRMFirstPerson.prototype, \"meshAnnotations\", {\n        get: function () {\n          return this._meshAnnotations;\n        },\n        enumerable: true,\n        configurable: true\n      });\n\n      VRMFirstPerson.prototype.getFirstPersonWorldDirection = function (target) {\n        return target.copy(VECTOR3_FRONT).applyQuaternion(math_1.getWorldQuaternionLite(this._firstPersonBone, _quat));\n      };\n\n      Object.defineProperty(VRMFirstPerson.prototype, \"firstPersonOnlyLayer\", {\n        get: function () {\n          return this._firstPersonOnlyLayer;\n        },\n        enumerable: true,\n        configurable: true\n      });\n      Object.defineProperty(VRMFirstPerson.prototype, \"thirdPersonOnlyLayer\", {\n        get: function () {\n          return this._thirdPersonOnlyLayer;\n        },\n        enumerable: true,\n        configurable: true\n      });\n\n      VRMFirstPerson.prototype.getFirstPersonBoneOffset = function (target) {\n        return target.copy(this._firstPersonBoneOffset);\n      };\n\n      VRMFirstPerson.prototype.getFirstPersonWorldPosition = function (v3) {\n        var offset = this._firstPersonBoneOffset;\n        var v4 = new THREE.Vector4(offset.x, offset.y, offset.z, 1.0);\n        v4.applyMatrix4(this._firstPersonBone.matrixWorld);\n        return v3.set(v4.x, v4.y, v4.z);\n      };\n\n      VRMFirstPerson.prototype.setup = function (_a) {\n        var _this = this;\n\n        var _b = _a === void 0 ? {} : _a,\n            _c = _b.firstPersonOnlyLayer,\n            firstPersonOnlyLayer = _c === void 0 ? VRMFirstPerson._DEFAULT_FIRSTPERSON_ONLY_LAYER : _c,\n            _d = _b.thirdPersonOnlyLayer,\n            thirdPersonOnlyLayer = _d === void 0 ? VRMFirstPerson._DEFAULT_THIRDPERSON_ONLY_LAYER : _d;\n\n        if (this._initialized) {\n          return;\n        }\n\n        this._initialized = true;\n        this._firstPersonOnlyLayer = firstPersonOnlyLayer;\n        this._thirdPersonOnlyLayer = thirdPersonOnlyLayer;\n\n        this._meshAnnotations.forEach(function (item) {\n          if (item.firstPersonFlag === FirstPersonFlag.FirstPersonOnly) {\n            item.mesh.layers.set(_this._firstPersonOnlyLayer);\n            item.mesh.traverse(function (child) {\n              return child.layers.set(_this._firstPersonOnlyLayer);\n            });\n          } else if (item.firstPersonFlag === FirstPersonFlag.ThirdPersonOnly) {\n            item.mesh.layers.set(_this._thirdPersonOnlyLayer);\n            item.mesh.traverse(function (child) {\n              return child.layers.set(_this._thirdPersonOnlyLayer);\n            });\n          } else if (item.firstPersonFlag === FirstPersonFlag.Auto) {\n            _this._createHeadlessModel(item.mesh);\n          }\n        });\n      };\n\n      VRMFirstPerson.prototype._excludeTriangles = function (triangles, bws, skinIndex, exclude) {\n        var count = 0;\n\n        if (bws != null && bws.length > 0) {\n          for (var i = 0; i < triangles.length; i += 3) {\n            var a = triangles[i];\n            var b = triangles[i + 1];\n            var c = triangles[i + 2];\n            var bw0 = bws[a];\n            var skin0 = skinIndex[a];\n            if (bw0[0] > 0 && exclude.includes(skin0[0])) continue;\n            if (bw0[1] > 0 && exclude.includes(skin0[1])) continue;\n            if (bw0[2] > 0 && exclude.includes(skin0[2])) continue;\n            if (bw0[3] > 0 && exclude.includes(skin0[3])) continue;\n            var bw1 = bws[b];\n            var skin1 = skinIndex[b];\n            if (bw1[0] > 0 && exclude.includes(skin1[0])) continue;\n            if (bw1[1] > 0 && exclude.includes(skin1[1])) continue;\n            if (bw1[2] > 0 && exclude.includes(skin1[2])) continue;\n            if (bw1[3] > 0 && exclude.includes(skin1[3])) continue;\n            var bw2 = bws[c];\n            var skin2 = skinIndex[c];\n            if (bw2[0] > 0 && exclude.includes(skin2[0])) continue;\n            if (bw2[1] > 0 && exclude.includes(skin2[1])) continue;\n            if (bw2[2] > 0 && exclude.includes(skin2[2])) continue;\n            if (bw2[3] > 0 && exclude.includes(skin2[3])) continue;\n            triangles[count++] = a;\n            triangles[count++] = b;\n            triangles[count++] = c;\n          }\n        }\n\n        return count;\n      };\n\n      VRMFirstPerson.prototype._createErasedMesh = function (src, erasingBonesIndex) {\n        var dst = new THREE.SkinnedMesh(src.geometry.clone(), src.material);\n        dst.name = src.name + \"(erase)\";\n        dst.frustumCulled = src.frustumCulled;\n        dst.layers.set(this._firstPersonOnlyLayer);\n        var geometry = dst.geometry;\n        var skinIndexAttr = geometry.getAttribute('skinIndex').array;\n        var skinIndex = [];\n\n        for (var i = 0; i < skinIndexAttr.length; i += 4) {\n          skinIndex.push([skinIndexAttr[i], skinIndexAttr[i + 1], skinIndexAttr[i + 2], skinIndexAttr[i + 3]]);\n        }\n\n        var skinWeightAttr = geometry.getAttribute('skinWeight').array;\n        var skinWeight = [];\n\n        for (var i = 0; i < skinWeightAttr.length; i += 4) {\n          skinWeight.push([skinWeightAttr[i], skinWeightAttr[i + 1], skinWeightAttr[i + 2], skinWeightAttr[i + 3]]);\n        }\n\n        var oldTriangles = Array.from(geometry.getIndex().array);\n\n        var count = this._excludeTriangles(oldTriangles, skinWeight, skinIndex, erasingBonesIndex);\n\n        var newTriangle = [];\n\n        for (var i = 0; i < count; i++) {\n          newTriangle[i] = oldTriangles[i];\n        }\n\n        geometry.setIndex(newTriangle);\n\n        if (src.onBeforeRender) {\n          dst.onBeforeRender = src.onBeforeRender;\n        }\n\n        dst.bind(new THREE.Skeleton(src.skeleton.bones, src.skeleton.boneInverses), new THREE.Matrix4());\n        return dst;\n      };\n\n      VRMFirstPerson.prototype._createHeadlessModelForSkinnedMesh = function (parent, mesh) {\n        var _this = this;\n\n        var eraseBoneIndexes = [];\n        mesh.skeleton.bones.forEach(function (bone, index) {\n          if (_this._isEraseTarget(bone)) eraseBoneIndexes.push(index);\n        });\n\n        if (!eraseBoneIndexes.length) {\n          mesh.layers.enable(this._thirdPersonOnlyLayer);\n          mesh.layers.enable(this._firstPersonOnlyLayer);\n          return;\n        }\n\n        mesh.layers.set(this._thirdPersonOnlyLayer);\n\n        var newMesh = this._createErasedMesh(mesh, eraseBoneIndexes);\n\n        parent.add(newMesh);\n      };\n\n      VRMFirstPerson.prototype._createHeadlessModel = function (node) {\n        var _this = this;\n\n        if (node.type === 'Group') {\n          node.layers.set(this._thirdPersonOnlyLayer);\n\n          if (this._isEraseTarget(node)) {\n            node.traverse(function (child) {\n              return child.layers.set(_this._thirdPersonOnlyLayer);\n            });\n          } else {\n            var parent_1 = new THREE.Group();\n            parent_1.name = \"_headless_\" + node.name;\n            parent_1.layers.set(this._firstPersonOnlyLayer);\n            node.parent.add(parent_1);\n            node.children.filter(function (child) {\n              return child.type === 'SkinnedMesh';\n            }).forEach(function (child) {\n              _this._createHeadlessModelForSkinnedMesh(parent_1, child);\n            });\n          }\n        } else if (node.type === 'SkinnedMesh') {\n          this._createHeadlessModelForSkinnedMesh(node.parent, node);\n        } else {\n          if (this._isEraseTarget(node)) {\n            node.layers.set(this._thirdPersonOnlyLayer);\n            node.traverse(function (child) {\n              return child.layers.set(_this._thirdPersonOnlyLayer);\n            });\n          }\n        }\n      };\n\n      VRMFirstPerson.prototype._isEraseTarget = function (bone) {\n        if (bone.name === this._firstPersonBone.name) {\n          return true;\n        } else if (!bone.parent) {\n          return false;\n        } else {\n          return this._isEraseTarget(bone.parent);\n        }\n      };\n\n      VRMFirstPerson._DEFAULT_FIRSTPERSON_ONLY_LAYER = 9;\n      VRMFirstPerson._DEFAULT_THIRDPERSON_ONLY_LAYER = 10;\n      return VRMFirstPerson;\n    }();\n\n    exports.VRMFirstPerson = VRMFirstPerson;\n    /***/\n  },\n\n  /***/\n  \"./src/vrm/firstperson/VRMFirstPersonImporter.ts\":\n  /*!*******************************************************!*\\\r\n    !*** ./src/vrm/firstperson/VRMFirstPersonImporter.ts ***!\r\n    \\*******************************************************/\n\n  /*! no static exports found */\n\n  /***/\n  function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n      return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) {\n          try {\n            step(generator.next(value));\n          } catch (e) {\n            reject(e);\n          }\n        }\n\n        function rejected(value) {\n          try {\n            step(generator[\"throw\"](value));\n          } catch (e) {\n            reject(e);\n          }\n        }\n\n        function step(result) {\n          result.done ? resolve(result.value) : new P(function (resolve) {\n            resolve(result.value);\n          }).then(fulfilled, rejected);\n        }\n\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n      });\n    };\n\n    var __generator = this && this.__generator || function (thisArg, body) {\n      var _ = {\n        label: 0,\n        sent: function () {\n          if (t[0] & 1) throw t[1];\n          return t[1];\n        },\n        trys: [],\n        ops: []\n      },\n          f,\n          y,\n          t,\n          g;\n      return g = {\n        next: verb(0),\n        \"throw\": verb(1),\n        \"return\": verb(2)\n      }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n        return this;\n      }), g;\n\n      function verb(n) {\n        return function (v) {\n          return step([n, v]);\n        };\n      }\n\n      function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n\n        while (_) try {\n          if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n          if (y = 0, t) op = [op[0] & 2, t.value];\n\n          switch (op[0]) {\n            case 0:\n            case 1:\n              t = op;\n              break;\n\n            case 4:\n              _.label++;\n              return {\n                value: op[1],\n                done: false\n              };\n\n            case 5:\n              _.label++;\n              y = op[1];\n              op = [0];\n              continue;\n\n            case 7:\n              op = _.ops.pop();\n\n              _.trys.pop();\n\n              continue;\n\n            default:\n              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n                _ = 0;\n                continue;\n              }\n\n              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n                _.label = op[1];\n                break;\n              }\n\n              if (op[0] === 6 && _.label < t[1]) {\n                _.label = t[1];\n                t = op;\n                break;\n              }\n\n              if (t && _.label < t[2]) {\n                _.label = t[2];\n\n                _.ops.push(op);\n\n                break;\n              }\n\n              if (t[2]) _.ops.pop();\n\n              _.trys.pop();\n\n              continue;\n          }\n\n          op = body.call(thisArg, _);\n        } catch (e) {\n          op = [6, e];\n          y = 0;\n        } finally {\n          f = t = 0;\n        }\n\n        if (op[0] & 5) throw op[1];\n        return {\n          value: op[0] ? op[1] : void 0,\n          done: true\n        };\n      }\n    };\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n\n    var THREE = __webpack_require__(\n    /*! three */\n    \"three\");\n\n    var types_1 = __webpack_require__(\n    /*! ../types */\n    \"./src/vrm/types/index.ts\");\n\n    var VRMFirstPerson_1 = __webpack_require__(\n    /*! ./VRMFirstPerson */\n    \"./src/vrm/firstperson/VRMFirstPerson.ts\");\n\n    var VRMFirstPersonImporter = function () {\n      function VRMFirstPersonImporter() {}\n\n      VRMFirstPersonImporter.prototype.import = function (gltf, humanoid) {\n        return __awaiter(this, void 0, Promise, function () {\n          var vrmExt, schemaFirstPerson, firstPersonBoneIndex, firstPersonBone, firstPersonBoneOffset, meshAnnotations, meshes;\n          return __generator(this, function (_a) {\n            switch (_a.label) {\n              case 0:\n                vrmExt = gltf.parser.json.extensions && gltf.parser.json.extensions.VRM;\n\n                if (!vrmExt) {\n                  return [2, null];\n                }\n\n                schemaFirstPerson = vrmExt.firstPerson;\n\n                if (!schemaFirstPerson) {\n                  return [2, null];\n                }\n\n                firstPersonBoneIndex = schemaFirstPerson.firstPersonBone;\n                if (!(firstPersonBoneIndex === undefined || firstPersonBoneIndex === -1)) return [3, 1];\n                firstPersonBone = humanoid.getBoneNode(types_1.VRMSchema.HumanoidBoneName.Head);\n                return [3, 3];\n\n              case 1:\n                return [4, gltf.parser.getDependency('node', firstPersonBoneIndex)];\n\n              case 2:\n                firstPersonBone = _a.sent();\n                _a.label = 3;\n\n              case 3:\n                if (!firstPersonBone) {\n                  console.warn('VRMFirstPersonImporter: Could not find firstPersonBone of the VRM');\n                  return [2, null];\n                }\n\n                firstPersonBoneOffset = schemaFirstPerson.firstPersonBoneOffset ? new THREE.Vector3(schemaFirstPerson.firstPersonBoneOffset.x, schemaFirstPerson.firstPersonBoneOffset.y, schemaFirstPerson.firstPersonBoneOffset.z) : new THREE.Vector3(0.0, 0.06, 0.0);\n                meshAnnotations = [];\n                return [4, gltf.parser.getDependencies('mesh')];\n\n              case 4:\n                meshes = _a.sent();\n                meshes.forEach(function (mesh, meshIndex) {\n                  var flag = schemaFirstPerson.meshAnnotations ? schemaFirstPerson.meshAnnotations.find(function (a) {\n                    return a.mesh === meshIndex;\n                  }) : undefined;\n                  meshAnnotations.push(new VRMFirstPerson_1.VRMRendererFirstPersonFlags(flag && flag.firstPersonFlag, mesh));\n                });\n                return [2, new VRMFirstPerson_1.VRMFirstPerson(firstPersonBone, firstPersonBoneOffset, meshAnnotations)];\n            }\n          });\n        });\n      };\n\n      return VRMFirstPersonImporter;\n    }();\n\n    exports.VRMFirstPersonImporter = VRMFirstPersonImporter;\n    /***/\n  },\n\n  /***/\n  \"./src/vrm/firstperson/index.ts\":\n  /*!**************************************!*\\\r\n    !*** ./src/vrm/firstperson/index.ts ***!\r\n    \\**************************************/\n\n  /*! no static exports found */\n\n  /***/\n  function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    function __export(m) {\n      for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n    }\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n\n    __export(__webpack_require__(\n    /*! ./VRMFirstPerson */\n    \"./src/vrm/firstperson/VRMFirstPerson.ts\"));\n\n    __export(__webpack_require__(\n    /*! ./VRMFirstPersonImporter */\n    \"./src/vrm/firstperson/VRMFirstPersonImporter.ts\"));\n    /***/\n\n  },\n\n  /***/\n  \"./src/vrm/humanoid/VRMHumanBone.ts\":\n  /*!******************************************!*\\\r\n    !*** ./src/vrm/humanoid/VRMHumanBone.ts ***!\r\n    \\******************************************/\n\n  /*! no static exports found */\n\n  /***/\n  function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n\n    var VRMHumanBone = function () {\n      function VRMHumanBone(node, humanLimit) {\n        this.node = node;\n        this.humanLimit = humanLimit;\n      }\n\n      return VRMHumanBone;\n    }();\n\n    exports.VRMHumanBone = VRMHumanBone;\n    /***/\n  },\n\n  /***/\n  \"./src/vrm/humanoid/VRMHumanBones.ts\":\n  /*!*******************************************!*\\\r\n    !*** ./src/vrm/humanoid/VRMHumanBones.ts ***!\r\n    \\*******************************************/\n\n  /*! no static exports found */\n\n  /***/\n  function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n    /***/\n  },\n\n  /***/\n  \"./src/vrm/humanoid/VRMHumanDescription.ts\":\n  /*!*************************************************!*\\\r\n    !*** ./src/vrm/humanoid/VRMHumanDescription.ts ***!\r\n    \\*************************************************/\n\n  /*! no static exports found */\n\n  /***/\n  function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n    /***/\n  },\n\n  /***/\n  \"./src/vrm/humanoid/VRMHumanLimit.ts\":\n  /*!*******************************************!*\\\r\n    !*** ./src/vrm/humanoid/VRMHumanLimit.ts ***!\r\n    \\*******************************************/\n\n  /*! no static exports found */\n\n  /***/\n  function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n    /***/\n  },\n\n  /***/\n  \"./src/vrm/humanoid/VRMHumanoid.ts\":\n  /*!*****************************************!*\\\r\n    !*** ./src/vrm/humanoid/VRMHumanoid.ts ***!\r\n    \\*****************************************/\n\n  /*! no static exports found */\n\n  /***/\n  function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n\n    var types_1 = __webpack_require__(\n    /*! ../types */\n    \"./src/vrm/types/index.ts\");\n\n    var VRMHumanoid = function () {\n      function VRMHumanoid(boneArray, humanDescription) {\n        this.humanBones = this._createHumanBones(boneArray);\n        this.humanDescription = humanDescription;\n        this.restPose = this.getPose();\n      }\n\n      VRMHumanoid.prototype.getPose = function () {\n        var _this = this;\n\n        var pose = {};\n        Object.keys(this.humanBones).forEach(function (vrmBoneName) {\n          var node = _this.getBoneNode(vrmBoneName);\n\n          if (!node) {\n            return;\n          }\n\n          if (pose[vrmBoneName]) {\n            return;\n          }\n\n          pose[vrmBoneName] = {\n            position: node.position.toArray(),\n            rotation: node.quaternion.toArray()\n          };\n        }, {});\n        return pose;\n      };\n\n      VRMHumanoid.prototype.setPose = function (poseObject) {\n        var _this = this;\n\n        Object.keys(poseObject).forEach(function (boneName) {\n          var state = poseObject[boneName];\n\n          var node = _this.getBoneNode(boneName);\n\n          if (!node) {\n            return;\n          }\n\n          var restState = _this.restPose[boneName];\n\n          if (!restState) {\n            return;\n          }\n\n          if (state.position) {\n            node.position.set(restState.position[0] + state.position[0], restState.position[1] + state.position[1], restState.position[2] + state.position[2]);\n          }\n\n          if (state.rotation) {\n            node.quaternion.fromArray(state.rotation);\n          }\n        });\n      };\n\n      VRMHumanoid.prototype.getBone = function (name) {\n        return this.humanBones[name][0] || undefined;\n      };\n\n      VRMHumanoid.prototype.getBones = function (name) {\n        return this.humanBones[name];\n      };\n\n      VRMHumanoid.prototype.getBoneNode = function (name) {\n        return this.humanBones[name][0] && this.humanBones[name][0].node || null;\n      };\n\n      VRMHumanoid.prototype.getBoneNodes = function (name) {\n        return this.humanBones[name].map(function (bone) {\n          return bone.node;\n        });\n      };\n\n      VRMHumanoid.prototype._createHumanBones = function (boneArray) {\n        var bones = Object.values(types_1.VRMSchema.HumanoidBoneName).reduce(function (accum, name) {\n          accum[name] = [];\n          return accum;\n        }, {});\n        boneArray.forEach(function (bone) {\n          bones[bone.name].push(bone.bone);\n        });\n        return bones;\n      };\n\n      return VRMHumanoid;\n    }();\n\n    exports.VRMHumanoid = VRMHumanoid;\n    /***/\n  },\n\n  /***/\n  \"./src/vrm/humanoid/VRMHumanoidImporter.ts\":\n  /*!*************************************************!*\\\r\n    !*** ./src/vrm/humanoid/VRMHumanoidImporter.ts ***!\r\n    \\*************************************************/\n\n  /*! no static exports found */\n\n  /***/\n  function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n      return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) {\n          try {\n            step(generator.next(value));\n          } catch (e) {\n            reject(e);\n          }\n        }\n\n        function rejected(value) {\n          try {\n            step(generator[\"throw\"](value));\n          } catch (e) {\n            reject(e);\n          }\n        }\n\n        function step(result) {\n          result.done ? resolve(result.value) : new P(function (resolve) {\n            resolve(result.value);\n          }).then(fulfilled, rejected);\n        }\n\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n      });\n    };\n\n    var __generator = this && this.__generator || function (thisArg, body) {\n      var _ = {\n        label: 0,\n        sent: function () {\n          if (t[0] & 1) throw t[1];\n          return t[1];\n        },\n        trys: [],\n        ops: []\n      },\n          f,\n          y,\n          t,\n          g;\n      return g = {\n        next: verb(0),\n        \"throw\": verb(1),\n        \"return\": verb(2)\n      }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n        return this;\n      }), g;\n\n      function verb(n) {\n        return function (v) {\n          return step([n, v]);\n        };\n      }\n\n      function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n\n        while (_) try {\n          if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n          if (y = 0, t) op = [op[0] & 2, t.value];\n\n          switch (op[0]) {\n            case 0:\n            case 1:\n              t = op;\n              break;\n\n            case 4:\n              _.label++;\n              return {\n                value: op[1],\n                done: false\n              };\n\n            case 5:\n              _.label++;\n              y = op[1];\n              op = [0];\n              continue;\n\n            case 7:\n              op = _.ops.pop();\n\n              _.trys.pop();\n\n              continue;\n\n            default:\n              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n                _ = 0;\n                continue;\n              }\n\n              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n                _.label = op[1];\n                break;\n              }\n\n              if (op[0] === 6 && _.label < t[1]) {\n                _.label = t[1];\n                t = op;\n                break;\n              }\n\n              if (t && _.label < t[2]) {\n                _.label = t[2];\n\n                _.ops.push(op);\n\n                break;\n              }\n\n              if (t[2]) _.ops.pop();\n\n              _.trys.pop();\n\n              continue;\n          }\n\n          op = body.call(thisArg, _);\n        } catch (e) {\n          op = [6, e];\n          y = 0;\n        } finally {\n          f = t = 0;\n        }\n\n        if (op[0] & 5) throw op[1];\n        return {\n          value: op[0] ? op[1] : void 0,\n          done: true\n        };\n      }\n    };\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n\n    var THREE = __webpack_require__(\n    /*! three */\n    \"three\");\n\n    var VRMHumanBone_1 = __webpack_require__(\n    /*! ./VRMHumanBone */\n    \"./src/vrm/humanoid/VRMHumanBone.ts\");\n\n    var VRMHumanoid_1 = __webpack_require__(\n    /*! ./VRMHumanoid */\n    \"./src/vrm/humanoid/VRMHumanoid.ts\");\n\n    var VRMHumanoidImporter = function () {\n      function VRMHumanoidImporter() {}\n\n      VRMHumanoidImporter.prototype.import = function (gltf) {\n        return __awaiter(this, void 0, Promise, function () {\n          var vrmExt, schemaHumanoid, humanBoneArray, humanDescription;\n\n          var _this = this;\n\n          return __generator(this, function (_a) {\n            switch (_a.label) {\n              case 0:\n                vrmExt = gltf.parser.json.extensions && gltf.parser.json.extensions.VRM;\n\n                if (!vrmExt) {\n                  return [2, null];\n                }\n\n                schemaHumanoid = vrmExt.humanoid;\n\n                if (!schemaHumanoid) {\n                  return [2, null];\n                }\n\n                humanBoneArray = [];\n                if (!schemaHumanoid.humanBones) return [3, 2];\n                return [4, Promise.all(schemaHumanoid.humanBones.map(function (bone) {\n                  return __awaiter(_this, void 0, void 0, function () {\n                    var node;\n                    return __generator(this, function (_a) {\n                      switch (_a.label) {\n                        case 0:\n                          if (!bone.bone || !bone.node) {\n                            return [2];\n                          }\n\n                          return [4, gltf.parser.getDependency('node', bone.node)];\n\n                        case 1:\n                          node = _a.sent();\n                          humanBoneArray.push({\n                            name: bone.bone,\n                            bone: new VRMHumanBone_1.VRMHumanBone(node, {\n                              axisLength: bone.axisLength,\n                              center: bone.center && new THREE.Vector3(bone.center.x, bone.center.y, bone.center.z),\n                              max: bone.max && new THREE.Vector3(bone.max.x, bone.max.y, bone.max.z),\n                              min: bone.min && new THREE.Vector3(bone.min.x, bone.min.y, bone.min.z),\n                              useDefaultValues: bone.useDefaultValues\n                            })\n                          });\n                          return [2];\n                      }\n                    });\n                  });\n                }))];\n\n              case 1:\n                _a.sent();\n\n                _a.label = 2;\n\n              case 2:\n                humanDescription = {\n                  armStretch: schemaHumanoid.armStretch,\n                  legStretch: schemaHumanoid.legStretch,\n                  upperArmTwist: schemaHumanoid.upperArmTwist,\n                  lowerArmTwist: schemaHumanoid.lowerArmTwist,\n                  upperLegTwist: schemaHumanoid.upperLegTwist,\n                  lowerLegTwist: schemaHumanoid.lowerLegTwist,\n                  feetSpacing: schemaHumanoid.feetSpacing,\n                  hasTranslationDoF: schemaHumanoid.hasTranslationDoF\n                };\n                return [2, new VRMHumanoid_1.VRMHumanoid(humanBoneArray, humanDescription)];\n            }\n          });\n        });\n      };\n\n      return VRMHumanoidImporter;\n    }();\n\n    exports.VRMHumanoidImporter = VRMHumanoidImporter;\n    /***/\n  },\n\n  /***/\n  \"./src/vrm/humanoid/index.ts\":\n  /*!***********************************!*\\\r\n    !*** ./src/vrm/humanoid/index.ts ***!\r\n    \\***********************************/\n\n  /*! no static exports found */\n\n  /***/\n  function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    function __export(m) {\n      for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n    }\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n\n    __export(__webpack_require__(\n    /*! ./VRMHumanBone */\n    \"./src/vrm/humanoid/VRMHumanBone.ts\"));\n\n    __export(__webpack_require__(\n    /*! ./VRMHumanBones */\n    \"./src/vrm/humanoid/VRMHumanBones.ts\"));\n\n    __export(__webpack_require__(\n    /*! ./VRMHumanDescription */\n    \"./src/vrm/humanoid/VRMHumanDescription.ts\"));\n\n    __export(__webpack_require__(\n    /*! ./VRMHumanLimit */\n    \"./src/vrm/humanoid/VRMHumanLimit.ts\"));\n\n    __export(__webpack_require__(\n    /*! ./VRMHumanoid */\n    \"./src/vrm/humanoid/VRMHumanoid.ts\"));\n\n    __export(__webpack_require__(\n    /*! ./VRMHumanoidImporter */\n    \"./src/vrm/humanoid/VRMHumanoidImporter.ts\"));\n    /***/\n\n  },\n\n  /***/\n  \"./src/vrm/index.ts\":\n  /*!**************************!*\\\r\n    !*** ./src/vrm/index.ts ***!\r\n    \\**************************/\n\n  /*! no static exports found */\n\n  /***/\n  function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    function __export(m) {\n      for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n    }\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n\n    __export(__webpack_require__(\n    /*! ./VRM */\n    \"./src/vrm/VRM.ts\"));\n\n    __export(__webpack_require__(\n    /*! ./VRMImporter */\n    \"./src/vrm/VRMImporter.ts\"));\n\n    __export(__webpack_require__(\n    /*! ./reduceBones */\n    \"./src/vrm/reduceBones.ts\"));\n\n    __export(__webpack_require__(\n    /*! ./blendshape */\n    \"./src/vrm/blendshape/index.ts\"));\n\n    __export(__webpack_require__(\n    /*! ./debug */\n    \"./src/vrm/debug/index.ts\"));\n\n    __export(__webpack_require__(\n    /*! ./firstperson */\n    \"./src/vrm/firstperson/index.ts\"));\n\n    __export(__webpack_require__(\n    /*! ./humanoid */\n    \"./src/vrm/humanoid/index.ts\"));\n\n    __export(__webpack_require__(\n    /*! ./lookat */\n    \"./src/vrm/lookat/index.ts\"));\n\n    __export(__webpack_require__(\n    /*! ./springbone */\n    \"./src/vrm/springbone/index.ts\"));\n\n    __export(__webpack_require__(\n    /*! ./types */\n    \"./src/vrm/types/index.ts\"));\n\n    __export(__webpack_require__(\n    /*! ./material */\n    \"./src/vrm/material/index.ts\"));\n    /***/\n\n  },\n\n  /***/\n  \"./src/vrm/lookat/CurveMapper.ts\":\n  /*!***************************************!*\\\r\n    !*** ./src/vrm/lookat/CurveMapper.ts ***!\r\n    \\***************************************/\n\n  /*! no static exports found */\n\n  /***/\n  function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n\n    var hermiteSpline = function (y0, y1, t0, t1, x) {\n      var xc = x * x * x;\n      var xs = x * x;\n      var dy = y1 - y0;\n      var h01 = -2.0 * xc + 3.0 * xs;\n      var h10 = xc - 2.0 * xs + x;\n      var h11 = xc - xs;\n      return y0 + dy * h01 + t0 * h10 + t1 * h11;\n    };\n\n    var evaluateCurve = function (arr, x) {\n      if (arr.length < 8) {\n        throw new Error('evaluateCurve: Invalid curve detected! (Array length must be 8 at least)');\n      }\n\n      if (arr.length % 4 !== 0) {\n        throw new Error('evaluateCurve: Invalid curve detected! (Array length must be multiples of 4');\n      }\n\n      var outNode;\n\n      for (outNode = 0;; outNode++) {\n        if (arr.length <= 4 * outNode) {\n          return arr[4 * outNode - 3];\n        } else if (x <= arr[4 * outNode]) {\n          break;\n        }\n      }\n\n      var inNode = outNode - 1;\n\n      if (inNode < 0) {\n        return arr[4 * inNode + 5];\n      }\n\n      var x0 = arr[4 * inNode];\n      var x1 = arr[4 * outNode];\n      var xHermite = (x - x0) / (x1 - x0);\n      var y0 = arr[4 * inNode + 1];\n      var y1 = arr[4 * outNode + 1];\n      var t0 = arr[4 * inNode + 3];\n      var t1 = arr[4 * outNode + 2];\n      return hermiteSpline(y0, y1, t0, t1, xHermite);\n    };\n\n    var CurveMapper = function () {\n      function CurveMapper(xRange, yRange, curve) {\n        this.curve = [0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 1.0, 0.0];\n        this.curveXRangeDegree = 90.0;\n        this.curveYRangeDegree = 10.0;\n\n        if (xRange !== undefined) {\n          this.curveXRangeDegree = xRange;\n        }\n\n        if (yRange !== undefined) {\n          this.curveYRangeDegree = yRange;\n        }\n\n        if (curve !== undefined) {\n          this.curve = curve;\n        }\n      }\n\n      CurveMapper.prototype.map = function (src) {\n        var clampedSrc = Math.min(Math.max(src, 0.0), this.curveXRangeDegree);\n        var x = clampedSrc / this.curveXRangeDegree;\n        return this.curveYRangeDegree * evaluateCurve(this.curve, x);\n      };\n\n      return CurveMapper;\n    }();\n\n    exports.CurveMapper = CurveMapper;\n    /***/\n  },\n\n  /***/\n  \"./src/vrm/lookat/VRMLookAtApplyer.ts\":\n  /*!********************************************!*\\\r\n    !*** ./src/vrm/lookat/VRMLookAtApplyer.ts ***!\r\n    \\********************************************/\n\n  /*! no static exports found */\n\n  /***/\n  function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n\n    var VRMLookAtApplyer = function () {\n      function VRMLookAtApplyer() {}\n\n      return VRMLookAtApplyer;\n    }();\n\n    exports.VRMLookAtApplyer = VRMLookAtApplyer;\n    /***/\n  },\n\n  /***/\n  \"./src/vrm/lookat/VRMLookAtBlendShapeApplyer.ts\":\n  /*!******************************************************!*\\\r\n    !*** ./src/vrm/lookat/VRMLookAtBlendShapeApplyer.ts ***!\r\n    \\******************************************************/\n\n  /*! no static exports found */\n\n  /***/\n  function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    var __extends = this && this.__extends || function () {\n      var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (d, b) {\n          d.__proto__ = b;\n        } || function (d, b) {\n          for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n        };\n\n        return extendStatics(d, b);\n      };\n\n      return function (d, b) {\n        extendStatics(d, b);\n\n        function __() {\n          this.constructor = d;\n        }\n\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n      };\n    }();\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n\n    var types_1 = __webpack_require__(\n    /*! ../types */\n    \"./src/vrm/types/index.ts\");\n\n    var VRMLookAtApplyer_1 = __webpack_require__(\n    /*! ./VRMLookAtApplyer */\n    \"./src/vrm/lookat/VRMLookAtApplyer.ts\");\n\n    var VRMLookAtBlendShapeApplyer = function (_super) {\n      __extends(VRMLookAtBlendShapeApplyer, _super);\n\n      function VRMLookAtBlendShapeApplyer(blendShapeProxy, curveHorizontal, curveVerticalDown, curveVerticalUp) {\n        var _this = _super.call(this) || this;\n\n        _this.type = types_1.VRMSchema.FirstPersonLookAtTypeName.BlendShape;\n        _this._curveHorizontal = curveHorizontal;\n        _this._curveVerticalDown = curveVerticalDown;\n        _this._curveVerticalUp = curveVerticalUp;\n        _this._blendShapeProxy = blendShapeProxy;\n        return _this;\n      }\n\n      VRMLookAtBlendShapeApplyer.prototype.name = function () {\n        return types_1.VRMSchema.FirstPersonLookAtTypeName.BlendShape;\n      };\n\n      VRMLookAtBlendShapeApplyer.prototype.lookAt = function (euler) {\n        var srcX = euler.x;\n        var srcY = euler.y;\n\n        if (srcX < 0.0) {\n          this._blendShapeProxy.setValue(types_1.VRMSchema.BlendShapePresetName.Lookup, 0.0);\n\n          this._blendShapeProxy.setValue(types_1.VRMSchema.BlendShapePresetName.Lookdown, this._curveVerticalDown.map(-srcX));\n        } else {\n          this._blendShapeProxy.setValue(types_1.VRMSchema.BlendShapePresetName.Lookdown, 0.0);\n\n          this._blendShapeProxy.setValue(types_1.VRMSchema.BlendShapePresetName.Lookup, this._curveVerticalUp.map(srcX));\n        }\n\n        if (srcY < 0.0) {\n          this._blendShapeProxy.setValue(types_1.VRMSchema.BlendShapePresetName.Lookleft, 0.0);\n\n          this._blendShapeProxy.setValue(types_1.VRMSchema.BlendShapePresetName.Lookright, this._curveHorizontal.map(-srcY));\n        } else {\n          this._blendShapeProxy.setValue(types_1.VRMSchema.BlendShapePresetName.Lookright, 0.0);\n\n          this._blendShapeProxy.setValue(types_1.VRMSchema.BlendShapePresetName.Lookleft, this._curveHorizontal.map(srcY));\n        }\n      };\n\n      return VRMLookAtBlendShapeApplyer;\n    }(VRMLookAtApplyer_1.VRMLookAtApplyer);\n\n    exports.VRMLookAtBlendShapeApplyer = VRMLookAtBlendShapeApplyer;\n    /***/\n  },\n\n  /***/\n  \"./src/vrm/lookat/VRMLookAtBoneApplyer.ts\":\n  /*!************************************************!*\\\r\n    !*** ./src/vrm/lookat/VRMLookAtBoneApplyer.ts ***!\r\n    \\************************************************/\n\n  /*! no static exports found */\n\n  /***/\n  function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    var __extends = this && this.__extends || function () {\n      var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (d, b) {\n          d.__proto__ = b;\n        } || function (d, b) {\n          for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n        };\n\n        return extendStatics(d, b);\n      };\n\n      return function (d, b) {\n        extendStatics(d, b);\n\n        function __() {\n          this.constructor = d;\n        }\n\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n      };\n    }();\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n\n    var THREE = __webpack_require__(\n    /*! three */\n    \"three\");\n\n    var types_1 = __webpack_require__(\n    /*! ../types */\n    \"./src/vrm/types/index.ts\");\n\n    var VRMLookAtApplyer_1 = __webpack_require__(\n    /*! ./VRMLookAtApplyer */\n    \"./src/vrm/lookat/VRMLookAtApplyer.ts\");\n\n    var VRMLookAtHead_1 = __webpack_require__(\n    /*! ./VRMLookAtHead */\n    \"./src/vrm/lookat/VRMLookAtHead.ts\");\n\n    var _euler = new THREE.Euler(0.0, 0.0, 0.0, VRMLookAtHead_1.VRMLookAtHead.EULER_ORDER);\n\n    var VRMLookAtBoneApplyer = function (_super) {\n      __extends(VRMLookAtBoneApplyer, _super);\n\n      function VRMLookAtBoneApplyer(humanoid, curveHorizontalInner, curveHorizontalOuter, curveVerticalDown, curveVerticalUp) {\n        var _this = _super.call(this) || this;\n\n        _this.type = types_1.VRMSchema.FirstPersonLookAtTypeName.Bone;\n        _this._curveHorizontalInner = curveHorizontalInner;\n        _this._curveHorizontalOuter = curveHorizontalOuter;\n        _this._curveVerticalDown = curveVerticalDown;\n        _this._curveVerticalUp = curveVerticalUp;\n        _this._leftEye = humanoid.getBoneNode(types_1.VRMSchema.HumanoidBoneName.LeftEye);\n        _this._rightEye = humanoid.getBoneNode(types_1.VRMSchema.HumanoidBoneName.RightEye);\n        return _this;\n      }\n\n      VRMLookAtBoneApplyer.prototype.lookAt = function (euler) {\n        var srcX = euler.x;\n        var srcY = euler.y;\n\n        if (this._leftEye) {\n          if (srcX < 0.0) {\n            _euler.x = -this._curveVerticalDown.map(-srcX);\n          } else {\n            _euler.x = this._curveVerticalUp.map(srcX);\n          }\n\n          if (srcY < 0.0) {\n            _euler.y = -this._curveHorizontalInner.map(-srcY);\n          } else {\n            _euler.y = this._curveHorizontalOuter.map(srcY);\n          }\n\n          this._leftEye.quaternion.setFromEuler(_euler);\n        }\n\n        if (this._rightEye) {\n          if (srcX < 0.0) {\n            _euler.x = -this._curveVerticalDown.map(-srcX);\n          } else {\n            _euler.x = this._curveVerticalUp.map(srcX);\n          }\n\n          if (srcY < 0.0) {\n            _euler.y = -this._curveHorizontalOuter.map(-srcY);\n          } else {\n            _euler.y = this._curveHorizontalInner.map(srcY);\n          }\n\n          this._rightEye.quaternion.setFromEuler(_euler);\n        }\n      };\n\n      return VRMLookAtBoneApplyer;\n    }(VRMLookAtApplyer_1.VRMLookAtApplyer);\n\n    exports.VRMLookAtBoneApplyer = VRMLookAtBoneApplyer;\n    /***/\n  },\n\n  /***/\n  \"./src/vrm/lookat/VRMLookAtHead.ts\":\n  /*!*****************************************!*\\\r\n    !*** ./src/vrm/lookat/VRMLookAtHead.ts ***!\r\n    \\*****************************************/\n\n  /*! no static exports found */\n\n  /***/\n  function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n\n    var THREE = __webpack_require__(\n    /*! three */\n    \"three\");\n\n    var math_1 = __webpack_require__(\n    /*! ../utils/math */\n    \"./src/vrm/utils/math.ts\");\n\n    var VECTOR3_FRONT = Object.freeze(new THREE.Vector3(0.0, 0.0, -1.0));\n\n    var _v3A = new THREE.Vector3();\n\n    var _v3B = new THREE.Vector3();\n\n    var _v3C = new THREE.Vector3();\n\n    var _quat = new THREE.Quaternion();\n\n    var VRMLookAtHead = function () {\n      function VRMLookAtHead(firstPerson, applyer) {\n        this.autoUpdate = true;\n        this._euler = new THREE.Euler(0.0, 0.0, 0.0, VRMLookAtHead.EULER_ORDER);\n        this.firstPerson = firstPerson;\n        this.applyer = applyer;\n      }\n\n      VRMLookAtHead.prototype.getLookAtWorldDirection = function (target) {\n        var rot = math_1.getWorldQuaternionLite(this.firstPerson.firstPersonBone, _quat);\n        return target.copy(VECTOR3_FRONT).applyEuler(this._euler).applyQuaternion(rot);\n      };\n\n      VRMLookAtHead.prototype.lookAt = function (position) {\n        this._calcEuler(this._euler, position);\n\n        if (this.applyer) {\n          this.applyer.lookAt(this._euler);\n        }\n      };\n\n      VRMLookAtHead.prototype.update = function (delta) {\n        if (this.target && this.autoUpdate) {\n          this.lookAt(this.target.getWorldPosition(_v3A));\n\n          if (this.applyer) {\n            this.applyer.lookAt(this._euler);\n          }\n        }\n      };\n\n      VRMLookAtHead.prototype._calcEuler = function (target, position) {\n        var headPosition = this.firstPerson.getFirstPersonWorldPosition(_v3B);\n\n        var lookAtDir = _v3C.copy(position).sub(headPosition).normalize();\n\n        lookAtDir.applyQuaternion(math_1.getWorldQuaternionLite(this.firstPerson.firstPersonBone, _quat).inverse());\n        target.x = Math.atan2(lookAtDir.y, Math.sqrt(lookAtDir.x * lookAtDir.x + lookAtDir.z * lookAtDir.z));\n        target.y = Math.atan2(-lookAtDir.x, -lookAtDir.z);\n        return target;\n      };\n\n      VRMLookAtHead.EULER_ORDER = 'YXZ';\n      return VRMLookAtHead;\n    }();\n\n    exports.VRMLookAtHead = VRMLookAtHead;\n    /***/\n  },\n\n  /***/\n  \"./src/vrm/lookat/VRMLookAtImporter.ts\":\n  /*!*********************************************!*\\\r\n    !*** ./src/vrm/lookat/VRMLookAtImporter.ts ***!\r\n    \\*********************************************/\n\n  /*! no static exports found */\n\n  /***/\n  function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n\n    var THREE = __webpack_require__(\n    /*! three */\n    \"three\");\n\n    var types_1 = __webpack_require__(\n    /*! ../types */\n    \"./src/vrm/types/index.ts\");\n\n    var CurveMapper_1 = __webpack_require__(\n    /*! ./CurveMapper */\n    \"./src/vrm/lookat/CurveMapper.ts\");\n\n    var VRMLookAtBlendShapeApplyer_1 = __webpack_require__(\n    /*! ./VRMLookAtBlendShapeApplyer */\n    \"./src/vrm/lookat/VRMLookAtBlendShapeApplyer.ts\");\n\n    var VRMLookAtBoneApplyer_1 = __webpack_require__(\n    /*! ./VRMLookAtBoneApplyer */\n    \"./src/vrm/lookat/VRMLookAtBoneApplyer.ts\");\n\n    var VRMLookAtHead_1 = __webpack_require__(\n    /*! ./VRMLookAtHead */\n    \"./src/vrm/lookat/VRMLookAtHead.ts\");\n\n    var VRMLookAtImporter = function () {\n      function VRMLookAtImporter() {}\n\n      VRMLookAtImporter.prototype.import = function (gltf, firstPerson, blendShapeProxy, humanoid) {\n        var vrmExt = gltf.parser.json.extensions && gltf.parser.json.extensions.VRM;\n\n        if (!vrmExt) {\n          return null;\n        }\n\n        var schemaFirstPerson = vrmExt.firstPerson;\n\n        if (!schemaFirstPerson) {\n          return null;\n        }\n\n        var applyer = this._importApplyer(schemaFirstPerson, blendShapeProxy, humanoid);\n\n        return new VRMLookAtHead_1.VRMLookAtHead(firstPerson, applyer || undefined);\n      };\n\n      VRMLookAtImporter.prototype._importApplyer = function (schemaFirstPerson, blendShapeProxy, humanoid) {\n        var lookAtHorizontalInner = schemaFirstPerson.lookAtHorizontalInner;\n        var lookAtHorizontalOuter = schemaFirstPerson.lookAtHorizontalOuter;\n        var lookAtVerticalDown = schemaFirstPerson.lookAtVerticalDown;\n        var lookAtVerticalUp = schemaFirstPerson.lookAtVerticalUp;\n\n        switch (schemaFirstPerson.lookAtTypeName) {\n          case types_1.VRMSchema.FirstPersonLookAtTypeName.Bone:\n            {\n              if (lookAtHorizontalInner === undefined || lookAtHorizontalOuter === undefined || lookAtVerticalDown === undefined || lookAtVerticalUp === undefined) {\n                return null;\n              } else {\n                return new VRMLookAtBoneApplyer_1.VRMLookAtBoneApplyer(humanoid, this._importCurveMapperBone(lookAtHorizontalInner), this._importCurveMapperBone(lookAtHorizontalOuter), this._importCurveMapperBone(lookAtVerticalDown), this._importCurveMapperBone(lookAtVerticalUp));\n              }\n            }\n\n          case types_1.VRMSchema.FirstPersonLookAtTypeName.BlendShape:\n            {\n              if (lookAtHorizontalOuter === undefined || lookAtVerticalDown === undefined || lookAtVerticalUp === undefined) {\n                return null;\n              } else {\n                return new VRMLookAtBlendShapeApplyer_1.VRMLookAtBlendShapeApplyer(blendShapeProxy, this._importCurveMapperBlendShape(lookAtHorizontalOuter), this._importCurveMapperBlendShape(lookAtVerticalDown), this._importCurveMapperBlendShape(lookAtVerticalUp));\n              }\n            }\n\n          default:\n            {\n              return null;\n            }\n        }\n      };\n\n      VRMLookAtImporter.prototype._importCurveMapperBone = function (map) {\n        return new CurveMapper_1.CurveMapper(typeof map.xRange === 'number' ? THREE.Math.DEG2RAD * map.xRange : undefined, typeof map.yRange === 'number' ? THREE.Math.DEG2RAD * map.yRange : undefined, map.curve);\n      };\n\n      VRMLookAtImporter.prototype._importCurveMapperBlendShape = function (map) {\n        return new CurveMapper_1.CurveMapper(typeof map.xRange === 'number' ? THREE.Math.DEG2RAD * map.xRange : undefined, map.yRange, map.curve);\n      };\n\n      return VRMLookAtImporter;\n    }();\n\n    exports.VRMLookAtImporter = VRMLookAtImporter;\n    /***/\n  },\n\n  /***/\n  \"./src/vrm/lookat/index.ts\":\n  /*!*********************************!*\\\r\n    !*** ./src/vrm/lookat/index.ts ***!\r\n    \\*********************************/\n\n  /*! no static exports found */\n\n  /***/\n  function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    function __export(m) {\n      for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n    }\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n\n    __export(__webpack_require__(\n    /*! ./CurveMapper */\n    \"./src/vrm/lookat/CurveMapper.ts\"));\n\n    __export(__webpack_require__(\n    /*! ./VRMLookAtApplyer */\n    \"./src/vrm/lookat/VRMLookAtApplyer.ts\"));\n\n    __export(__webpack_require__(\n    /*! ./VRMLookAtBlendShapeApplyer */\n    \"./src/vrm/lookat/VRMLookAtBlendShapeApplyer.ts\"));\n\n    __export(__webpack_require__(\n    /*! ./VRMLookAtBoneApplyer */\n    \"./src/vrm/lookat/VRMLookAtBoneApplyer.ts\"));\n\n    __export(__webpack_require__(\n    /*! ./VRMLookAtHead */\n    \"./src/vrm/lookat/VRMLookAtHead.ts\"));\n\n    __export(__webpack_require__(\n    /*! ./VRMLookAtImporter */\n    \"./src/vrm/lookat/VRMLookAtImporter.ts\"));\n    /***/\n\n  },\n\n  /***/\n  \"./src/vrm/material/MToonMaterial.ts\":\n  /*!*******************************************!*\\\r\n    !*** ./src/vrm/material/MToonMaterial.ts ***!\r\n    \\*******************************************/\n\n  /*! no static exports found */\n\n  /***/\n  function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    var __extends = this && this.__extends || function () {\n      var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (d, b) {\n          d.__proto__ = b;\n        } || function (d, b) {\n          for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n        };\n\n        return extendStatics(d, b);\n      };\n\n      return function (d, b) {\n        extendStatics(d, b);\n\n        function __() {\n          this.constructor = d;\n        }\n\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n      };\n    }();\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n\n    var THREE = __webpack_require__(\n    /*! three */\n    \"three\");\n\n    var getTexelDecodingFunction_1 = __webpack_require__(\n    /*! ./getTexelDecodingFunction */\n    \"./src/vrm/material/getTexelDecodingFunction.ts\");\n\n    var mtoon_vert_1 = __webpack_require__(\n    /*! ./shaders/mtoon.vert */\n    \"./src/vrm/material/shaders/mtoon.vert\");\n\n    var mtoon_frag_1 = __webpack_require__(\n    /*! ./shaders/mtoon.frag */\n    \"./src/vrm/material/shaders/mtoon.frag\");\n\n    var TAU = 2.0 * Math.PI;\n    var MToonMaterialCullMode;\n\n    (function (MToonMaterialCullMode) {\n      MToonMaterialCullMode[MToonMaterialCullMode[\"Off\"] = 0] = \"Off\";\n      MToonMaterialCullMode[MToonMaterialCullMode[\"Front\"] = 1] = \"Front\";\n      MToonMaterialCullMode[MToonMaterialCullMode[\"Back\"] = 2] = \"Back\";\n    })(MToonMaterialCullMode = exports.MToonMaterialCullMode || (exports.MToonMaterialCullMode = {}));\n\n    var MToonMaterialDebugMode;\n\n    (function (MToonMaterialDebugMode) {\n      MToonMaterialDebugMode[MToonMaterialDebugMode[\"None\"] = 0] = \"None\";\n      MToonMaterialDebugMode[MToonMaterialDebugMode[\"Normal\"] = 1] = \"Normal\";\n      MToonMaterialDebugMode[MToonMaterialDebugMode[\"LitShadeRate\"] = 2] = \"LitShadeRate\";\n      MToonMaterialDebugMode[MToonMaterialDebugMode[\"UV\"] = 3] = \"UV\";\n    })(MToonMaterialDebugMode = exports.MToonMaterialDebugMode || (exports.MToonMaterialDebugMode = {}));\n\n    var MToonMaterialOutlineColorMode;\n\n    (function (MToonMaterialOutlineColorMode) {\n      MToonMaterialOutlineColorMode[MToonMaterialOutlineColorMode[\"FixedColor\"] = 0] = \"FixedColor\";\n      MToonMaterialOutlineColorMode[MToonMaterialOutlineColorMode[\"MixedLighting\"] = 1] = \"MixedLighting\";\n    })(MToonMaterialOutlineColorMode = exports.MToonMaterialOutlineColorMode || (exports.MToonMaterialOutlineColorMode = {}));\n\n    var MToonMaterialOutlineWidthMode;\n\n    (function (MToonMaterialOutlineWidthMode) {\n      MToonMaterialOutlineWidthMode[MToonMaterialOutlineWidthMode[\"None\"] = 0] = \"None\";\n      MToonMaterialOutlineWidthMode[MToonMaterialOutlineWidthMode[\"WorldCoordinates\"] = 1] = \"WorldCoordinates\";\n      MToonMaterialOutlineWidthMode[MToonMaterialOutlineWidthMode[\"ScreenCoordinates\"] = 2] = \"ScreenCoordinates\";\n    })(MToonMaterialOutlineWidthMode = exports.MToonMaterialOutlineWidthMode || (exports.MToonMaterialOutlineWidthMode = {}));\n\n    var MToonMaterialRenderMode;\n\n    (function (MToonMaterialRenderMode) {\n      MToonMaterialRenderMode[MToonMaterialRenderMode[\"Opaque\"] = 0] = \"Opaque\";\n      MToonMaterialRenderMode[MToonMaterialRenderMode[\"Cutout\"] = 1] = \"Cutout\";\n      MToonMaterialRenderMode[MToonMaterialRenderMode[\"Transparent\"] = 2] = \"Transparent\";\n      MToonMaterialRenderMode[MToonMaterialRenderMode[\"TransparentWithZWrite\"] = 3] = \"TransparentWithZWrite\";\n    })(MToonMaterialRenderMode = exports.MToonMaterialRenderMode || (exports.MToonMaterialRenderMode = {}));\n\n    var MToonMaterial = function (_super) {\n      __extends(MToonMaterial, _super);\n\n      function MToonMaterial(colorSpaceGamma, parameters) {\n        var _this = _super.call(this) || this;\n\n        _this.isMToonMaterial = true;\n        _this.cutoff = 0.5;\n        _this.color = new THREE.Vector4(1.0, 1.0, 1.0, 1.0);\n        _this.shadeColor = new THREE.Vector4(0.97, 0.81, 0.86, 1.0);\n        _this.map = null;\n        _this.mainTex_ST = new THREE.Vector4(0.0, 0.0, 1.0, 1.0);\n        _this.shadeTexture = null;\n        _this.bumpScale = 1.0;\n        _this.normalMap = null;\n        _this.receiveShadowRate = 1.0;\n        _this.receiveShadowTexture = null;\n        _this.shadingGradeRate = 1.0;\n        _this.shadingGradeTexture = null;\n        _this.shadeShift = 0.0;\n        _this.shadeToony = 0.9;\n        _this.lightColorAttenuation = 0.0;\n        _this.indirectLightIntensity = 0.1;\n        _this.rimTexture = null;\n        _this.rimColor = new THREE.Vector4(0.0, 0.0, 0.0, 1.0);\n        _this.rimLightingMix = 0.0;\n        _this.rimFresnelPower = 1.0;\n        _this.rimLift = 0.0;\n        _this.sphereAdd = null;\n        _this.emissionColor = new THREE.Vector4(0.0, 0.0, 0.0, 1.0);\n        _this.emissiveMap = null;\n        _this.outlineWidthTexture = null;\n        _this.outlineWidth = 0.5;\n        _this.outlineScaledMaxDistance = 1.0;\n        _this.outlineColor = new THREE.Vector4(0.0, 0.0, 0.0, 1.0);\n        _this.outlineLightingMix = 1.0;\n        _this.uvAnimMaskTexture = null;\n        _this.uvAnimScrollX = 0.0;\n        _this.uvAnimScrollY = 0.0;\n        _this.uvAnimRotation = 0.0;\n        _this.shouldApplyUniforms = true;\n        _this._debugMode = MToonMaterialDebugMode.None;\n        _this._blendMode = MToonMaterialRenderMode.Opaque;\n        _this._outlineWidthMode = MToonMaterialOutlineWidthMode.None;\n        _this._outlineColorMode = MToonMaterialOutlineColorMode.FixedColor;\n        _this._cullMode = MToonMaterialCullMode.Back;\n        _this._outlineCullMode = MToonMaterialCullMode.Front;\n        _this._isOutline = false;\n        _this._uvAnimOffsetX = 0.0;\n        _this._uvAnimOffsetY = 0.0;\n        _this._uvAnimPhase = 0.0;\n        _this._colorSpaceGamma = colorSpaceGamma;\n\n        if (parameters === undefined) {\n          parameters = {};\n        }\n\n        ['mToonVersion', 'shadeTexture_ST', 'bumpMap_ST', 'receiveShadowTexture_ST', 'shadingGradeTexture_ST', 'sphereAdd_ST', 'emissionMap_ST', 'outlineWidthTexture_ST', 'srcBlend', 'dstBlend'].forEach(function (key) {\n          if (parameters[key] !== undefined) {\n            delete parameters[key];\n          }\n        });\n        parameters.fog = true;\n        parameters.lights = true;\n        parameters.clipping = true;\n        parameters.skinning = parameters.skinning || false;\n        parameters.morphTargets = parameters.morphTargets || false;\n        parameters.morphNormals = parameters.morphNormals || false;\n        parameters.uniforms = THREE.UniformsUtils.merge([THREE.UniformsLib.common, THREE.UniformsLib.normalmap, THREE.UniformsLib.emissivemap, THREE.UniformsLib.fog, THREE.UniformsLib.lights, {\n          cutoff: {\n            value: 0.5\n          },\n          color: {\n            value: new THREE.Color(1.0, 1.0, 1.0)\n          },\n          colorAlpha: {\n            value: 1.0\n          },\n          shadeColor: {\n            value: new THREE.Color(0.97, 0.81, 0.86)\n          },\n          mainTex_ST: {\n            value: new THREE.Vector4(0.0, 0.0, 1.0, 1.0)\n          },\n          shadeTexture: {\n            value: null\n          },\n          bumpScale: {\n            value: 1.0\n          },\n          receiveShadowRate: {\n            value: 1.0\n          },\n          receiveShadowTexture: {\n            value: null\n          },\n          shadingGradeRate: {\n            value: 1.0\n          },\n          shadingGradeTexture: {\n            value: null\n          },\n          shadeShift: {\n            value: 0.0\n          },\n          shadeToony: {\n            value: 0.9\n          },\n          lightColorAttenuation: {\n            value: 0.0\n          },\n          indirectLightIntensity: {\n            value: 0.1\n          },\n          rimTexture: {\n            value: null\n          },\n          rimColor: {\n            value: new THREE.Color(0.0, 0.0, 0.0)\n          },\n          rimLightingMix: {\n            value: 0.0\n          },\n          rimFresnelPower: {\n            value: 1.0\n          },\n          rimLift: {\n            value: 0.0\n          },\n          sphereAdd: {\n            value: null\n          },\n          emissionColor: {\n            value: new THREE.Color(0.0, 0.0, 0.0)\n          },\n          outlineWidthTexture: {\n            value: null\n          },\n          outlineWidth: {\n            value: 0.5\n          },\n          outlineScaledMaxDistance: {\n            value: 1.0\n          },\n          outlineColor: {\n            value: new THREE.Color(0.0, 0.0, 0.0)\n          },\n          outlineLightingMix: {\n            value: 1.0\n          },\n          uvAnimMaskTexture: {\n            value: null\n          },\n          uvAnimOffsetX: {\n            value: 0.0\n          },\n          uvAnimOffsetY: {\n            value: 0.0\n          },\n          uvAnimTheta: {\n            value: 0.0\n          }\n        }]);\n\n        _this.setValues(parameters);\n\n        _this._updateShaderCode();\n\n        _this._applyUniforms();\n\n        return _this;\n      }\n\n      Object.defineProperty(MToonMaterial.prototype, \"mainTex\", {\n        get: function () {\n          return this.map;\n        },\n        set: function (t) {\n          this.map = t;\n        },\n        enumerable: true,\n        configurable: true\n      });\n      Object.defineProperty(MToonMaterial.prototype, \"bumpMap\", {\n        get: function () {\n          return this.normalMap;\n        },\n        set: function (t) {\n          this.normalMap = t;\n        },\n        enumerable: true,\n        configurable: true\n      });\n      Object.defineProperty(MToonMaterial.prototype, \"emissionMap\", {\n        get: function () {\n          return this.emissiveMap;\n        },\n        set: function (t) {\n          this.emissiveMap = t;\n        },\n        enumerable: true,\n        configurable: true\n      });\n      Object.defineProperty(MToonMaterial.prototype, \"blendMode\", {\n        get: function () {\n          return this._blendMode;\n        },\n        set: function (m) {\n          this._blendMode = m;\n          this.depthWrite = this._blendMode !== MToonMaterialRenderMode.Transparent;\n          this.transparent = this._blendMode === MToonMaterialRenderMode.Transparent || this._blendMode === MToonMaterialRenderMode.TransparentWithZWrite;\n\n          this._updateShaderCode();\n        },\n        enumerable: true,\n        configurable: true\n      });\n      Object.defineProperty(MToonMaterial.prototype, \"debugMode\", {\n        get: function () {\n          return this._debugMode;\n        },\n        set: function (m) {\n          this._debugMode = m;\n\n          this._updateShaderCode();\n        },\n        enumerable: true,\n        configurable: true\n      });\n      Object.defineProperty(MToonMaterial.prototype, \"outlineWidthMode\", {\n        get: function () {\n          return this._outlineWidthMode;\n        },\n        set: function (m) {\n          this._outlineWidthMode = m;\n\n          this._updateShaderCode();\n        },\n        enumerable: true,\n        configurable: true\n      });\n      Object.defineProperty(MToonMaterial.prototype, \"outlineColorMode\", {\n        get: function () {\n          return this._outlineColorMode;\n        },\n        set: function (m) {\n          this._outlineColorMode = m;\n\n          this._updateShaderCode();\n        },\n        enumerable: true,\n        configurable: true\n      });\n      Object.defineProperty(MToonMaterial.prototype, \"cullMode\", {\n        get: function () {\n          return this._cullMode;\n        },\n        set: function (m) {\n          this._cullMode = m;\n\n          this._updateCullFace();\n        },\n        enumerable: true,\n        configurable: true\n      });\n      Object.defineProperty(MToonMaterial.prototype, \"outlineCullMode\", {\n        get: function () {\n          return this._outlineCullMode;\n        },\n        set: function (m) {\n          this._outlineCullMode = m;\n\n          this._updateCullFace();\n        },\n        enumerable: true,\n        configurable: true\n      });\n      Object.defineProperty(MToonMaterial.prototype, \"zWrite\", {\n        get: function () {\n          return this.depthWrite ? 1 : 0;\n        },\n        set: function (i) {\n          this.depthWrite = 0.5 <= i;\n        },\n        enumerable: true,\n        configurable: true\n      });\n      Object.defineProperty(MToonMaterial.prototype, \"isOutline\", {\n        get: function () {\n          return this._isOutline;\n        },\n        set: function (b) {\n          this._isOutline = b;\n\n          this._updateShaderCode();\n\n          this._updateCullFace();\n        },\n        enumerable: true,\n        configurable: true\n      });\n\n      MToonMaterial.prototype.updateVRMMaterials = function (delta) {\n        this._uvAnimOffsetX = this._uvAnimOffsetX + delta * this.uvAnimScrollX;\n        this._uvAnimOffsetY = this._uvAnimOffsetY + delta * this.uvAnimScrollY;\n        this._uvAnimPhase = this._uvAnimPhase + delta * this.uvAnimRotation;\n\n        this._applyUniforms();\n      };\n\n      MToonMaterial.prototype.copy = function (source) {\n        _super.prototype.copy.call(this, source);\n\n        this.cutoff = source.cutoff;\n        this.color.copy(source.color);\n        this.shadeColor.copy(source.shadeColor);\n        this.map = source.map;\n        this.mainTex_ST.copy(source.mainTex_ST);\n        this.shadeTexture = source.shadeTexture;\n        this.bumpScale = source.bumpScale;\n        this.normalMap = source.normalMap;\n        this.receiveShadowRate = source.receiveShadowRate;\n        this.receiveShadowTexture = source.receiveShadowTexture;\n        this.shadingGradeRate = source.shadingGradeRate;\n        this.shadingGradeTexture = source.shadingGradeTexture;\n        this.shadeShift = source.shadeShift;\n        this.shadeToony = source.shadeToony;\n        this.lightColorAttenuation = source.lightColorAttenuation;\n        this.indirectLightIntensity = source.indirectLightIntensity;\n        this.rimTexture = source.rimTexture;\n        this.rimColor.copy(source.rimColor);\n        this.rimLightingMix = source.rimLightingMix;\n        this.rimFresnelPower = source.rimFresnelPower;\n        this.rimLift = source.rimLift;\n        this.sphereAdd = source.sphereAdd;\n        this.emissionColor.copy(source.emissionColor);\n        this.emissiveMap = source.emissiveMap;\n        this.outlineWidthTexture = source.outlineWidthTexture;\n        this.outlineWidth = source.outlineWidth;\n        this.outlineScaledMaxDistance = source.outlineScaledMaxDistance;\n        this.outlineColor.copy(source.outlineColor);\n        this.outlineLightingMix = source.outlineLightingMix;\n        this.uvAnimMaskTexture = source.uvAnimMaskTexture;\n        this.uvAnimScrollX = source.uvAnimScrollX;\n        this.uvAnimScrollY = source.uvAnimScrollY;\n        this.uvAnimRotation = source.uvAnimRotation;\n        this.debugMode = source.debugMode;\n        this.blendMode = source.blendMode;\n        this.outlineWidthMode = source.outlineWidthMode;\n        this.outlineColorMode = source.outlineColorMode;\n        this.cullMode = source.cullMode;\n        this.outlineCullMode = source.outlineCullMode;\n        this.isOutline = source.isOutline;\n        return this;\n      };\n\n      MToonMaterial.prototype._applyUniforms = function () {\n        this.uniforms.uvAnimOffsetX.value = this._uvAnimOffsetX;\n        this.uniforms.uvAnimOffsetY.value = this._uvAnimOffsetY;\n        this.uniforms.uvAnimTheta.value = TAU * this._uvAnimPhase;\n\n        if (!this.shouldApplyUniforms) {\n          return;\n        }\n\n        this.shouldApplyUniforms = false;\n        this.uniforms.cutoff.value = this.cutoff;\n        this.uniforms.color.value.setRGB(this.color.x, this.color.y, this.color.z);\n\n        if (!this._colorSpaceGamma) {\n          this.uniforms.color.value.convertSRGBToLinear();\n        }\n\n        this.uniforms.colorAlpha.value = this.color.w;\n        this.uniforms.shadeColor.value.setRGB(this.shadeColor.x, this.shadeColor.y, this.shadeColor.z);\n\n        if (!this._colorSpaceGamma) {\n          this.uniforms.shadeColor.value.convertSRGBToLinear();\n        }\n\n        this.uniforms.map.value = this.map;\n        this.uniforms.mainTex_ST.value.copy(this.mainTex_ST);\n        this.uniforms.shadeTexture.value = this.shadeTexture;\n        this.uniforms.bumpScale.value = this.bumpScale;\n        this.uniforms.normalMap.value = this.normalMap;\n        this.uniforms.receiveShadowRate.value = this.receiveShadowRate;\n        this.uniforms.receiveShadowTexture.value = this.receiveShadowTexture;\n        this.uniforms.shadingGradeRate.value = this.shadingGradeRate;\n        this.uniforms.shadingGradeTexture.value = this.shadingGradeTexture;\n        this.uniforms.shadeShift.value = this.shadeShift;\n        this.uniforms.shadeToony.value = this.shadeToony;\n        this.uniforms.lightColorAttenuation.value = this.lightColorAttenuation;\n        this.uniforms.indirectLightIntensity.value = this.indirectLightIntensity;\n        this.uniforms.rimTexture.value = this.rimTexture;\n        this.uniforms.rimColor.value.setRGB(this.rimColor.x, this.rimColor.y, this.rimColor.z);\n\n        if (!this._colorSpaceGamma) {\n          this.uniforms.rimColor.value.convertSRGBToLinear();\n        }\n\n        this.uniforms.rimLightingMix.value = this.rimLightingMix;\n        this.uniforms.rimFresnelPower.value = this.rimFresnelPower;\n        this.uniforms.rimLift.value = this.rimLift;\n        this.uniforms.sphereAdd.value = this.sphereAdd;\n        this.uniforms.emissionColor.value.setRGB(this.emissionColor.x, this.emissionColor.y, this.emissionColor.z);\n\n        if (!this._colorSpaceGamma) {\n          this.uniforms.emissionColor.value.convertSRGBToLinear();\n        }\n\n        this.uniforms.emissiveMap.value = this.emissiveMap;\n        this.uniforms.outlineWidthTexture.value = this.outlineWidthTexture;\n        this.uniforms.outlineWidth.value = this.outlineWidth;\n        this.uniforms.outlineScaledMaxDistance.value = this.outlineScaledMaxDistance;\n        this.uniforms.outlineColor.value.setRGB(this.outlineColor.x, this.outlineColor.y, this.outlineColor.z);\n\n        if (!this._colorSpaceGamma) {\n          this.uniforms.outlineColor.value.convertSRGBToLinear();\n        }\n\n        this.uniforms.outlineLightingMix.value = this.outlineLightingMix;\n        this.uniforms.uvAnimMaskTexture.value = this.uvAnimMaskTexture;\n\n        this._updateCullFace();\n      };\n\n      MToonMaterial.prototype._updateShaderCode = function () {\n        this.defines = {\n          OUTLINE: this._isOutline,\n          BLENDMODE_OPAQUE: this._blendMode === MToonMaterialRenderMode.Opaque,\n          BLENDMODE_CUTOUT: this._blendMode === MToonMaterialRenderMode.Cutout,\n          BLENDMODE_TRANSPARENT: this._blendMode === MToonMaterialRenderMode.Transparent || this._blendMode === MToonMaterialRenderMode.TransparentWithZWrite,\n          USE_SHADETEXTURE: this.shadeTexture !== null,\n          USE_RECEIVESHADOWTEXTURE: this.receiveShadowTexture !== null,\n          USE_SHADINGGRADETEXTURE: this.shadingGradeTexture !== null,\n          USE_RIMTEXTURE: this.rimTexture !== null,\n          USE_SPHEREADD: this.sphereAdd !== null,\n          USE_OUTLINEWIDTHTEXTURE: this.outlineWidthTexture !== null,\n          USE_UVANIMMASKTEXTURE: this.uvAnimMaskTexture !== null,\n          DEBUG_NORMAL: this._debugMode === MToonMaterialDebugMode.Normal,\n          DEBUG_LITSHADERATE: this._debugMode === MToonMaterialDebugMode.LitShadeRate,\n          DEBUG_UV: this._debugMode === MToonMaterialDebugMode.UV,\n          OUTLINE_WIDTH_WORLD: this._outlineWidthMode === MToonMaterialOutlineWidthMode.WorldCoordinates,\n          OUTLINE_WIDTH_SCREEN: this._outlineWidthMode === MToonMaterialOutlineWidthMode.ScreenCoordinates,\n          OUTLINE_COLOR_FIXED: this._outlineColorMode === MToonMaterialOutlineColorMode.FixedColor,\n          OUTLINE_COLOR_MIXED: this._outlineColorMode === MToonMaterialOutlineColorMode.MixedLighting\n        };\n        var encodings = (this.shadeTexture !== null ? getTexelDecodingFunction_1.getTexelDecodingFunction('shadeTextureTexelToLinear', this.shadeTexture.encoding) + '\\n' : '') + (this.sphereAdd !== null ? getTexelDecodingFunction_1.getTexelDecodingFunction('sphereAddTexelToLinear', this.sphereAdd.encoding) + '\\n' : '');\n        this.vertexShader = mtoon_vert_1.default;\n        this.fragmentShader = encodings + mtoon_frag_1.default;\n        this.needsUpdate = true;\n      };\n\n      MToonMaterial.prototype._updateCullFace = function () {\n        if (!this.isOutline) {\n          if (this.cullMode === MToonMaterialCullMode.Off) {\n            this.side = THREE.DoubleSide;\n          } else if (this.cullMode === MToonMaterialCullMode.Front) {\n            this.side = THREE.BackSide;\n          } else if (this.cullMode === MToonMaterialCullMode.Back) {\n            this.side = THREE.FrontSide;\n          }\n        } else {\n          if (this.outlineCullMode === MToonMaterialCullMode.Off) {\n            this.side = THREE.DoubleSide;\n          } else if (this.outlineCullMode === MToonMaterialCullMode.Front) {\n            this.side = THREE.BackSide;\n          } else if (this.outlineCullMode === MToonMaterialCullMode.Back) {\n            this.side = THREE.FrontSide;\n          }\n        }\n      };\n\n      return MToonMaterial;\n    }(THREE.ShaderMaterial);\n\n    exports.MToonMaterial = MToonMaterial;\n    /***/\n  },\n\n  /***/\n  \"./src/vrm/material/VRMMaterialImporter.ts\":\n  /*!*************************************************!*\\\r\n    !*** ./src/vrm/material/VRMMaterialImporter.ts ***!\r\n    \\*************************************************/\n\n  /*! no static exports found */\n\n  /***/\n  function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n      return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) {\n          try {\n            step(generator.next(value));\n          } catch (e) {\n            reject(e);\n          }\n        }\n\n        function rejected(value) {\n          try {\n            step(generator[\"throw\"](value));\n          } catch (e) {\n            reject(e);\n          }\n        }\n\n        function step(result) {\n          result.done ? resolve(result.value) : new P(function (resolve) {\n            resolve(result.value);\n          }).then(fulfilled, rejected);\n        }\n\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n      });\n    };\n\n    var __generator = this && this.__generator || function (thisArg, body) {\n      var _ = {\n        label: 0,\n        sent: function () {\n          if (t[0] & 1) throw t[1];\n          return t[1];\n        },\n        trys: [],\n        ops: []\n      },\n          f,\n          y,\n          t,\n          g;\n      return g = {\n        next: verb(0),\n        \"throw\": verb(1),\n        \"return\": verb(2)\n      }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n        return this;\n      }), g;\n\n      function verb(n) {\n        return function (v) {\n          return step([n, v]);\n        };\n      }\n\n      function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n\n        while (_) try {\n          if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n          if (y = 0, t) op = [op[0] & 2, t.value];\n\n          switch (op[0]) {\n            case 0:\n            case 1:\n              t = op;\n              break;\n\n            case 4:\n              _.label++;\n              return {\n                value: op[1],\n                done: false\n              };\n\n            case 5:\n              _.label++;\n              y = op[1];\n              op = [0];\n              continue;\n\n            case 7:\n              op = _.ops.pop();\n\n              _.trys.pop();\n\n              continue;\n\n            default:\n              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n                _ = 0;\n                continue;\n              }\n\n              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n                _.label = op[1];\n                break;\n              }\n\n              if (op[0] === 6 && _.label < t[1]) {\n                _.label = t[1];\n                t = op;\n                break;\n              }\n\n              if (t && _.label < t[2]) {\n                _.label = t[2];\n\n                _.ops.push(op);\n\n                break;\n              }\n\n              if (t[2]) _.ops.pop();\n\n              _.trys.pop();\n\n              continue;\n          }\n\n          op = body.call(thisArg, _);\n        } catch (e) {\n          op = [6, e];\n          y = 0;\n        } finally {\n          f = t = 0;\n        }\n\n        if (op[0] & 5) throw op[1];\n        return {\n          value: op[0] ? op[1] : void 0,\n          done: true\n        };\n      }\n    };\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n\n    var THREE = __webpack_require__(\n    /*! three */\n    \"three\");\n\n    var MToonMaterial_1 = __webpack_require__(\n    /*! ./MToonMaterial */\n    \"./src/vrm/material/MToonMaterial.ts\");\n\n    var VRMUnlitMaterial_1 = __webpack_require__(\n    /*! ./VRMUnlitMaterial */\n    \"./src/vrm/material/VRMUnlitMaterial.ts\");\n\n    var VRMMaterialImporter = function () {\n      function VRMMaterialImporter(options) {\n        if (options === void 0) {\n          options = {};\n        }\n\n        this._colorSpaceGamma = options.colorSpaceGamma || true;\n        this._requestEnvMap = options.requestEnvMap;\n      }\n\n      VRMMaterialImporter.prototype.convertGLTFMaterials = function (gltf) {\n        return __awaiter(this, void 0, Promise, function () {\n          var vrmExt, materialProperties, meshesMap, materialList, materials;\n\n          var _this = this;\n\n          return __generator(this, function (_a) {\n            switch (_a.label) {\n              case 0:\n                vrmExt = gltf.parser.json.extensions && gltf.parser.json.extensions.VRM;\n\n                if (!vrmExt) {\n                  return [2, null];\n                }\n\n                materialProperties = vrmExt.materialProperties;\n\n                if (!materialProperties) {\n                  return [2, null];\n                }\n\n                return [4, gltf.parser.getDependencies('mesh')];\n\n              case 1:\n                meshesMap = _a.sent();\n                materialList = {};\n                materials = [];\n                return [4, Promise.all(meshesMap.map(function (mesh, meshIndex) {\n                  return __awaiter(_this, void 0, void 0, function () {\n                    var primitives;\n\n                    var _this = this;\n\n                    return __generator(this, function (_a) {\n                      switch (_a.label) {\n                        case 0:\n                          primitives = mesh.type === 'Group' ? mesh.children : [mesh];\n                          return [4, Promise.all(primitives.map(function (primitive, primitiveIndex) {\n                            return __awaiter(_this, void 0, void 0, function () {\n                              var vrmMaterialIndex, props, vrmMaterials;\n                              return __generator(this, function (_a) {\n                                switch (_a.label) {\n                                  case 0:\n                                    if (!Array.isArray(primitive.material)) {\n                                      primitive.material = [primitive.material];\n                                      primitive.geometry.addGroup(0, primitive.geometry.index.count, 0);\n                                    }\n\n                                    vrmMaterialIndex = gltf.parser.json.meshes[meshIndex].primitives[primitiveIndex].material;\n                                    props = materialProperties[vrmMaterialIndex];\n\n                                    if (!props) {\n                                      console.warn(\"VRMMaterialImporter: There are no material definition for material #\" + vrmMaterialIndex + \" on VRM extension.\");\n                                      props = {\n                                        shader: 'VRM_USE_GLTFSHADER'\n                                      };\n                                    }\n\n                                    if (!materialList[vrmMaterialIndex]) return [3, 1];\n                                    vrmMaterials = materialList[vrmMaterialIndex];\n                                    return [3, 3];\n\n                                  case 1:\n                                    return [4, this.createVRMMaterials(primitive.material[0], props, gltf)];\n\n                                  case 2:\n                                    vrmMaterials = _a.sent();\n                                    materialList[vrmMaterialIndex] = vrmMaterials;\n                                    materials.push(vrmMaterials.surface);\n\n                                    if (vrmMaterials.outline) {\n                                      materials.push(vrmMaterials.outline);\n                                    }\n\n                                    _a.label = 3;\n\n                                  case 3:\n                                    primitive.material[0] = vrmMaterials.surface;\n\n                                    if (this._requestEnvMap) {\n                                      this._requestEnvMap().then(function (envMap) {\n                                        vrmMaterials.surface.envMap = envMap;\n                                        vrmMaterials.surface.needsUpdate = true;\n                                      });\n                                    }\n\n                                    primitive.renderOrder = props.renderQueue || 2000;\n\n                                    if (vrmMaterials.outline) {\n                                      primitive.material[1] = vrmMaterials.outline;\n                                      primitive.geometry.addGroup(0, primitive.geometry.index.count, 1);\n                                    }\n\n                                    return [2];\n                                }\n                              });\n                            });\n                          }))];\n\n                        case 1:\n                          _a.sent();\n\n                          return [2];\n                      }\n                    });\n                  });\n                }))];\n\n              case 2:\n                _a.sent();\n\n                return [2, materials];\n            }\n          });\n        });\n      };\n\n      VRMMaterialImporter.prototype.createVRMMaterials = function (originalMaterial, vrmProps, gltf) {\n        return __awaiter(this, void 0, Promise, function () {\n          var newSurface, newOutline, params_1, params, params, params, params;\n\n          var _this = this;\n\n          return __generator(this, function (_a) {\n            switch (_a.label) {\n              case 0:\n                if (!(vrmProps.shader === 'VRM/MToon')) return [3, 2];\n                return [4, this._extractMaterialProperties(originalMaterial, vrmProps, gltf)];\n\n              case 1:\n                params_1 = _a.sent();\n                ['srcBlend', 'dstBlend', 'isFirstSetup'].forEach(function (name) {\n                  if (params_1[name] !== undefined) {\n                    delete params_1[name];\n                  }\n                });\n                ['mainTex', 'shadeTexture', 'emission', 'sphereAdd'].forEach(function (name) {\n                  if (params_1[name] !== undefined) {\n                    params_1[name].encoding = _this._colorSpaceGamma ? THREE.LinearEncoding : THREE.sRGBEncoding;\n                  }\n                });\n                newSurface = new MToonMaterial_1.MToonMaterial(this._colorSpaceGamma, params_1);\n\n                if (params_1.outlineWidthMode !== MToonMaterial_1.MToonMaterialOutlineWidthMode.None) {\n                  params_1.isOutline = true;\n                  newOutline = new MToonMaterial_1.MToonMaterial(this._colorSpaceGamma, params_1);\n                }\n\n                return [3, 11];\n\n              case 2:\n                if (!(vrmProps.shader === 'VRM/UnlitTexture')) return [3, 4];\n                return [4, this._extractMaterialProperties(originalMaterial, vrmProps, gltf)];\n\n              case 3:\n                params = _a.sent();\n                params.renderType = VRMUnlitMaterial_1.VRMUnlitMaterialRenderType.Opaque;\n                newSurface = new VRMUnlitMaterial_1.VRMUnlitMaterial(params);\n                return [3, 11];\n\n              case 4:\n                if (!(vrmProps.shader === 'VRM/UnlitCutout')) return [3, 6];\n                return [4, this._extractMaterialProperties(originalMaterial, vrmProps, gltf)];\n\n              case 5:\n                params = _a.sent();\n                params.renderType = VRMUnlitMaterial_1.VRMUnlitMaterialRenderType.Cutout;\n                newSurface = new VRMUnlitMaterial_1.VRMUnlitMaterial(params);\n                return [3, 11];\n\n              case 6:\n                if (!(vrmProps.shader === 'VRM/UnlitTransparent')) return [3, 8];\n                return [4, this._extractMaterialProperties(originalMaterial, vrmProps, gltf)];\n\n              case 7:\n                params = _a.sent();\n                params.renderType = VRMUnlitMaterial_1.VRMUnlitMaterialRenderType.Transparent;\n                newSurface = new VRMUnlitMaterial_1.VRMUnlitMaterial(params);\n                return [3, 11];\n\n              case 8:\n                if (!(vrmProps.shader === 'VRM/UnlitTransparentZWrite')) return [3, 10];\n                return [4, this._extractMaterialProperties(originalMaterial, vrmProps, gltf)];\n\n              case 9:\n                params = _a.sent();\n                params.renderType = VRMUnlitMaterial_1.VRMUnlitMaterialRenderType.TransparentWithZWrite;\n                newSurface = new VRMUnlitMaterial_1.VRMUnlitMaterial(params);\n                return [3, 11];\n\n              case 10:\n                if (vrmProps.shader !== 'VRM_USE_GLTFSHADER') {\n                  console.warn(\"Unknown shader detected: \\\"\" + vrmProps.shader + \"\\\"\");\n                }\n\n                newSurface = this._convertGLTFMaterial(originalMaterial.clone());\n                _a.label = 11;\n\n              case 11:\n                newSurface.name = originalMaterial.name;\n                newSurface.userData = JSON.parse(JSON.stringify(originalMaterial.userData));\n                newSurface.userData.vrmMaterialProperties = vrmProps;\n\n                if (newOutline) {\n                  newOutline.name = originalMaterial.name + ' (Outline)';\n                  newOutline.userData = JSON.parse(JSON.stringify(originalMaterial.userData));\n                  newOutline.userData.vrmMaterialProperties = vrmProps;\n                }\n\n                return [2, {\n                  surface: newSurface,\n                  outline: newOutline\n                }];\n            }\n          });\n        });\n      };\n\n      VRMMaterialImporter.prototype._renameMaterialProperty = function (name) {\n        if (name[0] !== '_') {\n          console.warn(\"VRMMaterials: Given property name \\\"\" + name + \"\\\" might be invalid\");\n          return name;\n        }\n\n        name = name.substring(1);\n\n        if (!/[A-Z]/.test(name[0])) {\n          console.warn(\"VRMMaterials: Given property name \\\"\" + name + \"\\\" might be invalid\");\n          return name;\n        }\n\n        return name[0].toLowerCase() + name.substring(1);\n      };\n\n      VRMMaterialImporter.prototype._convertGLTFMaterial = function (material) {\n        if (material.isMeshStandardMaterial) {\n          var mtl = material;\n\n          if (this._colorSpaceGamma) {\n            if (mtl.map) {\n              mtl.map.encoding = THREE.LinearEncoding;\n            }\n\n            if (mtl.emissiveMap) {\n              mtl.emissiveMap.encoding = THREE.LinearEncoding;\n            }\n          } else {\n            mtl.color.convertSRGBToLinear();\n            mtl.emissive.convertSRGBToLinear();\n          }\n        }\n\n        if (material.isMeshBasicMaterial) {\n          var mtl = material;\n\n          if (this._colorSpaceGamma) {\n            if (mtl.map) {\n              mtl.map.encoding = THREE.LinearEncoding;\n            }\n          } else {\n            mtl.color.convertSRGBToLinear();\n          }\n        }\n\n        return material;\n      };\n\n      VRMMaterialImporter.prototype._extractMaterialProperties = function (originalMaterial, vrmProps, gltf) {\n        var taskList = [];\n        var params = {};\n\n        if (vrmProps.textureProperties) {\n          var _loop_1 = function (name) {\n            var newName = this_1._renameMaterialProperty(name);\n\n            var textureIndex = vrmProps.textureProperties[name];\n            taskList.push(gltf.parser.getDependency('texture', textureIndex).then(function (texture) {\n              params[newName] = texture;\n            }));\n          };\n\n          var this_1 = this;\n\n          for (var _i = 0, _a = Object.keys(vrmProps.textureProperties); _i < _a.length; _i++) {\n            var name = _a[_i];\n\n            _loop_1(name);\n          }\n        }\n\n        if (vrmProps.floatProperties) {\n          for (var _b = 0, _c = Object.keys(vrmProps.floatProperties); _b < _c.length; _b++) {\n            var name = _c[_b];\n\n            var newName = this._renameMaterialProperty(name);\n\n            params[newName] = vrmProps.floatProperties[name];\n          }\n        }\n\n        if (vrmProps.vectorProperties) {\n          var _loop_2 = function (name) {\n            var _a;\n\n            var newName = this_2._renameMaterialProperty(name);\n\n            var isTextureST = ['_MainTex', '_ShadeTexture', '_BumpMap', '_ReceiveShadowTexture', '_ShadingGradeTexture', '_SphereAdd', '_EmissionMap', '_OutlineWidthTexture'].some(function (textureName) {\n              return name === textureName;\n            });\n\n            if (isTextureST) {\n              newName += '_ST';\n            }\n\n            params[newName] = new ((_a = THREE.Vector4).bind.apply(_a, [void 0].concat(vrmProps.vectorProperties[name])))();\n          };\n\n          var this_2 = this;\n\n          for (var _d = 0, _e = Object.keys(vrmProps.vectorProperties); _d < _e.length; _d++) {\n            var name = _e[_d];\n\n            _loop_2(name);\n          }\n        }\n\n        if (vrmProps.keywordMap._ALPHATEST_ON && params.blendMode === MToonMaterial_1.MToonMaterialRenderMode.Opaque) {\n          params.blendMode = MToonMaterial_1.MToonMaterialRenderMode.Cutout;\n        }\n\n        params.skinning = originalMaterial.skinning || false;\n        params.morphTargets = originalMaterial.morphTargets || false;\n        params.morphNormals = originalMaterial.morphNormals || false;\n        return Promise.all(taskList).then(function () {\n          return params;\n        });\n      };\n\n      return VRMMaterialImporter;\n    }();\n\n    exports.VRMMaterialImporter = VRMMaterialImporter;\n    /***/\n  },\n\n  /***/\n  \"./src/vrm/material/VRMUnlitMaterial.ts\":\n  /*!**********************************************!*\\\r\n    !*** ./src/vrm/material/VRMUnlitMaterial.ts ***!\r\n    \\**********************************************/\n\n  /*! no static exports found */\n\n  /***/\n  function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    var __extends = this && this.__extends || function () {\n      var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (d, b) {\n          d.__proto__ = b;\n        } || function (d, b) {\n          for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n        };\n\n        return extendStatics(d, b);\n      };\n\n      return function (d, b) {\n        extendStatics(d, b);\n\n        function __() {\n          this.constructor = d;\n        }\n\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n      };\n    }();\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n\n    var THREE = __webpack_require__(\n    /*! three */\n    \"three\");\n\n    var unlit_vert_1 = __webpack_require__(\n    /*! ./shaders/unlit.vert */\n    \"./src/vrm/material/shaders/unlit.vert\");\n\n    var unlit_frag_1 = __webpack_require__(\n    /*! ./shaders/unlit.frag */\n    \"./src/vrm/material/shaders/unlit.frag\");\n\n    var VRMUnlitMaterialRenderType;\n\n    (function (VRMUnlitMaterialRenderType) {\n      VRMUnlitMaterialRenderType[VRMUnlitMaterialRenderType[\"Opaque\"] = 0] = \"Opaque\";\n      VRMUnlitMaterialRenderType[VRMUnlitMaterialRenderType[\"Cutout\"] = 1] = \"Cutout\";\n      VRMUnlitMaterialRenderType[VRMUnlitMaterialRenderType[\"Transparent\"] = 2] = \"Transparent\";\n      VRMUnlitMaterialRenderType[VRMUnlitMaterialRenderType[\"TransparentWithZWrite\"] = 3] = \"TransparentWithZWrite\";\n    })(VRMUnlitMaterialRenderType = exports.VRMUnlitMaterialRenderType || (exports.VRMUnlitMaterialRenderType = {}));\n\n    var VRMUnlitMaterial = function (_super) {\n      __extends(VRMUnlitMaterial, _super);\n\n      function VRMUnlitMaterial(parameters) {\n        var _this = _super.call(this) || this;\n\n        _this.isVRMUnlitMaterial = true;\n        _this.cutoff = 0.5;\n        _this.map = null;\n        _this.mainTex_ST = new THREE.Vector4(0.0, 0.0, 1.0, 1.0);\n        _this._renderType = VRMUnlitMaterialRenderType.Opaque;\n        _this.shouldApplyUniforms = true;\n\n        if (parameters === undefined) {\n          parameters = {};\n        }\n\n        parameters.fog = true;\n        parameters.clipping = true;\n        parameters.skinning = parameters.skinning || false;\n        parameters.morphTargets = parameters.morphTargets || false;\n        parameters.morphNormals = parameters.morphNormals || false;\n        parameters.uniforms = THREE.UniformsUtils.merge([THREE.UniformsLib.common, THREE.UniformsLib.fog, {\n          cutoff: {\n            value: 0.5\n          },\n          mainTex_ST: {\n            value: new THREE.Vector4(0.0, 0.0, 1.0, 1.0)\n          }\n        }]);\n\n        _this.setValues(parameters);\n\n        _this._updateShaderCode();\n\n        _this._applyUniforms();\n\n        return _this;\n      }\n\n      Object.defineProperty(VRMUnlitMaterial.prototype, \"mainTex\", {\n        get: function () {\n          return this.map;\n        },\n        set: function (t) {\n          this.map = t;\n        },\n        enumerable: true,\n        configurable: true\n      });\n      Object.defineProperty(VRMUnlitMaterial.prototype, \"renderType\", {\n        get: function () {\n          return this._renderType;\n        },\n        set: function (t) {\n          this._renderType = t;\n          this.depthWrite = this._renderType !== VRMUnlitMaterialRenderType.Transparent;\n          this.transparent = this._renderType === VRMUnlitMaterialRenderType.Transparent || this._renderType === VRMUnlitMaterialRenderType.TransparentWithZWrite;\n\n          this._updateShaderCode();\n        },\n        enumerable: true,\n        configurable: true\n      });\n\n      VRMUnlitMaterial.prototype.updateVRMMaterials = function (delta) {\n        this._applyUniforms();\n      };\n\n      VRMUnlitMaterial.prototype.copy = function (source) {\n        _super.prototype.copy.call(this, source);\n\n        this.cutoff = source.cutoff;\n        this.map = source.map;\n        this.mainTex_ST.copy(source.mainTex_ST);\n        this.renderType = source.renderType;\n        return this;\n      };\n\n      VRMUnlitMaterial.prototype._applyUniforms = function () {\n        if (!this.shouldApplyUniforms) {\n          return;\n        }\n\n        this.shouldApplyUniforms = false;\n        this.uniforms.cutoff.value = this.cutoff;\n        this.uniforms.map.value = this.map;\n        this.uniforms.mainTex_ST.value.copy(this.mainTex_ST);\n      };\n\n      VRMUnlitMaterial.prototype._updateShaderCode = function () {\n        this.defines = {\n          RENDERTYPE_OPAQUE: this._renderType === VRMUnlitMaterialRenderType.Opaque,\n          RENDERTYPE_CUTOUT: this._renderType === VRMUnlitMaterialRenderType.Cutout,\n          RENDERTYPE_TRANSPARENT: this._renderType === VRMUnlitMaterialRenderType.Transparent || this._renderType === VRMUnlitMaterialRenderType.TransparentWithZWrite\n        };\n        this.vertexShader = unlit_vert_1.default;\n        this.fragmentShader = unlit_frag_1.default;\n        this.needsUpdate = true;\n      };\n\n      return VRMUnlitMaterial;\n    }(THREE.ShaderMaterial);\n\n    exports.VRMUnlitMaterial = VRMUnlitMaterial;\n    /***/\n  },\n\n  /***/\n  \"./src/vrm/material/getTexelDecodingFunction.ts\":\n  /*!******************************************************!*\\\r\n    !*** ./src/vrm/material/getTexelDecodingFunction.ts ***!\r\n    \\******************************************************/\n\n  /*! no static exports found */\n\n  /***/\n  function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n\n    var THREE = __webpack_require__(\n    /*! three */\n    \"three\");\n\n    exports.getEncodingComponents = function (encoding) {\n      switch (encoding) {\n        case THREE.LinearEncoding:\n          return ['Linear', '( value )'];\n\n        case THREE.sRGBEncoding:\n          return ['sRGB', '( value )'];\n\n        case THREE.RGBEEncoding:\n          return ['RGBE', '( value )'];\n\n        case THREE.RGBM7Encoding:\n          return ['RGBM', '( value, 7.0 )'];\n\n        case THREE.RGBM16Encoding:\n          return ['RGBM', '( value, 16.0 )'];\n\n        case THREE.RGBDEncoding:\n          return ['RGBD', '( value, 256.0 )'];\n\n        case THREE.GammaEncoding:\n          return ['Gamma', '( value, float( GAMMA_FACTOR ) )'];\n\n        default:\n          throw new Error('unsupported encoding: ' + encoding);\n      }\n    };\n\n    exports.getTexelDecodingFunction = function (functionName, encoding) {\n      var components = exports.getEncodingComponents(encoding);\n      return 'vec4 ' + functionName + '( vec4 value ) { return ' + components[0] + 'ToLinear' + components[1] + '; }';\n    };\n    /***/\n\n  },\n\n  /***/\n  \"./src/vrm/material/index.ts\":\n  /*!***********************************!*\\\r\n    !*** ./src/vrm/material/index.ts ***!\r\n    \\***********************************/\n\n  /*! no static exports found */\n\n  /***/\n  function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    function __export(m) {\n      for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n    }\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n\n    __export(__webpack_require__(\n    /*! ./MToonMaterial */\n    \"./src/vrm/material/MToonMaterial.ts\"));\n\n    __export(__webpack_require__(\n    /*! ./VRMMaterialImporter */\n    \"./src/vrm/material/VRMMaterialImporter.ts\"));\n\n    __export(__webpack_require__(\n    /*! ./VRMUnlitMaterial */\n    \"./src/vrm/material/VRMUnlitMaterial.ts\"));\n    /***/\n\n  },\n\n  /***/\n  \"./src/vrm/material/shaders/mtoon.frag\":\n  /*!*********************************************!*\\\r\n    !*** ./src/vrm/material/shaders/mtoon.frag ***!\r\n    \\*********************************************/\n\n  /*! exports provided: default */\n\n  /***/\n  function (module, __webpack_exports__, __webpack_require__) {\n    \"use strict\";\n\n    __webpack_require__.r(__webpack_exports__);\n    /* harmony default export */\n\n\n    __webpack_exports__[\"default\"] = \"// #define PHONG\\n\\n#ifdef BLENDMODE_CUTOUT\\n  uniform float cutoff;\\n#endif\\n\\nuniform vec3 color;\\nuniform float colorAlpha;\\nuniform vec3 shadeColor;\\n#ifdef USE_SHADETEXTURE\\n  uniform sampler2D shadeTexture;\\n#endif\\n\\nuniform float receiveShadowRate;\\n#ifdef USE_RECEIVESHADOWTEXTURE\\n  uniform sampler2D receiveShadowTexture;\\n#endif\\n\\nuniform float shadingGradeRate;\\n#ifdef USE_SHADINGGRADETEXTURE\\n  uniform sampler2D shadingGradeTexture;\\n#endif\\n\\nuniform float shadeShift;\\nuniform float shadeToony;\\nuniform float lightColorAttenuation;\\nuniform float indirectLightIntensity;\\n\\n#ifdef USE_RIMTEXTURE\\n  uniform sampler2D rimTexture;\\n#endif\\nuniform vec3 rimColor;\\nuniform float rimLightingMix;\\nuniform float rimFresnelPower;\\nuniform float rimLift;\\n\\n#ifdef USE_SPHEREADD\\n  uniform sampler2D sphereAdd;\\n#endif\\n\\nuniform vec3 emissionColor;\\n\\nuniform vec3 outlineColor;\\nuniform float outlineLightingMix;\\n\\n#ifdef USE_UVANIMMASKTEXTURE\\n  uniform sampler2D uvAnimMaskTexture;\\n#endif\\n\\nuniform float uvAnimOffsetX;\\nuniform float uvAnimOffsetY;\\nuniform float uvAnimTheta;\\n\\n#include <common>\\n#include <packing>\\n#include <dithering_pars_fragment>\\n#include <color_pars_fragment>\\n\\n// #include <uv_pars_fragment>\\n#if defined( USE_MAP ) || defined( USE_SHADETEXTURE ) || defined( USE_NORMALMAP ) || defined( USE_RECEIVESHADOWTEXTURE ) || defined( USE_SHADINGGRADETEXTURE ) || defined( USE_RIMTEXTURE ) || defined( USE_EMISSIVEMAP ) || defined( USE_OUTLINEWIDTHTEXTURE ) || defined( USE_UVANIMMASKTEXTURE )\\n  varying vec2 vUv;\\n#endif\\n\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n// #include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n// #include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n// #include <envmap_pars_fragment>\\n// #include <gradientmap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <bsdfs>\\n#include <lights_pars_begin>\\n\\n// #include <lights_phong_pars_fragment>\\nvarying vec3 vViewPosition;\\n\\n#ifndef FLAT_SHADED\\n  varying vec3 vNormal;\\n#endif\\n\\n#define Material_LightProbeLOD( material ) (0)\\n\\n#include <shadowmap_pars_fragment>\\n// #include <bumpmap_pars_fragment>\\n\\n// #include <normalmap_pars_fragment>\\n#ifdef USE_NORMALMAP\\n  uniform sampler2D normalMap;\\n  uniform float bumpScale;\\n\\n  // this number is very random, this is still a 対処療法\\n  #define UV_DERIVATIVE_EPSILON 1E-6\\n\\n  // Per-Pixel Tangent Space Normal Mapping\\n  // http://hacksoflife.blogspot.ch/2009/11/per-pixel-tangent-space-normal-mapping.html\\n  vec3 perturbNormal2Arb( vec2 uv, vec3 eye_pos, vec3 surf_norm ) {\\n    // Workaround for Adreno 3XX dFd*( vec3 ) bug. See #9988\\n    vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\\n    vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\\n    vec2 st0 = dFdx( uv.st );\\n    vec2 st1 = dFdy( uv.st );\\n\\n    float scale = sign( st1.t * st0.s - st0.t * st1.s ); // we do not care about the magnitude\\n    vec3 S = ( q0 * st1.t - q1 * st0.t ) * scale;\\n    vec3 T = ( - q0 * st1.s + q1 * st0.s ) * scale;\\n\\n    // Workaround for the issue that happens when delta of uv = 0.0\\n    if ( length( S ) == 0.0 || length( T ) == 0.0 ) {\\n      return surf_norm;\\n    }\\n\\n    S = normalize( S );\\n    T = normalize( T );\\n    vec3 N = normalize( surf_norm );\\n\\n    vec3 mapN = texture2D( normalMap, uv ).xyz * 2.0 - 1.0;\\n\\n    mapN.xy *= bumpScale;\\n\\n    #ifdef DOUBLE_SIDED\\n      // Workaround for Adreno GPUs gl_FrontFacing bug. See #15850 and #10331\\n      // http://hacksoflife.blogspot.com/2009/11/per-pixel-tangent-space-normal-mapping.html?showComment=1522254677437#c5087545147696715943\\n      vec3 NfromST = cross( S, T );\\n      if( dot( NfromST, N ) > 0.0 ) {\\n        S *= -1.0;\\n        T *= -1.0;\\n      }\\n    #else\\n      mapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\\n    #endif\\n\\n    mat3 tsn = mat3( S, T, N );\\n\\n    return normalize( tsn * mapN );\\n  }\\n#endif\\n\\n// #include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\n\\n// == lighting stuff ===========================================================\\nfloat getLightIntensity(\\n  const in IncidentLight directLight,\\n  const in GeometricContext geometry,\\n  const in float shadow,\\n  const in float shadingGrade\\n) {\\n  float lightIntensity = dot( geometry.normal, directLight.direction );\\n  lightIntensity = 0.5 + 0.5 * lightIntensity;\\n  lightIntensity = lightIntensity * shadow;\\n  lightIntensity = lightIntensity * shadingGrade;\\n  lightIntensity = lightIntensity * 2.0 - 1.0;\\n  return smoothstep( shadeShift, shadeShift + ( 1.0 - shadeToony ), lightIntensity );\\n}\\n\\nvec3 getLighting( const in vec3 lightColor ) {\\n  vec3 lighting = lightColor;\\n  lighting = mix(\\n    lighting,\\n    vec3( max( 0.001, max( lighting.x, max( lighting.y, lighting.z ) ) ) ),\\n    lightColorAttenuation\\n  );\\n\\n  #ifndef PHYSICALLY_CORRECT_LIGHTS\\n    lighting *= PI;\\n  #endif\\n\\n  return lighting;\\n}\\n\\nvec3 getDiffuse(\\n  const in vec3 lit,\\n  const in vec3 shade,\\n  const in float lightIntensity,\\n  const in vec3 lighting\\n) {\\n  #ifdef DEBUG_LITSHADERATE\\n    return vec3( BRDF_Diffuse_Lambert( lightIntensity * lighting ) );\\n  #endif\\n\\n  return lighting * BRDF_Diffuse_Lambert( mix( shade, lit, lightIntensity ) );\\n}\\n\\nvec3 calcDirectDiffuse(\\n  const in vec2 uv,\\n  const in vec3 lit,\\n  const in vec3 shade,\\n  in GeometricContext geometry,\\n  inout ReflectedLight reflectedLight\\n) {\\n  IncidentLight directLight;\\n  vec3 lightingSum = vec3( 0.0 );\\n\\n  float shadingGrade = 1.0;\\n  #ifdef USE_SHADINGGRADETEXTURE\\n    shadingGrade = 1.0 - shadingGradeRate * ( 1.0 - texture2D( shadingGradeTexture, uv ).r );\\n  #endif\\n\\n  float receiveShadow = receiveShadowRate;\\n  #ifdef USE_RECEIVESHADOWTEXTURE\\n    receiveShadow *= texture2D( receiveShadowTexture, uv ).a;\\n  #endif\\n\\n  #if ( NUM_POINT_LIGHTS > 0 )\\n    PointLight pointLight;\\n\\n    #pragma unroll_loop\\n    for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n      pointLight = pointLights[ i ];\\n      getPointDirectLightIrradiance( pointLight, geometry, directLight );\\n\\n      float atten = 1.0;\\n      #ifdef USE_SHADOWMAP\\n        atten = all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\\n      #endif\\n\\n      float shadow = 1.0 - receiveShadow * ( 1.0 - ( 0.5 + 0.5 * atten ) );\\n      float lightIntensity = getLightIntensity( directLight, geometry, shadow, shadingGrade );\\n      vec3 lighting = getLighting( directLight.color );\\n      reflectedLight.directDiffuse += getDiffuse( lit, shade, lightIntensity, lighting );\\n      lightingSum += lighting;\\n    }\\n  #endif\\n\\n  #if ( NUM_SPOT_LIGHTS > 0 )\\n    SpotLight spotLight;\\n\\n    #pragma unroll_loop\\n    for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n      spotLight = spotLights[ i ];\\n      getSpotDirectLightIrradiance( spotLight, geometry, directLight );\\n\\n      float atten = 1.0;\\n      #ifdef USE_SHADOWMAP\\n        atten = all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\\n      #endif\\n\\n      float shadow = 1.0 - receiveShadow * ( 1.0 - ( 0.5 + 0.5 * atten ) );\\n      float lightIntensity = getLightIntensity( directLight, geometry, shadow, shadingGrade );\\n      vec3 lighting = getLighting( directLight.color );\\n      reflectedLight.directDiffuse += getDiffuse( lit, shade, lightIntensity, lighting );\\n      lightingSum += lighting;\\n    }\\n  #endif\\n\\n  #if ( NUM_DIR_LIGHTS > 0 )\\n    DirectionalLight directionalLight;\\n\\n    #pragma unroll_loop\\n    for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n      directionalLight = directionalLights[ i ];\\n      getDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\\n\\n      float atten = 1.0;\\n      #ifdef USE_SHADOWMAP\\n        atten = all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\\n      #endif\\n\\n      float shadow = 1.0 - receiveShadow * ( 1.0 - ( 0.5 + 0.5 * atten ) );\\n      float lightIntensity = getLightIntensity( directLight, geometry, shadow, shadingGrade );\\n      vec3 lighting = getLighting( directLight.color );\\n      reflectedLight.directDiffuse += getDiffuse( lit, shade, lightIntensity, lighting );\\n      lightingSum += lighting;\\n    }\\n  #endif\\n\\n  return lightingSum;\\n}\\n\\n// == post correction ==========================================================\\nvoid postCorrection() {\\n  #include <tonemapping_fragment>\\n  #include <encodings_fragment>\\n  #include <fog_fragment>\\n  #include <premultiplied_alpha_fragment>\\n  #include <dithering_fragment>\\n}\\n\\n// == main procedure ===========================================================\\nvoid main() {\\n  #include <clipping_planes_fragment>\\n\\n  vec2 uv = vec2(0.5, 0.5);\\n\\n  #if defined( USE_MAP ) || defined( USE_SHADETEXTURE ) || defined( USE_NORMALMAP ) || defined( USE_RECEIVESHADOWTEXTURE ) || defined( USE_SHADINGGRADETEXTURE ) || defined( USE_RIMTEXTURE ) || defined( USE_EMISSIVEMAP ) || defined( USE_OUTLINEWIDTHTEXTURE ) || defined( USE_UVANIMMASKTEXTURE )\\n    uv = vUv;\\n\\n    float uvAnimMask = 1.0;\\n    #ifdef USE_UVANIMMASKTEXTURE\\n      uvAnimMask = texture2D( uvAnimMaskTexture, uv ).x;\\n    #endif\\n\\n    uv = uv + vec2( uvAnimOffsetX, uvAnimOffsetY ) * uvAnimMask;\\n    float uvRotCos = cos( uvAnimTheta * uvAnimMask );\\n    float uvRotSin = sin( uvAnimTheta * uvAnimMask );\\n    uv = mat2( uvRotCos, uvRotSin, -uvRotSin, uvRotCos ) * ( uv - 0.5 ) + 0.5;\\n  #endif\\n\\n  #ifdef DEBUG_UV\\n    gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\\n    #if defined( USE_MAP ) || defined( USE_SHADETEXTURE ) || defined( USE_NORMALMAP ) || defined( USE_RECEIVESHADOWTEXTURE ) || defined( USE_SHADINGGRADETEXTURE ) || defined( USE_RIMTEXTURE ) || defined( USE_EMISSIVEMAP ) || defined( USE_OUTLINEWIDTHTEXTURE ) || defined( USE_UVANIMMASKTEXTURE )\\n      gl_FragColor = vec4( uv, 0.0, 1.0 );\\n    #endif\\n    return;\\n  #endif\\n\\n  vec4 diffuseColor = vec4( color, colorAlpha );\\n  ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n  vec3 totalEmissiveRadiance = emissionColor;\\n\\n  #include <logdepthbuf_fragment>\\n\\n  // #include <map_fragment>\\n  #ifdef USE_MAP\\n    diffuseColor *= mapTexelToLinear( texture2D( map, uv ) );\\n  #endif\\n\\n  #include <color_fragment>\\n  // #include <alphamap_fragment>\\n\\n  // -- MToon: alpha -----------------------------------------------------------\\n  // #include <alphatest_fragment>\\n  #ifdef BLENDMODE_CUTOUT\\n    if ( diffuseColor.a <= cutoff ) { discard; }\\n    diffuseColor.a = 1.0;\\n  #endif\\n\\n  #ifdef BLENDMODE_OPAQUE\\n    diffuseColor.a = 1.0;\\n  #endif\\n\\n  #if defined( OUTLINE ) && defined( OUTLINE_COLOR_FIXED ) // omitting DebugMode\\n    gl_FragColor = vec4( outlineColor, diffuseColor.a );\\n    postCorrection();\\n    return;\\n  #endif\\n\\n  // #include <specularmap_fragment>\\n  #include <normal_fragment_begin>\\n\\n  #ifdef OUTLINE\\n    normal *= -1.0;\\n  #endif\\n\\n  // #include <normal_fragment_maps>\\n  #ifdef USE_NORMALMAP\\n    normal = perturbNormal2Arb( uv, -vViewPosition, normal );\\n  #endif\\n\\n  // #include <emissivemap_fragment>\\n  #ifdef USE_EMISSIVEMAP\\n    totalEmissiveRadiance *= emissiveMapTexelToLinear( texture2D( emissiveMap, uv ) ).rgb;\\n  #endif\\n\\n  #ifdef DEBUG_NORMAL\\n    gl_FragColor = vec4( 0.5 + 0.5 * normal, 1.0 );\\n    return;\\n  #endif\\n\\n  // -- MToon: lighting --------------------------------------------------------\\n  // accumulation\\n  // #include <lights_phong_fragment>\\n  // #include <lights_fragment_begin>\\n  vec3 lit = diffuseColor.rgb;\\n  vec3 shade = shadeColor;\\n  #ifdef USE_SHADETEXTURE\\n    shade *= shadeTextureTexelToLinear( texture2D( shadeTexture, uv ) ).rgb;\\n  #endif\\n\\n  GeometricContext geometry;\\n\\n  geometry.position = - vViewPosition;\\n  geometry.normal = normal;\\n  geometry.viewDir = normalize( vViewPosition );\\n\\n  vec3 lighting = calcDirectDiffuse( uv, diffuseColor.rgb, shade, geometry, reflectedLight );\\n\\n  vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\\n  #if ( NUM_HEMI_LIGHTS > 0 )\\n    #pragma unroll_loop\\n    for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\\n      irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\\n    }\\n  #endif\\n\\n  // #include <lights_fragment_maps>\\n  #ifdef USE_LIGHTMAP\\n    vec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).rgb * lightMapIntensity;\\n    #ifndef PHYSICALLY_CORRECT_LIGHTS\\n      lightMapIrradiance *= PI; // factor of PI should not be present; included here to prevent breakage\\n    #endif\\n    irradiance += lightMapIrradiance;\\n  #endif\\n\\n  // #include <lights_fragment_end>\\n  reflectedLight.indirectDiffuse += indirectLightIntensity * irradiance * BRDF_Diffuse_Lambert( lit );\\n\\n  // modulation\\n  #include <aomap_fragment>\\n\\n  vec3 col = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\\n\\n  #if defined( OUTLINE ) && defined( OUTLINE_COLOR_MIXED ) // omitting DebugMode\\n    gl_FragColor = vec4(\\n      outlineColor.rgb * mix( vec3( 1.0 ), col, outlineLightingMix ),\\n      diffuseColor.a\\n    );\\n    postCorrection();\\n    return;\\n  #endif\\n\\n  // -- MToon: parametric rim lighting -----------------------------------------\\n  vec3 viewDir = normalize( vViewPosition );\\n  vec3 rimMix = mix(vec3(1.0), lighting + indirectLightIntensity * irradiance, rimLightingMix);\\n  vec3 rim = rimColor * pow( saturate( 1.0 - dot( viewDir, normal ) + rimLift ), rimFresnelPower );\\n  #ifdef USE_RIMTEXTURE\\n    rim *= texture2D( rimTexture, uv ).rgb;\\n  #endif\\n  col += rim;\\n\\n  // -- MToon: additive matcap -------------------------------------------------\\n  #ifdef USE_SPHEREADD\\n    {\\n      vec3 x = normalize( vec3( viewDir.z, 0.0, -viewDir.x ) );\\n      vec3 y = cross( viewDir, x ); // guaranteed to be normalized\\n      vec2 sphereUv = 0.5 + 0.5 * vec2( dot( x, normal ), -dot( y, normal ) );\\n      vec3 matcap = sphereAddTexelToLinear( texture2D( sphereAdd, sphereUv ) ).xyz;\\n      col += matcap;\\n    }\\n  #endif\\n\\n  // -- MToon: Emission --------------------------------------------------------\\n  col += totalEmissiveRadiance;\\n\\n  // #include <envmap_fragment>\\n\\n  // -- Almost done! -----------------------------------------------------------\\n  gl_FragColor = vec4( col, diffuseColor.a );\\n  postCorrection();\\n}\";\n    /***/\n  },\n\n  /***/\n  \"./src/vrm/material/shaders/mtoon.vert\":\n  /*!*********************************************!*\\\r\n    !*** ./src/vrm/material/shaders/mtoon.vert ***!\r\n    \\*********************************************/\n\n  /*! exports provided: default */\n\n  /***/\n  function (module, __webpack_exports__, __webpack_require__) {\n    \"use strict\";\n\n    __webpack_require__.r(__webpack_exports__);\n    /* harmony default export */\n\n\n    __webpack_exports__[\"default\"] = \"// #define PHONG\\n\\nvarying vec3 vViewPosition;\\n\\n#ifndef FLAT_SHADED\\n  varying vec3 vNormal;\\n#endif\\n\\n#include <common>\\n\\n// #include <uv_pars_vertex>\\n#if defined( USE_MAP ) || defined( USE_SHADETEXTURE ) || defined( USE_NORMALMAP ) || defined( USE_RECEIVESHADOWTEXTURE ) || defined( USE_SHADINGGRADETEXTURE ) || defined( USE_RIMTEXTURE ) || defined( USE_EMISSIVEMAP ) || defined( USE_OUTLINEWIDTHTEXTURE ) || defined( USE_UVANIMMASKTEXTURE )\\n  varying vec2 vUv;\\n  uniform vec4 mainTex_ST;\\n#endif\\n\\n#include <uv2_pars_vertex>\\n// #include <displacementmap_pars_vertex>\\n// #include <envmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\n\\n#ifdef USE_OUTLINEWIDTHTEXTURE\\n  uniform sampler2D outlineWidthTexture;\\n#endif\\n\\nuniform float outlineWidth;\\nuniform float outlineScaledMaxDistance;\\n\\nvoid main() {\\n\\n  // #include <uv_vertex>\\n  #if defined( USE_MAP ) || defined( USE_SHADETEXTURE ) || defined( USE_NORMALMAP ) || defined( USE_RECEIVESHADOWTEXTURE ) || defined( USE_SHADINGGRADETEXTURE ) || defined( USE_RIMTEXTURE ) || defined( USE_EMISSIVEMAP ) || defined( USE_OUTLINEWIDTHTEXTURE ) || defined( USE_UVANIMMASKTEXTURE )\\n    vUv = vec2( mainTex_ST.p * uv.x + mainTex_ST.s, mainTex_ST.q * uv.y + mainTex_ST.t );\\n  #endif\\n\\n  #include <uv2_vertex>\\n  #include <color_vertex>\\n\\n  #include <beginnormal_vertex>\\n  #include <morphnormal_vertex>\\n  #include <skinbase_vertex>\\n  #include <skinnormal_vertex>\\n  #include <defaultnormal_vertex>\\n\\n  #ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED\\n    vNormal = normalize( transformedNormal );\\n  #endif\\n\\n  #include <begin_vertex>\\n\\n  #include <morphtarget_vertex>\\n  #include <skinning_vertex>\\n  // #include <displacementmap_vertex>\\n  #include <project_vertex>\\n  #include <logdepthbuf_vertex>\\n  #include <clipping_planes_vertex>\\n\\n  vViewPosition = - mvPosition.xyz;\\n\\n  float outlineTex = 1.0;\\n\\n  #ifdef OUTLINE\\n    #ifdef USE_OUTLINEWIDTHTEXTURE\\n      outlineTex = texture2D( outlineWidthTexture, vUv ).r;\\n    #endif\\n\\n    #ifdef OUTLINE_WIDTH_WORLD\\n      vec3 outlineOffset = 0.01 * outlineWidth * outlineTex * normalize( objectNormal );\\n      gl_Position += projectionMatrix * modelViewMatrix * vec4( outlineOffset, 0.0 );\\n    #endif\\n\\n    #ifdef OUTLINE_WIDTH_SCREEN\\n      vec3 clipNormal = ( projectionMatrix * modelViewMatrix * vec4( normalize( objectNormal ), 0.0 ) ).xyz;\\n      vec2 projectedNormal = normalize( clipNormal.xy );\\n      projectedNormal *= min( gl_Position.w, outlineScaledMaxDistance );\\n      projectedNormal.x *= projectionMatrix[ 0 ].x / projectionMatrix[ 1 ].y;\\n      gl_Position.xy += 0.01 * outlineWidth * outlineTex * projectedNormal.xy;\\n    #endif\\n\\n    gl_Position.z += 1E-6 * gl_Position.w; // anti-artifact magic\\n  #endif\\n\\n  #include <worldpos_vertex>\\n  // #include <envmap_vertex>\\n  #include <shadowmap_vertex>\\n  #include <fog_vertex>\\n\\n}\";\n    /***/\n  },\n\n  /***/\n  \"./src/vrm/material/shaders/unlit.frag\":\n  /*!*********************************************!*\\\r\n    !*** ./src/vrm/material/shaders/unlit.frag ***!\r\n    \\*********************************************/\n\n  /*! exports provided: default */\n\n  /***/\n  function (module, __webpack_exports__, __webpack_require__) {\n    \"use strict\";\n\n    __webpack_require__.r(__webpack_exports__);\n    /* harmony default export */\n\n\n    __webpack_exports__[\"default\"] = \"#ifdef RENDERTYPE_CUTOUT\\n  uniform float cutoff;\\n#endif\\n\\n#include <common>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n// #include <alphamap_pars_fragment>\\n// #include <aomap_pars_fragment>\\n// #include <lightmap_pars_fragment>\\n// #include <envmap_pars_fragment>\\n#include <fog_pars_fragment>\\n// #include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\n\\n// == main procedure ===========================================================\\nvoid main() {\\n  #include <clipping_planes_fragment>\\n\\n  vec4 diffuseColor = vec4( 1.0 );\\n\\n  #include <logdepthbuf_fragment>\\n\\n  // #include <map_fragment>\\n  #ifdef USE_MAP\\n    diffuseColor *= mapTexelToLinear( texture2D( map, vUv ) );\\n  #endif\\n\\n  #include <color_fragment>\\n  // #include <alphamap_fragment>\\n\\n  // MToon: alpha\\n  // #include <alphatest_fragment>\\n  #ifdef RENDERTYPE_CUTOUT\\n    if ( diffuseColor.a <= cutoff ) { discard; }\\n    diffuseColor.a = 1.0;\\n  #endif\\n\\n  #ifdef RENDERTYPE_OPAQUE\\n    diffuseColor.a = 1.0;\\n  #endif\\n\\n  // #include <specularmap_fragment>\\n\\n  ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\n  // accumulation (baked indirect lighting only)\\n  #ifdef USE_LIGHTMAP\\n    reflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\\n  #else\\n    reflectedLight.indirectDiffuse += vec3( 1.0 );\\n  #endif\\n\\n  // modulation\\n  // #include <aomap_fragment>\\n\\n  reflectedLight.indirectDiffuse *= diffuseColor.rgb;\\n  vec3 outgoingLight = reflectedLight.indirectDiffuse;\\n\\n  // #include <envmap_fragment>\\n\\n  gl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\n  #include <premultiplied_alpha_fragment>\\n  #include <tonemapping_fragment>\\n  #include <encodings_fragment>\\n  #include <fog_fragment>\\n}\";\n    /***/\n  },\n\n  /***/\n  \"./src/vrm/material/shaders/unlit.vert\":\n  /*!*********************************************!*\\\r\n    !*** ./src/vrm/material/shaders/unlit.vert ***!\r\n    \\*********************************************/\n\n  /*! exports provided: default */\n\n  /***/\n  function (module, __webpack_exports__, __webpack_require__) {\n    \"use strict\";\n\n    __webpack_require__.r(__webpack_exports__);\n    /* harmony default export */\n\n\n    __webpack_exports__[\"default\"] = \"#include <common>\\n\\n// #include <uv_pars_vertex>\\n#ifdef USE_MAP\\n  varying vec2 vUv;\\n  uniform vec4 mainTex_ST;\\n#endif\\n\\n#include <uv2_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\n\\nvoid main() {\\n\\n  // #include <uv_vertex>\\n  #ifdef USE_MAP\\n    vUv = vec2( mainTex_ST.p * uv.x + mainTex_ST.s, mainTex_ST.q * uv.y + mainTex_ST.t );\\n  #endif\\n\\n  #include <uv2_vertex>\\n  #include <color_vertex>\\n  #include <skinbase_vertex>\\n\\n  #ifdef USE_ENVMAP\\n\\n  #include <beginnormal_vertex>\\n  #include <morphnormal_vertex>\\n  #include <skinnormal_vertex>\\n  #include <defaultnormal_vertex>\\n\\n  #endif\\n\\n  #include <begin_vertex>\\n  #include <morphtarget_vertex>\\n  #include <skinning_vertex>\\n  #include <project_vertex>\\n  #include <logdepthbuf_vertex>\\n\\n  #include <worldpos_vertex>\\n  #include <clipping_planes_vertex>\\n  #include <envmap_vertex>\\n  #include <fog_vertex>\\n\\n}\";\n    /***/\n  },\n\n  /***/\n  \"./src/vrm/reduceBones.ts\":\n  /*!********************************!*\\\r\n    !*** ./src/vrm/reduceBones.ts ***!\r\n    \\********************************/\n\n  /*! no static exports found */\n\n  /***/\n  function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n\n    var THREE = __webpack_require__(\n    /*! three */\n    \"three\");\n\n    function reduceBones(root) {\n      root.traverse(function (obj) {\n        if (obj.type !== 'SkinnedMesh') {\n          return;\n        }\n\n        var mesh = obj;\n        var geometry = mesh.geometry.clone();\n        mesh.geometry = geometry;\n        var attribute = geometry.getAttribute('skinIndex');\n        var bones = [];\n        var boneInverses = [];\n        var boneIndexMap = {};\n        var array = attribute.array.map(function (index) {\n          if (boneIndexMap[index] === undefined) {\n            boneIndexMap[index] = bones.length;\n            bones.push(mesh.skeleton.bones[index]);\n            boneInverses.push(mesh.skeleton.boneInverses[index]);\n          }\n\n          return boneIndexMap[index];\n        });\n        geometry.removeAttribute('skinIndex');\n        geometry.addAttribute('skinIndex', new THREE.BufferAttribute(array, 4, false));\n        mesh.bind(new THREE.Skeleton(bones, boneInverses), new THREE.Matrix4());\n      });\n    }\n\n    exports.reduceBones = reduceBones;\n    /***/\n  },\n\n  /***/\n  \"./src/vrm/springbone/VRMSpringBone.ts\":\n  /*!*********************************************!*\\\r\n    !*** ./src/vrm/springbone/VRMSpringBone.ts ***!\r\n    \\*********************************************/\n\n  /*! no static exports found */\n\n  /***/\n  function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n\n    var THREE = __webpack_require__(\n    /*! three */\n    \"three\");\n\n    var math_1 = __webpack_require__(\n    /*! ../utils/math */\n    \"./src/vrm/utils/math.ts\");\n\n    exports.GIZMO_RENDER_ORDER = 10000;\n    var IDENTITY_MATRIX4 = Object.freeze(new THREE.Matrix4());\n    var IDENTITY_QUATERNION = Object.freeze(new THREE.Quaternion());\n\n    var _v3A = new THREE.Vector3();\n\n    var _v3B = new THREE.Vector3();\n\n    var _v3C = new THREE.Vector3();\n\n    var _quatA = new THREE.Quaternion();\n\n    var _matA = new THREE.Matrix4();\n\n    var _matB = new THREE.Matrix4();\n\n    var VRMSpringBone = function () {\n      function VRMSpringBone(bone, radius, stiffiness, gravityDir, gravityPower, dragForce, colliders) {\n        var _this = this;\n\n        if (colliders === void 0) {\n          colliders = [];\n        }\n\n        this.bone = bone;\n        this.bone.matrixAutoUpdate = false;\n        this.radius = radius;\n        this.stiffnessForce = stiffiness;\n        this.gravityDir = gravityDir;\n        this.gravityPower = gravityPower;\n        this.dragForce = dragForce;\n        this.colliders = colliders;\n        this._worldPosition = new THREE.Vector3().setFromMatrixPosition(this.bone.matrixWorld);\n        this._parentWorldRotation = new THREE.Quaternion();\n        this._initialLocalMatrix = this.bone.matrix.clone();\n        this._initialLocalRotation = this.bone.quaternion.clone();\n\n        this._initialLocalChildPosition = function () {\n          if (_this.bone.children.length === 0) {\n            return _this.bone.position.clone().normalize().multiplyScalar(0.07);\n          } else {\n            var firstChild = _this.bone.children[0];\n            return firstChild.position.clone();\n          }\n        }();\n\n        this._currentTail = this.bone.localToWorld(this._initialLocalChildPosition.clone());\n        this._prevTail = this._currentTail.clone();\n        this._nextTail = this._currentTail.clone();\n        this._boneAxis = this._initialLocalChildPosition.clone().normalize();\n        this._worldBoneLength = this.bone.localToWorld(_v3A.copy(this._initialLocalChildPosition)).sub(this._worldPosition).length();\n      }\n\n      VRMSpringBone.prototype.reset = function () {\n        this.bone.matrix.copy(this._initialLocalMatrix);\n        this.bone.localToWorld(this._currentTail.copy(this._initialLocalChildPosition));\n\n        this._prevTail.copy(this._currentTail);\n\n        this._nextTail.copy(this._currentTail);\n\n        this.bone.updateMatrix();\n        this.bone.matrixWorld.multiplyMatrices(this._getParentMatrixWorld(), this.bone.matrix);\n\n        this._worldPosition.setFromMatrixPosition(this.bone.matrixWorld);\n      };\n\n      VRMSpringBone.prototype.update = function (delta) {\n        if (delta <= 0) return;\n        this.bone.matrixWorld.multiplyMatrices(this._getParentMatrixWorld(), this.bone.matrix);\n\n        if (this.bone.parent) {\n          math_1.getWorldQuaternionLite(this.bone.parent, this._parentWorldRotation);\n        } else {\n          this._parentWorldRotation.copy(IDENTITY_QUATERNION);\n        }\n\n        this._worldPosition.setFromMatrixPosition(this.bone.matrixWorld);\n\n        var stiffness = this.stiffnessForce * delta;\n\n        var external = _v3B.copy(this.gravityDir).multiplyScalar(this.gravityPower * delta);\n\n        this._nextTail.copy(this._currentTail).add(_v3A.copy(this._currentTail).sub(this._prevTail).multiplyScalar(1 - this.dragForce)).add(_v3A.copy(this._boneAxis).applyMatrix4(this._initialLocalMatrix).applyMatrix4(this._getParentMatrixWorld()).sub(this._worldPosition).normalize().multiplyScalar(stiffness)).add(external);\n\n        this._nextTail.sub(this._worldPosition).normalize().multiplyScalar(this._worldBoneLength).add(this._worldPosition);\n\n        this._collision(this._nextTail);\n\n        this._prevTail.copy(this._currentTail);\n\n        this._currentTail.copy(this._nextTail);\n\n        var initialWorldMatrixInv = _matA.getInverse(_matB.copy(this._getParentMatrixWorld()).multiply(this._initialLocalMatrix));\n\n        var applyRotation = _quatA.setFromUnitVectors(this._boneAxis, _v3A.copy(this._nextTail).applyMatrix4(initialWorldMatrixInv).normalize());\n\n        this.bone.quaternion.copy(this._initialLocalRotation).multiply(applyRotation);\n        this.bone.updateMatrix();\n        this.bone.matrixWorld.multiplyMatrices(this._getParentMatrixWorld(), this.bone.matrix);\n      };\n\n      VRMSpringBone.prototype._collision = function (tail) {\n        var _this = this;\n\n        this.colliders.forEach(function (collider) {\n          var colliderWorldPosition = _v3A.setFromMatrixPosition(collider.matrixWorld);\n\n          var colliderRadius = collider.geometry.boundingSphere.radius;\n          var r = _this.radius + colliderRadius;\n\n          if (tail.distanceToSquared(colliderWorldPosition) <= r * r) {\n            var normal = _v3B.subVectors(tail, colliderWorldPosition).normalize();\n\n            var posFromCollider = _v3C.addVectors(colliderWorldPosition, normal.multiplyScalar(r));\n\n            tail.copy(posFromCollider.sub(_this._worldPosition).normalize().multiplyScalar(_this._worldBoneLength).add(_this._worldPosition));\n          }\n        });\n      };\n\n      VRMSpringBone.prototype._getParentMatrixWorld = function () {\n        return this.bone.parent ? this.bone.parent.matrixWorld : IDENTITY_MATRIX4;\n      };\n\n      return VRMSpringBone;\n    }();\n\n    exports.VRMSpringBone = VRMSpringBone;\n    /***/\n  },\n\n  /***/\n  \"./src/vrm/springbone/VRMSpringBoneColliderGroup.ts\":\n  /*!**********************************************************!*\\\r\n    !*** ./src/vrm/springbone/VRMSpringBoneColliderGroup.ts ***!\r\n    \\**********************************************************/\n\n  /*! no static exports found */\n\n  /***/\n  function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n    /***/\n  },\n\n  /***/\n  \"./src/vrm/springbone/VRMSpringBoneImporter.ts\":\n  /*!*****************************************************!*\\\r\n    !*** ./src/vrm/springbone/VRMSpringBoneImporter.ts ***!\r\n    \\*****************************************************/\n\n  /*! no static exports found */\n\n  /***/\n  function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n      return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) {\n          try {\n            step(generator.next(value));\n          } catch (e) {\n            reject(e);\n          }\n        }\n\n        function rejected(value) {\n          try {\n            step(generator[\"throw\"](value));\n          } catch (e) {\n            reject(e);\n          }\n        }\n\n        function step(result) {\n          result.done ? resolve(result.value) : new P(function (resolve) {\n            resolve(result.value);\n          }).then(fulfilled, rejected);\n        }\n\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n      });\n    };\n\n    var __generator = this && this.__generator || function (thisArg, body) {\n      var _ = {\n        label: 0,\n        sent: function () {\n          if (t[0] & 1) throw t[1];\n          return t[1];\n        },\n        trys: [],\n        ops: []\n      },\n          f,\n          y,\n          t,\n          g;\n      return g = {\n        next: verb(0),\n        \"throw\": verb(1),\n        \"return\": verb(2)\n      }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n        return this;\n      }), g;\n\n      function verb(n) {\n        return function (v) {\n          return step([n, v]);\n        };\n      }\n\n      function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n\n        while (_) try {\n          if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n          if (y = 0, t) op = [op[0] & 2, t.value];\n\n          switch (op[0]) {\n            case 0:\n            case 1:\n              t = op;\n              break;\n\n            case 4:\n              _.label++;\n              return {\n                value: op[1],\n                done: false\n              };\n\n            case 5:\n              _.label++;\n              y = op[1];\n              op = [0];\n              continue;\n\n            case 7:\n              op = _.ops.pop();\n\n              _.trys.pop();\n\n              continue;\n\n            default:\n              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n                _ = 0;\n                continue;\n              }\n\n              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n                _.label = op[1];\n                break;\n              }\n\n              if (op[0] === 6 && _.label < t[1]) {\n                _.label = t[1];\n                t = op;\n                break;\n              }\n\n              if (t && _.label < t[2]) {\n                _.label = t[2];\n\n                _.ops.push(op);\n\n                break;\n              }\n\n              if (t[2]) _.ops.pop();\n\n              _.trys.pop();\n\n              continue;\n          }\n\n          op = body.call(thisArg, _);\n        } catch (e) {\n          op = [6, e];\n          y = 0;\n        } finally {\n          f = t = 0;\n        }\n\n        if (op[0] & 5) throw op[1];\n        return {\n          value: op[0] ? op[1] : void 0,\n          done: true\n        };\n      }\n    };\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n\n    var THREE = __webpack_require__(\n    /*! three */\n    \"three\");\n\n    var VRMSpringBone_1 = __webpack_require__(\n    /*! ./VRMSpringBone */\n    \"./src/vrm/springbone/VRMSpringBone.ts\");\n\n    var VRMSpringBoneManager_1 = __webpack_require__(\n    /*! ./VRMSpringBoneManager */\n    \"./src/vrm/springbone/VRMSpringBoneManager.ts\");\n\n    var VRMSpringBoneImporter = function () {\n      function VRMSpringBoneImporter() {}\n\n      VRMSpringBoneImporter.prototype.import = function (gltf) {\n        return __awaiter(this, void 0, Promise, function () {\n          var colliderGroups, springBoneGroupList;\n          return __generator(this, function (_a) {\n            switch (_a.label) {\n              case 0:\n                if (!gltf.parser.json.extensions || !gltf.parser.json.extensions.VRM || !gltf.parser.json.extensions.VRM.secondaryAnimation) {\n                  return [2, null];\n                }\n\n                return [4, this._getColliderMeshGroups(gltf)];\n\n              case 1:\n                colliderGroups = _a.sent();\n                colliderGroups.forEach(function (group) {\n                  var _a;\n\n                  return (_a = gltf.scene).add.apply(_a, group.colliders);\n                });\n                return [4, this._getSpringBoneGroupList(gltf, colliderGroups)];\n\n              case 2:\n                springBoneGroupList = _a.sent();\n                return [2, new VRMSpringBoneManager_1.VRMSpringBoneManager(springBoneGroupList)];\n            }\n          });\n        });\n      };\n\n      Object.defineProperty(VRMSpringBoneImporter.prototype, \"_isColiderMeshVisible\", {\n        get: function () {\n          return false;\n        },\n        enumerable: true,\n        configurable: true\n      });\n\n      VRMSpringBoneImporter.prototype._createSpringBone = function (gltf, bone, hitRadius, stiffiness, gravityDir, gravityPower, dragForce, colliders) {\n        if (colliders === void 0) {\n          colliders = [];\n        }\n\n        return new VRMSpringBone_1.VRMSpringBone(bone, hitRadius, stiffiness, gravityDir, gravityPower, dragForce, colliders);\n      };\n\n      VRMSpringBoneImporter.prototype._getSpringBoneGroupList = function (gltf, colliderGroups) {\n        return __awaiter(this, void 0, Promise, function () {\n          var springBoneGroups, springBoneGroupList;\n\n          var _this = this;\n\n          return __generator(this, function (_a) {\n            springBoneGroups = gltf.parser.json.extensions.VRM.secondaryAnimation.boneGroups;\n            springBoneGroupList = [];\n            springBoneGroups.forEach(function (vrmBoneGroup) {\n              if (vrmBoneGroup.stiffiness === undefined || vrmBoneGroup.gravityDir === undefined || vrmBoneGroup.gravityDir.x === undefined || vrmBoneGroup.gravityDir.y === undefined || vrmBoneGroup.gravityDir.z === undefined || vrmBoneGroup.gravityPower === undefined || vrmBoneGroup.dragForce === undefined || vrmBoneGroup.hitRadius === undefined || vrmBoneGroup.colliderGroups === undefined || vrmBoneGroup.bones === undefined) {\n                return;\n              }\n\n              var stiffiness = vrmBoneGroup.stiffiness;\n              var gravityDir = new THREE.Vector3(vrmBoneGroup.gravityDir.x, vrmBoneGroup.gravityDir.y, vrmBoneGroup.gravityDir.z);\n              var gravityPower = vrmBoneGroup.gravityPower;\n              var dragForce = vrmBoneGroup.dragForce;\n              var hitRadius = vrmBoneGroup.hitRadius;\n              var colliders = [];\n              vrmBoneGroup.colliderGroups.forEach(function (colliderIndex) {\n                colliders.push.apply(colliders, colliderGroups[colliderIndex].colliders);\n              });\n              var springBoneGroup = [];\n              vrmBoneGroup.bones.forEach(function (nodeIndex) {\n                return __awaiter(_this, void 0, void 0, function () {\n                  var springRootBone;\n\n                  var _this = this;\n\n                  return __generator(this, function (_a) {\n                    switch (_a.label) {\n                      case 0:\n                        return [4, gltf.parser.getDependency('node', nodeIndex)];\n\n                      case 1:\n                        springRootBone = _a.sent();\n\n                        if (!springRootBone) {\n                          return [2];\n                        }\n\n                        springRootBone.traverse(function (bone) {\n                          var springBone = _this._createSpringBone(gltf, bone, hitRadius, stiffiness, gravityDir, gravityPower, dragForce, colliders);\n\n                          springBoneGroup.push(springBone);\n                        });\n                        return [2];\n                    }\n                  });\n                });\n              });\n              springBoneGroupList.push(springBoneGroup);\n            });\n            return [2, springBoneGroupList];\n          });\n        });\n      };\n\n      VRMSpringBoneImporter.prototype._getColliderMeshGroups = function (gltf) {\n        return __awaiter(this, void 0, Promise, function () {\n          var vrmExt, secondaryAnimation, vrmColliderGroups, colliderGroups;\n\n          var _this = this;\n\n          return __generator(this, function (_a) {\n            vrmExt = gltf.parser.json.extensions && gltf.parser.json.extensions.VRM;\n\n            if (vrmExt === undefined) {\n              return [2, []];\n            }\n\n            secondaryAnimation = vrmExt.secondaryAnimation;\n\n            if (secondaryAnimation === undefined) {\n              return [2, []];\n            }\n\n            vrmColliderGroups = secondaryAnimation.colliderGroups;\n\n            if (vrmColliderGroups === undefined) {\n              return [2, []];\n            }\n\n            colliderGroups = [];\n            vrmColliderGroups.forEach(function (colliderGroup) {\n              return __awaiter(_this, void 0, void 0, function () {\n                var bone, colliders, colliderMeshGroup;\n\n                var _this = this;\n\n                return __generator(this, function (_a) {\n                  switch (_a.label) {\n                    case 0:\n                      if (colliderGroup.node === undefined || colliderGroup.colliders === undefined) {\n                        return [2];\n                      }\n\n                      return [4, gltf.parser.getDependency('node', colliderGroup.node)];\n\n                    case 1:\n                      bone = _a.sent();\n                      colliders = [];\n                      colliderGroup.colliders.forEach(function (collider) {\n                        if (collider.offset === undefined || collider.offset.x === undefined || collider.offset.y === undefined || collider.offset.z === undefined || collider.radius === undefined) {\n                          return;\n                        }\n\n                        var offsetMatrix = new THREE.Matrix4().makeTranslation(collider.offset.x, collider.offset.y, -collider.offset.z);\n                        var visible = _this._isColiderMeshVisible;\n                        var colliderMesh = new THREE.Mesh(new THREE.SphereBufferGeometry(collider.radius, 8, 4), new THREE.MeshBasicMaterial({\n                          color: 0xff00ff,\n                          visible: visible,\n                          wireframe: true,\n                          transparent: true,\n                          depthTest: false\n                        }));\n                        colliderMesh.material.renderOrder = VRMSpringBone_1.GIZMO_RENDER_ORDER;\n                        colliderMesh.name = 'vrmColliderSphere';\n                        colliderMesh.geometry.computeBoundingSphere();\n\n                        colliderMesh.updateMatrixWorld = function () {\n                          colliderMesh.matrixWorld.copy(bone.matrixWorld).multiply(offsetMatrix);\n                        };\n\n                        colliders.push(colliderMesh);\n                      });\n                      colliderMeshGroup = {\n                        node: colliderGroup.node,\n                        colliders: colliders\n                      };\n                      colliderGroups.push(colliderMeshGroup);\n                      return [2];\n                  }\n                });\n              });\n            });\n            return [2, colliderGroups];\n          });\n        });\n      };\n\n      return VRMSpringBoneImporter;\n    }();\n\n    exports.VRMSpringBoneImporter = VRMSpringBoneImporter;\n    /***/\n  },\n\n  /***/\n  \"./src/vrm/springbone/VRMSpringBoneManager.ts\":\n  /*!****************************************************!*\\\r\n    !*** ./src/vrm/springbone/VRMSpringBoneManager.ts ***!\r\n    \\****************************************************/\n\n  /*! no static exports found */\n\n  /***/\n  function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n\n    var VRMSpringBoneManager = function () {\n      function VRMSpringBoneManager(springBoneGroupList) {\n        this.springBoneGroupList = [];\n        this.springBoneGroupList = springBoneGroupList;\n      }\n\n      VRMSpringBoneManager.prototype.lateUpdate = function (delta) {\n        this.springBoneGroupList.forEach(function (springBoneGroup) {\n          springBoneGroup.forEach(function (springBone) {\n            springBone.update(delta);\n          });\n        });\n      };\n\n      VRMSpringBoneManager.prototype.reset = function () {\n        this.springBoneGroupList.forEach(function (springBoneGroup) {\n          springBoneGroup.forEach(function (springBone) {\n            springBone.reset();\n          });\n        });\n      };\n\n      return VRMSpringBoneManager;\n    }();\n\n    exports.VRMSpringBoneManager = VRMSpringBoneManager;\n    /***/\n  },\n\n  /***/\n  \"./src/vrm/springbone/index.ts\":\n  /*!*************************************!*\\\r\n    !*** ./src/vrm/springbone/index.ts ***!\r\n    \\*************************************/\n\n  /*! no static exports found */\n\n  /***/\n  function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    function __export(m) {\n      for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n    }\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n\n    __export(__webpack_require__(\n    /*! ./VRMSpringBone */\n    \"./src/vrm/springbone/VRMSpringBone.ts\"));\n\n    __export(__webpack_require__(\n    /*! ./VRMSpringBoneColliderGroup */\n    \"./src/vrm/springbone/VRMSpringBoneColliderGroup.ts\"));\n\n    __export(__webpack_require__(\n    /*! ./VRMSpringBoneImporter */\n    \"./src/vrm/springbone/VRMSpringBoneImporter.ts\"));\n\n    __export(__webpack_require__(\n    /*! ./VRMSpringBoneManager */\n    \"./src/vrm/springbone/VRMSpringBoneManager.ts\"));\n    /***/\n\n  },\n\n  /***/\n  \"./src/vrm/types/GLTFSchema.ts\":\n  /*!*************************************!*\\\r\n    !*** ./src/vrm/types/GLTFSchema.ts ***!\r\n    \\*************************************/\n\n  /*! no static exports found */\n\n  /***/\n  function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n    /***/\n  },\n\n  /***/\n  \"./src/vrm/types/VRMSchema.ts\":\n  /*!************************************!*\\\r\n    !*** ./src/vrm/types/VRMSchema.ts ***!\r\n    \\************************************/\n\n  /*! no static exports found */\n\n  /***/\n  function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n    var VRMSchema;\n\n    (function (VRMSchema) {\n      var BlendShapePresetName;\n\n      (function (BlendShapePresetName) {\n        BlendShapePresetName[\"A\"] = \"a\";\n        BlendShapePresetName[\"Angry\"] = \"angry\";\n        BlendShapePresetName[\"Blink\"] = \"blink\";\n        BlendShapePresetName[\"BlinkL\"] = \"blink_l\";\n        BlendShapePresetName[\"BlinkR\"] = \"blink_r\";\n        BlendShapePresetName[\"E\"] = \"e\";\n        BlendShapePresetName[\"Fun\"] = \"fun\";\n        BlendShapePresetName[\"I\"] = \"i\";\n        BlendShapePresetName[\"Joy\"] = \"joy\";\n        BlendShapePresetName[\"Lookdown\"] = \"lookdown\";\n        BlendShapePresetName[\"Lookleft\"] = \"lookleft\";\n        BlendShapePresetName[\"Lookright\"] = \"lookright\";\n        BlendShapePresetName[\"Lookup\"] = \"lookup\";\n        BlendShapePresetName[\"Neutral\"] = \"neutral\";\n        BlendShapePresetName[\"O\"] = \"o\";\n        BlendShapePresetName[\"Sorrow\"] = \"sorrow\";\n        BlendShapePresetName[\"U\"] = \"u\";\n        BlendShapePresetName[\"Unknown\"] = \"unknown\";\n      })(BlendShapePresetName = VRMSchema.BlendShapePresetName || (VRMSchema.BlendShapePresetName = {}));\n\n      var FirstPersonLookAtTypeName;\n\n      (function (FirstPersonLookAtTypeName) {\n        FirstPersonLookAtTypeName[\"BlendShape\"] = \"BlendShape\";\n        FirstPersonLookAtTypeName[\"Bone\"] = \"Bone\";\n      })(FirstPersonLookAtTypeName = VRMSchema.FirstPersonLookAtTypeName || (VRMSchema.FirstPersonLookAtTypeName = {}));\n\n      var HumanoidBoneName;\n\n      (function (HumanoidBoneName) {\n        HumanoidBoneName[\"Chest\"] = \"chest\";\n        HumanoidBoneName[\"Head\"] = \"head\";\n        HumanoidBoneName[\"Hips\"] = \"hips\";\n        HumanoidBoneName[\"Jaw\"] = \"jaw\";\n        HumanoidBoneName[\"LeftEye\"] = \"leftEye\";\n        HumanoidBoneName[\"LeftFoot\"] = \"leftFoot\";\n        HumanoidBoneName[\"LeftHand\"] = \"leftHand\";\n        HumanoidBoneName[\"LeftIndexDistal\"] = \"leftIndexDistal\";\n        HumanoidBoneName[\"LeftIndexIntermediate\"] = \"leftIndexIntermediate\";\n        HumanoidBoneName[\"LeftIndexProximal\"] = \"leftIndexProximal\";\n        HumanoidBoneName[\"LeftLittleDistal\"] = \"leftLittleDistal\";\n        HumanoidBoneName[\"LeftLittleIntermediate\"] = \"leftLittleIntermediate\";\n        HumanoidBoneName[\"LeftLittleProximal\"] = \"leftLittleProximal\";\n        HumanoidBoneName[\"LeftLowerArm\"] = \"leftLowerArm\";\n        HumanoidBoneName[\"LeftLowerLeg\"] = \"leftLowerLeg\";\n        HumanoidBoneName[\"LeftMiddleDistal\"] = \"leftMiddleDistal\";\n        HumanoidBoneName[\"LeftMiddleIntermediate\"] = \"leftMiddleIntermediate\";\n        HumanoidBoneName[\"LeftMiddleProximal\"] = \"leftMiddleProximal\";\n        HumanoidBoneName[\"LeftRingDistal\"] = \"leftRingDistal\";\n        HumanoidBoneName[\"LeftRingIntermediate\"] = \"leftRingIntermediate\";\n        HumanoidBoneName[\"LeftRingProximal\"] = \"leftRingProximal\";\n        HumanoidBoneName[\"LeftShoulder\"] = \"leftShoulder\";\n        HumanoidBoneName[\"LeftThumbDistal\"] = \"leftThumbDistal\";\n        HumanoidBoneName[\"LeftThumbIntermediate\"] = \"leftThumbIntermediate\";\n        HumanoidBoneName[\"LeftThumbProximal\"] = \"leftThumbProximal\";\n        HumanoidBoneName[\"LeftToes\"] = \"leftToes\";\n        HumanoidBoneName[\"LeftUpperArm\"] = \"leftUpperArm\";\n        HumanoidBoneName[\"LeftUpperLeg\"] = \"leftUpperLeg\";\n        HumanoidBoneName[\"Neck\"] = \"neck\";\n        HumanoidBoneName[\"RightEye\"] = \"rightEye\";\n        HumanoidBoneName[\"RightFoot\"] = \"rightFoot\";\n        HumanoidBoneName[\"RightHand\"] = \"rightHand\";\n        HumanoidBoneName[\"RightIndexDistal\"] = \"rightIndexDistal\";\n        HumanoidBoneName[\"RightIndexIntermediate\"] = \"rightIndexIntermediate\";\n        HumanoidBoneName[\"RightIndexProximal\"] = \"rightIndexProximal\";\n        HumanoidBoneName[\"RightLittleDistal\"] = \"rightLittleDistal\";\n        HumanoidBoneName[\"RightLittleIntermediate\"] = \"rightLittleIntermediate\";\n        HumanoidBoneName[\"RightLittleProximal\"] = \"rightLittleProximal\";\n        HumanoidBoneName[\"RightLowerArm\"] = \"rightLowerArm\";\n        HumanoidBoneName[\"RightLowerLeg\"] = \"rightLowerLeg\";\n        HumanoidBoneName[\"RightMiddleDistal\"] = \"rightMiddleDistal\";\n        HumanoidBoneName[\"RightMiddleIntermediate\"] = \"rightMiddleIntermediate\";\n        HumanoidBoneName[\"RightMiddleProximal\"] = \"rightMiddleProximal\";\n        HumanoidBoneName[\"RightRingDistal\"] = \"rightRingDistal\";\n        HumanoidBoneName[\"RightRingIntermediate\"] = \"rightRingIntermediate\";\n        HumanoidBoneName[\"RightRingProximal\"] = \"rightRingProximal\";\n        HumanoidBoneName[\"RightShoulder\"] = \"rightShoulder\";\n        HumanoidBoneName[\"RightThumbDistal\"] = \"rightThumbDistal\";\n        HumanoidBoneName[\"RightThumbIntermediate\"] = \"rightThumbIntermediate\";\n        HumanoidBoneName[\"RightThumbProximal\"] = \"rightThumbProximal\";\n        HumanoidBoneName[\"RightToes\"] = \"rightToes\";\n        HumanoidBoneName[\"RightUpperArm\"] = \"rightUpperArm\";\n        HumanoidBoneName[\"RightUpperLeg\"] = \"rightUpperLeg\";\n        HumanoidBoneName[\"Spine\"] = \"spine\";\n        HumanoidBoneName[\"UpperChest\"] = \"upperChest\";\n      })(HumanoidBoneName = VRMSchema.HumanoidBoneName || (VRMSchema.HumanoidBoneName = {}));\n\n      var MetaAllowedUserName;\n\n      (function (MetaAllowedUserName) {\n        MetaAllowedUserName[\"Everyone\"] = \"Everyone\";\n        MetaAllowedUserName[\"ExplicitlyLicensedPerson\"] = \"ExplicitlyLicensedPerson\";\n        MetaAllowedUserName[\"OnlyAuthor\"] = \"OnlyAuthor\";\n      })(MetaAllowedUserName = VRMSchema.MetaAllowedUserName || (VRMSchema.MetaAllowedUserName = {}));\n\n      var MetaUssageName;\n\n      (function (MetaUssageName) {\n        MetaUssageName[\"Allow\"] = \"Allow\";\n        MetaUssageName[\"Disallow\"] = \"Disallow\";\n      })(MetaUssageName = VRMSchema.MetaUssageName || (VRMSchema.MetaUssageName = {}));\n\n      var MetaLicenseName;\n\n      (function (MetaLicenseName) {\n        MetaLicenseName[\"Cc0\"] = \"CC0\";\n        MetaLicenseName[\"CcBy\"] = \"CC_BY\";\n        MetaLicenseName[\"CcByNc\"] = \"CC_BY_NC\";\n        MetaLicenseName[\"CcByNcNd\"] = \"CC_BY_NC_ND\";\n        MetaLicenseName[\"CcByNcSa\"] = \"CC_BY_NC_SA\";\n        MetaLicenseName[\"CcByNd\"] = \"CC_BY_ND\";\n        MetaLicenseName[\"CcBySa\"] = \"CC_BY_SA\";\n        MetaLicenseName[\"Other\"] = \"Other\";\n        MetaLicenseName[\"RedistributionProhibited\"] = \"Redistribution_Prohibited\";\n      })(MetaLicenseName = VRMSchema.MetaLicenseName || (VRMSchema.MetaLicenseName = {}));\n    })(VRMSchema = exports.VRMSchema || (exports.VRMSchema = {}));\n    /***/\n\n  },\n\n  /***/\n  \"./src/vrm/types/index.ts\":\n  /*!********************************!*\\\r\n    !*** ./src/vrm/types/index.ts ***!\r\n    \\********************************/\n\n  /*! no static exports found */\n\n  /***/\n  function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    function __export(m) {\n      for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n    }\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n\n    __export(__webpack_require__(\n    /*! ./GLTFSchema */\n    \"./src/vrm/types/GLTFSchema.ts\"));\n\n    __export(__webpack_require__(\n    /*! ./VRMSchema */\n    \"./src/vrm/types/VRMSchema.ts\"));\n\n    __export(__webpack_require__(\n    /*! ./types */\n    \"./src/vrm/types/types.ts\"));\n    /***/\n\n  },\n\n  /***/\n  \"./src/vrm/types/types.ts\":\n  /*!********************************!*\\\r\n    !*** ./src/vrm/types/types.ts ***!\r\n    \\********************************/\n\n  /*! no static exports found */\n\n  /***/\n  function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n    /***/\n  },\n\n  /***/\n  \"./src/vrm/utils/disposer.ts\":\n  /*!***********************************!*\\\r\n    !*** ./src/vrm/utils/disposer.ts ***!\r\n    \\***********************************/\n\n  /*! no static exports found */\n\n  /***/\n  function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n\n    function disposeMaterial(material) {\n      Object.keys(material).forEach(function (propertyName) {\n        if (!!material[propertyName] && typeof material[propertyName].dispose === 'function') {\n          material[propertyName].dispose();\n        }\n      });\n      material.dispose();\n      material = undefined;\n    }\n\n    function dispose(object3D) {\n      if (object3D.geometry) {\n        object3D.geometry.dispose();\n        object3D.geometry = undefined;\n      }\n\n      if (!!object3D.material && Array.isArray(object3D.material)) {\n        object3D.material.forEach(function (material) {\n          return disposeMaterial(material);\n        });\n      } else if (object3D.material) {\n        disposeMaterial(object3D.material);\n      }\n    }\n\n    function deepDispose(object3D) {\n      object3D.traverse(dispose);\n    }\n\n    exports.deepDispose = deepDispose;\n    /***/\n  },\n\n  /***/\n  \"./src/vrm/utils/math.ts\":\n  /*!*******************************!*\\\r\n    !*** ./src/vrm/utils/math.ts ***!\r\n    \\*******************************/\n\n  /*! no static exports found */\n\n  /***/\n  function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n\n    var THREE = __webpack_require__(\n    /*! three */\n    \"three\");\n\n    function saturate(value) {\n      return Math.max(Math.min(value, 1.0), 0.0);\n    }\n\n    exports.saturate = saturate;\n\n    function linstep(x, min, max) {\n      if (x <= min) return 0;\n      if (x >= max) return 1;\n      return (x - min) / (max - min);\n    }\n\n    exports.linstep = linstep;\n\n    var _position = new THREE.Vector3();\n\n    var _scale = new THREE.Vector3();\n\n    var _rotation = new THREE.Quaternion();\n\n    function getWorldPositionLite(object, out) {\n      object.matrixWorld.decompose(out, _rotation, _scale);\n      return out;\n    }\n\n    exports.getWorldPositionLite = getWorldPositionLite;\n\n    function getWorldScaleLite(object, out) {\n      object.matrixWorld.decompose(_position, _rotation, out);\n      return out;\n    }\n\n    exports.getWorldScaleLite = getWorldScaleLite;\n\n    function getWorldQuaternionLite(object, out) {\n      object.matrixWorld.decompose(_position, out, _scale);\n      return out;\n    }\n\n    exports.getWorldQuaternionLite = getWorldQuaternionLite;\n    /***/\n  },\n\n  /***/\n  \"./src/vrm/utils/renameMaterialProperty.ts\":\n  /*!*************************************************!*\\\r\n    !*** ./src/vrm/utils/renameMaterialProperty.ts ***!\r\n    \\*************************************************/\n\n  /*! no static exports found */\n\n  /***/\n  function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n\n    function renameMaterialProperty(name) {\n      if (name[0] !== '_') {\n        console.warn(\"renameMaterialProperty: Given property name \\\"\" + name + \"\\\" might be invalid\");\n        return name;\n      }\n\n      name = name.substring(1);\n\n      if (!/[A-Z]/.test(name[0])) {\n        console.warn(\"renameMaterialProperty: Given property name \\\"\" + name + \"\\\" might be invalid\");\n        return name;\n      }\n\n      return name[0].toLowerCase() + name.substring(1);\n    }\n\n    exports.renameMaterialProperty = renameMaterialProperty;\n    /***/\n  },\n\n  /***/\n  \"three\":\n  /*!************************!*\\\r\n    !*** external \"THREE\" ***!\r\n    \\************************/\n\n  /*! no static exports found */\n\n  /***/\n  function (module, exports) {\n    module.exports = THREE;\n    /***/\n  }\n  /******/\n\n});","map":{"version":3,"sources":["webpack://__three_vrm__/webpack/bootstrap","webpack://__three_vrm__/src/assign.ts","webpack://__three_vrm__/src/index.ts","webpack://__three_vrm__/src/vrm/VRM.ts","webpack://__three_vrm__/src/vrm/VRMImporter.ts","webpack://__three_vrm__/src/vrm/blendshape/VRMBlendShapeGroup.ts","webpack://__three_vrm__/src/vrm/blendshape/VRMBlendShapeImporter.ts","webpack://__three_vrm__/src/vrm/blendshape/VRMBlendShapeProxy.ts","webpack://__three_vrm__/src/vrm/blendshape/index.ts","webpack://__three_vrm__/src/vrm/debug/VRMDebug.ts","webpack://__three_vrm__/src/vrm/debug/VRMImporterDebug.ts","webpack://__three_vrm__/src/vrm/debug/VRMLookAtHeadDebug.ts","webpack://__three_vrm__/src/vrm/debug/VRMLookAtImporterDebug.ts","webpack://__three_vrm__/src/vrm/debug/VRMSpringBoneDebug.ts","webpack://__three_vrm__/src/vrm/debug/VRMSpringBoneImporterDebug.ts","webpack://__three_vrm__/src/vrm/debug/index.ts","webpack://__three_vrm__/src/vrm/firstperson/VRMFirstPerson.ts","webpack://__three_vrm__/src/vrm/firstperson/VRMFirstPersonImporter.ts","webpack://__three_vrm__/src/vrm/firstperson/index.ts","webpack://__three_vrm__/src/vrm/humanoid/VRMHumanBone.ts","webpack://__three_vrm__/src/vrm/humanoid/VRMHumanoid.ts","webpack://__three_vrm__/src/vrm/humanoid/VRMHumanoidImporter.ts","webpack://__three_vrm__/src/vrm/humanoid/index.ts","webpack://__three_vrm__/src/vrm/index.ts","webpack://__three_vrm__/src/vrm/lookat/CurveMapper.ts","webpack://__three_vrm__/src/vrm/lookat/VRMLookAtApplyer.ts","webpack://__three_vrm__/src/vrm/lookat/VRMLookAtBlendShapeApplyer.ts","webpack://__three_vrm__/src/vrm/lookat/VRMLookAtBoneApplyer.ts","webpack://__three_vrm__/src/vrm/lookat/VRMLookAtHead.ts","webpack://__three_vrm__/src/vrm/lookat/VRMLookAtImporter.ts","webpack://__three_vrm__/src/vrm/lookat/index.ts","webpack://__three_vrm__/src/vrm/material/MToonMaterial.ts","webpack://__three_vrm__/src/vrm/material/VRMMaterialImporter.ts","webpack://__three_vrm__/src/vrm/material/VRMUnlitMaterial.ts","webpack://__three_vrm__/src/vrm/material/getTexelDecodingFunction.ts","webpack://__three_vrm__/src/vrm/material/index.ts","webpack://__three_vrm__/src/vrm/material/shaders/mtoon.frag","webpack://__three_vrm__/src/vrm/material/shaders/mtoon.vert","webpack://__three_vrm__/src/vrm/material/shaders/unlit.frag","webpack://__three_vrm__/src/vrm/material/shaders/unlit.vert","webpack://__three_vrm__/src/vrm/reduceBones.ts","webpack://__three_vrm__/src/vrm/springbone/VRMSpringBone.ts","webpack://__three_vrm__/src/vrm/springbone/VRMSpringBoneImporter.ts","webpack://__three_vrm__/src/vrm/springbone/VRMSpringBoneManager.ts","webpack://__three_vrm__/src/vrm/springbone/index.ts","webpack://__three_vrm__/src/vrm/types/VRMSchema.ts","webpack://__three_vrm__/src/vrm/types/index.ts","webpack://__three_vrm__/src/vrm/utils/disposer.ts","webpack://__three_vrm__/src/vrm/utils/math.ts","webpack://__three_vrm__/src/vrm/utils/renameMaterialProperty.ts"],"names":[],"mappings":"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","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/assign.ts\");\n","/* eslint-disable */\nimport * as __three_vrm__ from '.';\n// @ts-ignore\nObject.assign(THREE, __three_vrm__);\n","export * from './vrm/';\n","import * as THREE from 'three';\nimport { VRMBlendShapeProxy } from './blendshape';\nimport { VRMFirstPerson } from './firstperson';\nimport { VRMHumanoid } from './humanoid';\nimport { VRMLookAtHead } from './lookat';\nimport { VRMSpringBoneManager } from './springbone';\nimport { VRMSchema } from './types';\nimport { deepDispose } from './utils/disposer';\nimport { VRMImporter, VRMImporterOptions } from './VRMImporter';\n\n/**\n * Parameters for a [[VRM]] class.\n */\nexport interface VRMParameters {\n  scene: THREE.Scene;\n  humanoid?: VRMHumanoid;\n  blendShapeProxy?: VRMBlendShapeProxy;\n  firstPerson?: VRMFirstPerson;\n  lookAt?: VRMLookAtHead;\n  materials?: THREE.Material[];\n  springBoneManager?: VRMSpringBoneManager;\n  meta?: VRMSchema.Meta;\n}\n\n/**\n * A class that represents a single VRM model.\n * See the documentation of [[VRM.from]] for the most basic use of VRM.\n */\nexport class VRM {\n  /**\n   * Create a new VRM from a parsed result of GLTF taken from GLTFLoader.\n   * It's probably a thing what you want to get started with VRMs.\n   *\n   * @example Most basic use of VRM\n   * ```\n   * const scene = new THREE.Scene();\n   *\n   * new THREE.GLTFLoader().load( 'models/three-vrm-girl.vrm', ( gltf ) => {\n   *\n   *   THREE.VRM.from( gltf ).then( ( vrm ) => {\n   *\n   *     scene.add( vrm.scene );\n   *\n   *   } );\n   *\n   * } );\n   * ```\n   *\n   * @param gltf A parsed GLTF object taken from GLTFLoader\n   * @param options Options that will be used in importer\n   */\n  public static async from(gltf: THREE.GLTF, options: VRMImporterOptions = {}): Promise<VRM> {\n    const importer = new VRMImporter(options);\n    return await importer.import(gltf);\n  }\n  /**\n   * `THREE.Scene` that contains the entire VRM.\n   */\n  public readonly scene: THREE.Scene;\n\n  /**\n   * Contains [[VRMHumanoid]] of the VRM.\n   * You can control each bones using [[VRMHumanoid.getBoneNode]].\n   *\n   * @TODO Add a link to VRM spec\n   */\n  public readonly humanoid?: VRMHumanoid;\n\n  /**\n   * Contains [[VRMBlendShapeProxy]] of the VRM.\n   * You might want to control these facial expressions via [[VRMBlendShapeProxy.setValue]].\n   */\n  public readonly blendShapeProxy?: VRMBlendShapeProxy;\n\n  /**\n   * Contains [[VRMFirstPerson]] of the VRM.\n   * You can use various feature of the firstPerson field.\n   */\n  public readonly firstPerson?: VRMFirstPerson;\n\n  /**\n   * Contains [[VRMLookAtHead]] of the VRM.\n   * You might want to use [[VRMLookAtHead.target]] to control the eye direction of your VRMs.\n   */\n  public readonly lookAt?: VRMLookAtHead;\n\n  /**\n   * Contains materials of the VRM.\n   * `updateVRMMaterials` method of these materials will be called via its [[VRM.update]] method.\n   */\n  public readonly materials?: THREE.Material[];\n\n  /**\n   * Contains meta fields of the VRM.\n   * You might want to refer these license fields before use your VRMs.\n   */\n  public readonly meta?: VRMSchema.Meta;\n\n  /**\n   * A [[VRMSpringBoneManager]] manipulates all spring bones attached on the VRM.\n   * Usually you don't have to care about this property.\n   */\n  public readonly springBoneManager?: VRMSpringBoneManager;\n\n  /**\n   * Create a new VRM instance.\n   *\n   * @param params [[VRMParameters]] that represents components of the VRM\n   */\n  public constructor(params: VRMParameters) {\n    this.scene = params.scene;\n    this.humanoid = params.humanoid;\n    this.blendShapeProxy = params.blendShapeProxy;\n    this.firstPerson = params.firstPerson;\n    this.lookAt = params.lookAt;\n    this.materials = params.materials;\n    this.springBoneManager = params.springBoneManager;\n    this.meta = params.meta;\n  }\n\n  /**\n   * **You need to call this on your update loop.**\n   *\n   * This function updates every VRM components.\n   *\n   * @param delta deltaTime\n   */\n  public update(delta: number): void {\n    if (this.lookAt) {\n      this.lookAt.update(delta);\n    }\n\n    if (this.blendShapeProxy) {\n      this.blendShapeProxy.update();\n    }\n\n    if (this.springBoneManager) {\n      this.springBoneManager.lateUpdate(delta);\n    }\n\n    if (this.materials) {\n      this.materials.forEach((material: any) => {\n        if (material.updateVRMMaterials) {\n          material.updateVRMMaterials(delta);\n        }\n      });\n    }\n  }\n\n  /**\n   * Dispose everything about the VRM instance.\n   */\n  public dispose(): void {\n    const scene = this.scene;\n    if (scene) {\n      while (scene.children.length > 0) {\n        const object = scene.children[scene.children.length - 1];\n        deepDispose(object);\n        scene.remove(object);\n      }\n    }\n  }\n}\n","import * as THREE from 'three';\nimport { VRMBlendShapeImporter } from './blendshape';\nimport { VRMFirstPersonImporter } from './firstperson';\nimport { VRMHumanoidImporter } from './humanoid/VRMHumanoidImporter';\nimport { VRMLookAtImporter } from './lookat/VRMLookAtImporter';\nimport { VRMMaterialImporter } from './material';\nimport { reduceBones } from './reduceBones';\nimport { VRMSpringBoneImporter } from './springbone/VRMSpringBoneImporter';\nimport { VRMSchema } from './types';\nimport { VRM } from './VRM';\n\nexport interface VRMImporterOptions {\n  lookAtImporter?: VRMLookAtImporter;\n  humanoidImporter?: VRMHumanoidImporter;\n  blendShapeImporter?: VRMBlendShapeImporter;\n  firstPersonImporter?: VRMFirstPersonImporter;\n  materialImporter?: VRMMaterialImporter;\n  springBoneImporter?: VRMSpringBoneImporter;\n}\n\n/**\n * An importer that imports a [[VRM]] from a VRM extension of a GLTF.\n */\nexport class VRMImporter {\n  protected readonly _blendShapeImporter: VRMBlendShapeImporter;\n  protected readonly _lookAtImporter: VRMLookAtImporter;\n  protected readonly _humanoidImporter: VRMHumanoidImporter;\n  protected readonly _firstPersonImporter: VRMFirstPersonImporter;\n  protected readonly _materialImporter: VRMMaterialImporter;\n  protected readonly _springBoneImporter: VRMSpringBoneImporter;\n\n  /**\n   * Create a new VRMImporter.\n   *\n   * @param options [[VRMImporterOptions]], optionally contains importers for each component\n   */\n  public constructor(options: VRMImporterOptions = {}) {\n    this._blendShapeImporter = options.blendShapeImporter || new VRMBlendShapeImporter();\n    this._lookAtImporter = options.lookAtImporter || new VRMLookAtImporter();\n    this._humanoidImporter = options.humanoidImporter || new VRMHumanoidImporter();\n    this._firstPersonImporter = options.firstPersonImporter || new VRMFirstPersonImporter();\n    this._materialImporter = options.materialImporter || new VRMMaterialImporter();\n    this._springBoneImporter = options.springBoneImporter || new VRMSpringBoneImporter();\n  }\n\n  /**\n   * Receive a GLTF object retrieved from `THREE.GLTFLoader` and create a new [[VRM]] instance.\n   *\n   * @param gltf A parsed result of GLTF taken from GLTFLoader\n   */\n  public async import(gltf: THREE.GLTF): Promise<VRM> {\n    if (gltf.parser.json.extensions === undefined || gltf.parser.json.extensions.VRM === undefined) {\n      throw new Error('Could not find VRM extension on the GLTF');\n    }\n    const vrmExt: VRMSchema.VRM = gltf.parser.json.extensions.VRM;\n\n    const scene = gltf.scene;\n\n    scene.updateMatrixWorld(false);\n\n    // Skinned object should not be frustumCulled\n    // Since pre-skinned position might be outside of view\n    scene.traverse((object3d) => {\n      if ((object3d as any).isMesh) {\n        object3d.frustumCulled = false;\n      }\n    });\n\n    reduceBones(scene);\n\n    const materials = (await this._materialImporter.convertGLTFMaterials(gltf)) || undefined;\n\n    const humanoid = (await this._humanoidImporter.import(gltf)) || undefined;\n\n    const firstPerson = humanoid ? (await this._firstPersonImporter.import(gltf, humanoid)) || undefined : undefined;\n\n    const blendShapeProxy = (await this._blendShapeImporter.import(gltf)) || undefined;\n\n    const lookAt =\n      firstPerson && blendShapeProxy && humanoid\n        ? (await this._lookAtImporter.import(gltf, firstPerson, blendShapeProxy, humanoid)) || undefined\n        : undefined;\n\n    const springBoneManager = (await this._springBoneImporter.import(gltf)) || undefined;\n\n    return new VRM({\n      scene: gltf.scene,\n      meta: vrmExt.meta,\n      materials,\n      humanoid,\n      firstPerson,\n      blendShapeProxy,\n      lookAt,\n      springBoneManager,\n    });\n  }\n}\n","import * as THREE from 'three';\nimport { GLTFPrimitive } from '../types';\n\nexport interface VRMBlendShapeBind {\n  meshes: GLTFPrimitive[];\n  morphTargetIndex: number;\n  weight: number;\n}\n\nenum VRMBlendShapeMaterialValueType {\n  NUMBER,\n  VECTOR2,\n  VECTOR3,\n  VECTOR4,\n  COLOR,\n}\n\nexport interface VRMBlendShapeMaterialValue {\n  material: THREE.Material;\n  propertyName: string;\n  defaultValue: number | THREE.Vector2 | THREE.Vector3 | THREE.Vector4 | THREE.Color;\n  targetValue: number | THREE.Vector2 | THREE.Vector3 | THREE.Vector4 | THREE.Color;\n  deltaValue: number | THREE.Vector2 | THREE.Vector3 | THREE.Vector4 | THREE.Color; // targetValue - defaultValue\n  type: VRMBlendShapeMaterialValueType;\n}\n\nconst _v2 = new THREE.Vector2();\nconst _v3 = new THREE.Vector3();\nconst _v4 = new THREE.Vector4();\nconst _color = new THREE.Color();\n\n// animationMixer の監視対象は、Scene の中に入っている必要がある。\n// そのため、表示オブジェクトではないけれど、Object3D を継承して Scene に投入できるようにする。\nexport class VRMBlendShapeGroup extends THREE.Object3D {\n  public weight = 0.0;\n  public isBinary = false;\n\n  private _binds: VRMBlendShapeBind[] = [];\n  private _materialValues: VRMBlendShapeMaterialValue[] = [];\n\n  constructor(expressionName: string) {\n    super();\n    this.name = `BlendShapeController_${expressionName}`;\n\n    // traverse 時の救済手段として Object3D ではないことを明示しておく\n    this.type = 'BlendShapeController';\n    // 表示目的のオブジェクトではないので、負荷軽減のために visible を false にしておく。\n    // これにより、このインスタンスに対する毎フレームの matrix 自動計算を省略できる。\n    this.visible = false;\n  }\n\n  public addBind(args: { meshes: GLTFPrimitive[]; morphTargetIndex: number; weight: number }): void {\n    // original weight is 0-100 but we want to deal with this value within 0-1\n    const weight = args.weight / 100;\n\n    this._binds.push({\n      meshes: args.meshes,\n      morphTargetIndex: args.morphTargetIndex,\n      weight,\n    });\n  }\n\n  public addMaterialValue(args: {\n    material: THREE.Material;\n    propertyName: string;\n    targetValue: number[];\n    defaultValue?: number | THREE.Vector2 | THREE.Vector3 | THREE.Vector4 | THREE.Color;\n  }): void {\n    const material = args.material;\n    const propertyName = args.propertyName;\n\n    let value = (material as any)[propertyName];\n    if (!value) {\n      // property has not been found\n      return;\n    }\n    value = args.defaultValue || value;\n\n    let type: VRMBlendShapeMaterialValueType;\n    let defaultValue: number | THREE.Vector2 | THREE.Vector3 | THREE.Vector4 | THREE.Color;\n    let targetValue: number | THREE.Vector2 | THREE.Vector3 | THREE.Vector4 | THREE.Color;\n    let deltaValue: number | THREE.Vector2 | THREE.Vector3 | THREE.Vector4 | THREE.Color;\n\n    if ((value as any).isVector2) {\n      type = VRMBlendShapeMaterialValueType.VECTOR2;\n      defaultValue = (value as THREE.Vector2).clone();\n      targetValue = new THREE.Vector2().fromArray(args.targetValue);\n      deltaValue = targetValue.clone().sub(defaultValue);\n    } else if ((value as any).isVector3) {\n      type = VRMBlendShapeMaterialValueType.VECTOR3;\n      defaultValue = (value as THREE.Vector3).clone();\n      targetValue = new THREE.Vector3().fromArray(args.targetValue);\n      deltaValue = targetValue.clone().sub(defaultValue);\n    } else if ((value as any).isVector4) {\n      type = VRMBlendShapeMaterialValueType.VECTOR4;\n      defaultValue = (value as THREE.Vector4).clone();\n\n      // vectorProperty and targetValue index is different from each other\n      // exported vrm by UniVRM file is\n      //\n      // vectorProperty\n      // offset = targetValue[0], targetValue[1]\n      // tiling = targetValue[2], targetValue[3]\n      //\n      // targetValue\n      // offset = targetValue[2], targetValue[3]\n      // tiling = targetValue[0], targetValue[1]\n      targetValue = new THREE.Vector4().fromArray([\n        args.targetValue[2],\n        args.targetValue[3],\n        args.targetValue[0],\n        args.targetValue[1],\n      ]);\n      deltaValue = targetValue.clone().sub(defaultValue);\n    } else if ((value as any).isColor) {\n      type = VRMBlendShapeMaterialValueType.COLOR;\n      defaultValue = (value as THREE.Color).clone();\n      targetValue = new THREE.Color().fromArray(args.targetValue);\n      deltaValue = targetValue.clone().sub(defaultValue);\n    } else {\n      type = VRMBlendShapeMaterialValueType.NUMBER;\n      defaultValue = value as number;\n      targetValue = args.targetValue[0];\n      deltaValue = targetValue - defaultValue;\n    }\n\n    this._materialValues.push({\n      material,\n      propertyName,\n      defaultValue,\n      targetValue,\n      deltaValue,\n      type,\n    });\n  }\n\n  /**\n   * Apply weight to every assigned blend shapes.\n   * Should be called via {@link BlendShapeMaster#update}.\n   */\n  public applyWeight(): void {\n    const w = this.isBinary ? (this.weight < 0.5 ? 0.0 : 1.0) : this.weight;\n\n    this._binds.forEach((bind) => {\n      bind.meshes.forEach((mesh) => {\n        if (!mesh.morphTargetInfluences) {\n          return;\n        } // TODO: we should kick this at `addBind`\n        mesh.morphTargetInfluences[bind.morphTargetIndex] += w * bind.weight;\n      });\n    });\n\n    this._materialValues.forEach((materialValue) => {\n      const prop = (materialValue.material as any)[materialValue.propertyName];\n      if (prop === undefined) {\n        return;\n      } // TODO: we should kick this at `addMaterialValue`\n\n      if (materialValue.type === VRMBlendShapeMaterialValueType.NUMBER) {\n        const deltaValue = materialValue.deltaValue as number;\n        (materialValue.material as any)[materialValue.propertyName] += deltaValue * w;\n      } else if (materialValue.type === VRMBlendShapeMaterialValueType.VECTOR2) {\n        const deltaValue = materialValue.deltaValue as THREE.Vector2;\n        (materialValue.material as any)[materialValue.propertyName].add(_v2.copy(deltaValue).multiplyScalar(w));\n      } else if (materialValue.type === VRMBlendShapeMaterialValueType.VECTOR3) {\n        const deltaValue = materialValue.deltaValue as THREE.Vector3;\n        (materialValue.material as any)[materialValue.propertyName].add(_v3.copy(deltaValue).multiplyScalar(w));\n      } else if (materialValue.type === VRMBlendShapeMaterialValueType.VECTOR4) {\n        const deltaValue = materialValue.deltaValue as THREE.Vector4;\n        (materialValue.material as any)[materialValue.propertyName].add(_v4.copy(deltaValue).multiplyScalar(w));\n      } else if (materialValue.type === VRMBlendShapeMaterialValueType.COLOR) {\n        const deltaValue = materialValue.deltaValue as THREE.Color;\n        (materialValue.material as any)[materialValue.propertyName].add(_color.copy(deltaValue).multiplyScalar(w));\n      }\n\n      if (typeof (materialValue.material as any).shouldApplyUniforms === 'boolean') {\n        (materialValue.material as any).shouldApplyUniforms = true;\n      }\n    });\n  }\n\n  /**\n   * Clear previously assigned blend shapes.\n   */\n  public clearAppliedWeight(): void {\n    this._binds.forEach((bind) => {\n      bind.meshes.forEach((mesh) => {\n        if (!mesh.morphTargetInfluences) {\n          return;\n        } // TODO: we should kick this at `addBind`\n        mesh.morphTargetInfluences[bind.morphTargetIndex] = 0.0;\n      });\n    });\n\n    this._materialValues.forEach((materialValue) => {\n      const prop = (materialValue.material as any)[materialValue.propertyName];\n      if (prop === undefined) {\n        return;\n      } // TODO: we should kick this at `addMaterialValue`\n\n      if (materialValue.type === VRMBlendShapeMaterialValueType.NUMBER) {\n        const defaultValue = materialValue.defaultValue as number;\n        (materialValue.material as any)[materialValue.propertyName] = defaultValue;\n      } else if (materialValue.type === VRMBlendShapeMaterialValueType.VECTOR2) {\n        const defaultValue = materialValue.defaultValue as THREE.Vector2;\n        (materialValue.material as any)[materialValue.propertyName].copy(defaultValue);\n      } else if (materialValue.type === VRMBlendShapeMaterialValueType.VECTOR3) {\n        const defaultValue = materialValue.defaultValue as THREE.Vector3;\n        (materialValue.material as any)[materialValue.propertyName].copy(defaultValue);\n      } else if (materialValue.type === VRMBlendShapeMaterialValueType.VECTOR4) {\n        const defaultValue = materialValue.defaultValue as THREE.Vector4;\n        (materialValue.material as any)[materialValue.propertyName].copy(defaultValue);\n      } else if (materialValue.type === VRMBlendShapeMaterialValueType.COLOR) {\n        const defaultValue = materialValue.defaultValue as THREE.Color;\n        (materialValue.material as any)[materialValue.propertyName].copy(defaultValue);\n      }\n\n      if (typeof (materialValue.material as any).shouldApplyUniforms === 'boolean') {\n        (materialValue.material as any).shouldApplyUniforms = true;\n      }\n    });\n  }\n}\n","import * as THREE from 'three';\nimport { GLTFMesh, GLTFPrimitive, VRMSchema } from '../types';\nimport { renameMaterialProperty } from '../utils/renameMaterialProperty';\nimport { VRMBlendShapeGroup } from './VRMBlendShapeGroup';\nimport { VRMBlendShapeProxy } from './VRMBlendShapeProxy';\n\n/**\n * An importer that imports a [[VRMBlendShape]] from a VRM extension of a GLTF.\n */\nexport class VRMBlendShapeImporter {\n  /**\n   * Import a [[VRMBlendShape]] from a VRM.\n   *\n   * @param gltf A parsed result of GLTF taken from GLTFLoader\n   */\n  public async import(gltf: THREE.GLTF): Promise<VRMBlendShapeProxy | null> {\n    const vrmExt: VRMSchema.VRM | undefined = gltf.parser.json.extensions && gltf.parser.json.extensions.VRM;\n    if (!vrmExt) {\n      return null;\n    }\n\n    const schemaBlendShape: VRMSchema.BlendShape | undefined = vrmExt.blendShapeMaster;\n    if (!schemaBlendShape) {\n      return null;\n    }\n\n    const blendShape = new VRMBlendShapeProxy();\n\n    const blendShapeGroups: VRMSchema.BlendShapeGroup[] | undefined = schemaBlendShape.blendShapeGroups;\n    if (!blendShapeGroups) {\n      return blendShape;\n    }\n\n    const blendShapePresetMap: { [presetName in VRMSchema.BlendShapePresetName]?: string } = {};\n\n    await Promise.all(\n      blendShapeGroups.map(async (schemaGroup) => {\n        const name = schemaGroup.name;\n        if (name === undefined) {\n          console.warn('VRMBlendShapeImporter: One of blendShapeGroups has no name');\n          return;\n        }\n\n        let presetName: VRMSchema.BlendShapePresetName | undefined;\n        if (\n          schemaGroup.presetName &&\n          schemaGroup.presetName !== VRMSchema.BlendShapePresetName.Unknown &&\n          !blendShapePresetMap[schemaGroup.presetName]\n        ) {\n          presetName = schemaGroup.presetName;\n          blendShapePresetMap[schemaGroup.presetName] = name;\n        }\n\n        const group = new VRMBlendShapeGroup(name);\n        gltf.scene.add(group);\n\n        group.isBinary = schemaGroup.isBinary || false;\n\n        if (schemaGroup.binds) {\n          schemaGroup.binds.forEach(async (bind) => {\n            if (bind.mesh === undefined || bind.index === undefined) {\n              return;\n            }\n\n            const morphMeshes: GLTFMesh = await gltf.parser.getDependency('mesh', bind.mesh);\n            const primitives: GLTFPrimitive[] =\n              morphMeshes.type === 'Group'\n                ? (morphMeshes.children as Array<GLTFPrimitive>)\n                : [morphMeshes as GLTFPrimitive];\n            const morphTargetIndex = bind.index;\n            if (\n              !primitives.every(\n                (primitive) =>\n                  Array.isArray(primitive.morphTargetInfluences) &&\n                  morphTargetIndex < primitive.morphTargetInfluences.length,\n              )\n            ) {\n              console.warn(\n                `VRMBlendShapeImporter: ${schemaGroup.name} attempts to index ${morphTargetIndex}th morph but not found.`,\n              );\n              return;\n            }\n\n            group.addBind({\n              meshes: primitives,\n              morphTargetIndex,\n              weight: bind.weight || 100,\n            });\n          });\n        }\n\n        const materialValues = schemaGroup.materialValues;\n        if (materialValues) {\n          materialValues.forEach((materialValue) => {\n            if (\n              materialValue.materialName === undefined ||\n              materialValue.propertyName === undefined ||\n              materialValue.targetValue === undefined\n            ) {\n              return;\n            }\n\n            const materials: THREE.Material[] = [];\n            gltf.scene.traverse((object) => {\n              if ((object as any).material) {\n                const material: THREE.Material[] | THREE.Material = (object as any).material;\n                if (Array.isArray(material)) {\n                  materials.push(\n                    ...material.filter(\n                      (mtl) => mtl.name === materialValue.materialName! && materials.indexOf(mtl) === -1,\n                    ),\n                  );\n                } else if (material.name === materialValue.materialName && materials.indexOf(material) === -1) {\n                  materials.push(material);\n                }\n              }\n            });\n\n            materials.forEach((material) => {\n              group.addMaterialValue({\n                material,\n                propertyName: renameMaterialProperty(materialValue.propertyName!),\n                targetValue: materialValue.targetValue!,\n              });\n            });\n          });\n        }\n\n        blendShape.registerBlendShapeGroup(name, presetName, group);\n      }),\n    );\n\n    return blendShape;\n  }\n}\n","import { VRMSchema } from '../types';\nimport { saturate } from '../utils/math';\nimport { VRMBlendShapeGroup } from './VRMBlendShapeGroup';\n\nexport class VRMBlendShapeProxy {\n  /**\n   * List of registered blend shape.\n   */\n  public readonly _blendShapeGroups: { [name: string]: VRMBlendShapeGroup } = {};\n\n  /**\n   * A map from [[VRMSchema.BlendShapePresetName]] to its actual blend shape name.\n   */\n  private readonly _blendShapePresetMap: { [presetName in VRMSchema.BlendShapePresetName]?: string } = {};\n\n  /**\n   * Create a new VRMBlendShape.\n   */\n  public constructor() {\n    // do nothing\n  }\n\n  /**\n   * List of name of registered blend shape group.\n   */\n  public get expressions(): string[] {\n    return Object.keys(this._blendShapeGroups);\n  }\n\n  /**\n   * Return registered blend shape group.\n   *\n   * @param name Name of the blend shape group\n   */\n  public getBlendShapeGroup(name: string | VRMSchema.BlendShapePresetName): VRMBlendShapeGroup | undefined {\n    const presetName = this._blendShapePresetMap[name as VRMSchema.BlendShapePresetName];\n    const controller = presetName ? this._blendShapeGroups[presetName] : this._blendShapeGroups[name];\n    if (!controller) {\n      console.warn(`no blend shape found by ${name}`);\n      return undefined;\n    }\n    return controller;\n  }\n\n  /**\n   * Register a blend shape group.\n   *\n   * @param name Name of the blend shape gorup\n   * @param controller VRMBlendShapeController that describes the blend shape group\n   */\n  public registerBlendShapeGroup(\n    name: string,\n    presetName: VRMSchema.BlendShapePresetName | undefined,\n    controller: VRMBlendShapeGroup,\n  ): void {\n    this._blendShapeGroups[name] = controller;\n    if (presetName) {\n      this._blendShapePresetMap[presetName] = name;\n    }\n  }\n\n  /**\n   * Get current weight of specified blend shape group.\n   *\n   * @param name Name of the blend shape group\n   */\n  public getValue(name: VRMSchema.BlendShapePresetName | string): number | null {\n    const controller = this.getBlendShapeGroup(name);\n    return (controller && controller.weight) || null;\n  }\n\n  /**\n   * Set a weight to specified blend shape group.\n   *\n   * @param name Name of the blend shape group\n   * @param weight Weight\n   */\n  public setValue(name: VRMSchema.BlendShapePresetName | string, weight: number): void {\n    const controller = this.getBlendShapeGroup(name);\n    if (controller) {\n      controller.weight = saturate(weight);\n    }\n  }\n\n  /**\n   * Get a track name of specified blend shape group.\n   * This track name is needed to manipulate its blend shape group via keyframe animations.\n   *\n   * @example Manipulate a blend shape group using keyframe animation\n   * ```js\n   * const trackName = vrm.blendShapeProxy.getBlendShapeTrackName( THREE.VRMSchema.BlendShapePresetName.Blink );\n   * const track = new THREE.NumberKeyframeTrack(\n   *   name,\n   *   [ 0.0, 0.5, 1.0 ], // times\n   *   [ 0.0, 1.0, 0.0 ] // values\n   * );\n   *\n   * const clip = new THREE.AnimationClip(\n   *   'blink', // name\n   *   1.0, // duration\n   *   [ track ] // tracks\n   * );\n   *\n   * const mixer = new THREE.AnimationMixer( vrm.scene );\n   * const action = mixer.clipAction( clip );\n   * action.play();\n   * ```\n   *\n   * @param name Name of the blend shape group\n   */\n  public getBlendShapeTrackName(name: VRMSchema.BlendShapePresetName | string): string | null {\n    const controller = this.getBlendShapeGroup(name);\n    return controller ? `${controller.name}.weight` : null;\n  }\n\n  /**\n   * Update every blend shape groups.\n   */\n  public update(): void {\n    Object.keys(this._blendShapeGroups).forEach((name) => {\n      const controller = this._blendShapeGroups[name];\n      controller.clearAppliedWeight();\n    });\n\n    Object.keys(this._blendShapeGroups).forEach((name) => {\n      const controller = this._blendShapeGroups[name];\n      controller.applyWeight();\n    });\n  }\n}\n","export * from './VRMBlendShapeGroup';\nexport * from './VRMBlendShapeImporter';\nexport * from './VRMBlendShapeProxy';\n","import * as THREE from 'three';\nimport { VRM, VRMParameters } from '../VRM';\nimport { VRMImporterOptions } from '../VRMImporter';\nimport { VRMDebugOptions } from './VRMDebugOptions';\nimport { VRMImporterDebug } from './VRMImporterDebug';\n\n/**\n * [[VRM]] but it has some useful gizmos.\n */\nexport class VRMDebug extends VRM {\n  /**\n   * Create a new VRMDebug from a parsed result of GLTF taken from GLTFLoader.\n   *\n   * See [[VRM.from]] for a detailed example.\n   *\n   * @param gltf A parsed GLTF object taken from GLTFLoader\n   * @param options Options that will be used in importer\n   * @param debugOption Options for VRMDebug features\n   */\n  public static async from(\n    gltf: THREE.GLTF,\n    options: VRMImporterOptions = {},\n    debugOption: VRMDebugOptions = {},\n  ): Promise<VRM> {\n    const importer = new VRMImporterDebug(options);\n    return await importer.import(gltf, debugOption);\n  }\n\n  /**\n   * Create a new VRMDebug instance.\n   *\n   * @param params [[VRMParameters]] that represents components of the VRM\n   * @param debugOption Options for VRMDebug features\n   */\n  constructor(params: VRMParameters, debugOption: VRMDebugOptions = {}) {\n    super(params);\n\n    // Gizmoを展開\n    if (!debugOption.disableBoxHelper) {\n      this.scene.add(new THREE.BoxHelper(this.scene));\n    }\n\n    if (!debugOption.disableSkeletonHelper) {\n      this.scene.add(new THREE.SkeletonHelper(this.scene));\n    }\n  }\n\n  public update(delta: number): void {\n    super.update(delta);\n  }\n}\n","import * as THREE from 'three';\nimport { reduceBones } from '../reduceBones';\nimport { VRMImporter, VRMImporterOptions } from '../VRMImporter';\nimport { VRMDebug } from './VRMDebug';\nimport { VRMDebugOptions } from './VRMDebugOptions';\nimport { VRMLookAtHeadDebug } from './VRMLookAtHeadDebug';\nimport { VRMLookAtImporterDebug } from './VRMLookAtImporterDebug';\nimport { VRMSpringBoneImporterDebug } from './VRMSpringBoneImporterDebug';\n\n/**\n * An importer that imports a [[VRMDebug]] from a VRM extension of a GLTF.\n */\nexport class VRMImporterDebug extends VRMImporter {\n  public constructor(options: VRMImporterOptions = {}) {\n    options.lookAtImporter = options.lookAtImporter || new VRMLookAtImporterDebug();\n    options.springBoneImporter = options.springBoneImporter || new VRMSpringBoneImporterDebug();\n    super(options);\n  }\n\n  public async import(gltf: THREE.GLTF, debugOptions: VRMDebugOptions = {}): Promise<VRMDebug> {\n    if (gltf.parser.json.extensions === undefined || gltf.parser.json.extensions.VRM === undefined) {\n      throw new Error('Could not find VRM extension on the GLTF');\n    }\n    const vrmExt = gltf.parser.json.extensions.VRM;\n\n    const scene = gltf.scene;\n\n    scene.updateMatrixWorld(false);\n\n    // Skinned object should not be frustumCulled\n    // Since pre-skinned position might be outside of view\n    scene.traverse((object3d) => {\n      if ((object3d as any).isMesh) {\n        object3d.frustumCulled = false;\n      }\n    });\n\n    reduceBones(scene);\n\n    const materials = (await this._materialImporter.convertGLTFMaterials(gltf)) || undefined;\n\n    const humanoid = (await this._humanoidImporter.import(gltf)) || undefined;\n\n    const firstPerson = humanoid ? (await this._firstPersonImporter.import(gltf, humanoid)) || undefined : undefined;\n\n    const blendShapeProxy = (await this._blendShapeImporter.import(gltf)) || undefined;\n\n    const lookAt =\n      firstPerson && blendShapeProxy && humanoid\n        ? (await this._lookAtImporter.import(gltf, firstPerson, blendShapeProxy, humanoid)) || undefined\n        : undefined;\n    if ((lookAt as any).setupHelper) {\n      (lookAt as VRMLookAtHeadDebug).setupHelper(scene, debugOptions);\n    }\n\n    const springBoneManager = (await this._springBoneImporter.import(gltf)) || undefined;\n\n    return new VRMDebug(\n      {\n        scene: gltf.scene,\n        meta: vrmExt.meta,\n        materials,\n        humanoid,\n        firstPerson,\n        blendShapeProxy,\n        lookAt,\n        springBoneManager,\n      },\n      debugOptions,\n    );\n  }\n}\n","import * as THREE from 'three';\nimport { VRMLookAtHead } from '../lookat/VRMLookAtHead';\nimport { VRMDebugOptions } from './VRMDebugOptions';\n\nconst _v3 = new THREE.Vector3();\n\nexport class VRMLookAtHeadDebug extends VRMLookAtHead {\n  private _faceDirectionHelper?: THREE.ArrowHelper;\n\n  public setupHelper(scene: THREE.Scene, debugOption: VRMDebugOptions): void {\n    if (!debugOption.disableFaceDirectionHelper) {\n      this._faceDirectionHelper = new THREE.ArrowHelper(\n        new THREE.Vector3(0, 0, -1),\n        new THREE.Vector3(0, 0, 0),\n        0.5,\n        0xff00ff,\n      );\n      scene.add(this._faceDirectionHelper);\n    }\n  }\n\n  public update(delta: number): void {\n    super.update(delta);\n\n    if (this._faceDirectionHelper) {\n      this.firstPerson.getFirstPersonWorldPosition(this._faceDirectionHelper.position);\n      this._faceDirectionHelper.setDirection(this.getLookAtWorldDirection(_v3));\n    }\n  }\n}\n","import * as THREE from 'three';\nimport { VRMBlendShapeProxy } from '../blendshape';\nimport { VRMFirstPerson } from '../firstperson';\nimport { VRMHumanoid } from '../humanoid';\nimport { VRMLookAtHead } from '../lookat/VRMLookAtHead';\nimport { VRMLookAtImporter } from '../lookat/VRMLookAtImporter';\nimport { VRMSchema } from '../types';\nimport { VRMLookAtHeadDebug } from './VRMLookAtHeadDebug';\n\nexport class VRMLookAtImporterDebug extends VRMLookAtImporter {\n  public import(\n    gltf: THREE.GLTF,\n    firstPerson: VRMFirstPerson,\n    blendShapeProxy: VRMBlendShapeProxy,\n    humanoid: VRMHumanoid,\n  ): VRMLookAtHead | null {\n    const vrmExt: VRMSchema.VRM | undefined = gltf.parser.json.extensions && gltf.parser.json.extensions.VRM;\n    if (!vrmExt) {\n      return null;\n    }\n\n    const schemaFirstPerson: VRMSchema.FirstPerson | undefined = vrmExt.firstPerson;\n    if (!schemaFirstPerson) {\n      return null;\n    }\n\n    const applyer = this._importApplyer(schemaFirstPerson, blendShapeProxy, humanoid);\n    return new VRMLookAtHeadDebug(firstPerson, applyer || undefined);\n  }\n}\n","import * as THREE from 'three';\nimport { GIZMO_RENDER_ORDER, VRMSpringBone } from '../springbone';\n\nconst _v3A = new THREE.Vector3();\n\nexport class VRMSpringBoneDebug extends VRMSpringBone {\n  private _gizmo?: THREE.ArrowHelper;\n\n  constructor(\n    bone: THREE.Object3D,\n    radius: number,\n    stiffiness: number,\n    gravityDir: THREE.Vector3,\n    gravityPower: number,\n    dragForce: number,\n    colliders: THREE.Mesh[] = [],\n  ) {\n    super(bone, radius, stiffiness, gravityDir, gravityPower, dragForce, colliders);\n  }\n\n  /**\n   * Return spring bone gizmo, as `THREE.ArrowHelper`.\n   * Useful in debugging spring bones.\n   */\n  public getGizmo(): THREE.ArrowHelper {\n    // return if gizmo is already existed\n    if (this._gizmo) {\n      return this._gizmo;\n    }\n\n    const nextTailRelative = _v3A.copy(this._nextTail).sub(this._worldPosition);\n    const nextTailRelativeLength = nextTailRelative.length();\n\n    this._gizmo = new THREE.ArrowHelper(\n      nextTailRelative.normalize(),\n      this._worldPosition,\n      nextTailRelativeLength,\n      0xffff00,\n      this.radius,\n      this.radius,\n    );\n\n    // it should be always visible\n    this._gizmo.line.renderOrder = GIZMO_RENDER_ORDER;\n    this._gizmo.cone.renderOrder = GIZMO_RENDER_ORDER;\n    (this._gizmo.line.material as THREE.Material).depthTest = false;\n    (this._gizmo.line.material as THREE.Material).transparent = true;\n    (this._gizmo.cone.material as THREE.Material).depthTest = false;\n    (this._gizmo.cone.material as THREE.Material).transparent = true;\n\n    return this._gizmo;\n  }\n\n  public update(delta: number): void {\n    super.update(delta);\n    // lastly we're gonna update gizmo\n    this._updateGizmo();\n  }\n\n  private _updateGizmo(): void {\n    if (!this._gizmo) {\n      return;\n    }\n\n    const nextTailRelative = _v3A.copy(this._currentTail).sub(this._worldPosition);\n    const nextTailRelativeLength = nextTailRelative.length();\n\n    this._gizmo.setDirection(nextTailRelative.normalize());\n    this._gizmo.setLength(nextTailRelativeLength, this.radius, this.radius);\n    this._gizmo.position.copy(this._worldPosition);\n  }\n}\n","import * as THREE from 'three';\nimport { VRMSpringBone } from '../springbone/VRMSpringBone';\nimport { VRMSpringBoneImporter } from '../springbone/VRMSpringBoneImporter';\nimport { VRMSpringBoneDebug } from './VRMSpringBoneDebug';\n\nexport class VRMSpringBoneImporterDebug extends VRMSpringBoneImporter {\n  protected get _isColiderMeshVisible(): boolean {\n    return true;\n  }\n\n  protected _createSpringBone(\n    gltf: THREE.GLTF,\n    bone: THREE.Object3D,\n    hitRadius: number,\n    stiffiness: number,\n    gravityDir: THREE.Vector3,\n    gravityPower: number,\n    dragForce: number,\n    colliders: THREE.Mesh[] = [],\n  ): VRMSpringBone {\n    const springBone = new VRMSpringBoneDebug(\n      bone,\n      hitRadius,\n      stiffiness,\n      gravityDir,\n      gravityPower,\n      dragForce,\n      colliders,\n    );\n    gltf.scene.add(springBone.getGizmo());\n    return springBone;\n  }\n}\n","export * from './VRMDebugOptions';\nexport * from './VRMDebug';\nexport * from './VRMSpringBoneDebug';\nexport * from './VRMSpringBoneImporterDebug';\n","import * as THREE from 'three';\nimport { GLTFMesh, GLTFNode } from '../types';\nimport { getWorldQuaternionLite } from '../utils/math';\n\nconst VECTOR3_FRONT = Object.freeze(new THREE.Vector3(0.0, 0.0, -1.0));\n\nconst _quat = new THREE.Quaternion();\n\nenum FirstPersonFlag {\n  Auto,\n  Both,\n  ThirdPersonOnly,\n  FirstPersonOnly,\n}\n\n/**\n * This class represents a single [`meshAnnotation`](https://github.com/vrm-c/UniVRM/blob/master/specification/0.0/schema/vrm.firstperson.meshannotation.schema.json) entry.\n * Each mesh will be assigned to specified layer when you call [[VRMFirstPerson.setup]].\n */\nexport class VRMRendererFirstPersonFlags {\n  private static _parseFirstPersonFlag(firstPersonFlag: string | undefined): FirstPersonFlag {\n    switch (firstPersonFlag) {\n      case 'Both':\n        return FirstPersonFlag.Both;\n      case 'ThirdPersonOnly':\n        return FirstPersonFlag.ThirdPersonOnly;\n      case 'FirstPersonOnly':\n        return FirstPersonFlag.FirstPersonOnly;\n      default:\n        return FirstPersonFlag.Auto;\n    }\n  }\n\n  /**\n   * A [[FirstPersonFlag]] of the annotation entry.\n   */\n  public firstPersonFlag: FirstPersonFlag;\n\n  /**\n   * A mesh of the annotation entry.\n   */\n  public mesh: GLTFMesh;\n\n  /**\n   * Create a new mesh annotation.\n   *\n   * @param firstPersonFlag A [[FirstPersonFlag]] of the annotation entry\n   * @param node A node of the annotation entry.\n   */\n  constructor(firstPersonFlag: string | undefined, mesh: GLTFMesh) {\n    this.firstPersonFlag = VRMRendererFirstPersonFlags._parseFirstPersonFlag(firstPersonFlag);\n    this.mesh = mesh;\n  }\n}\n\nexport class VRMFirstPerson {\n  /**\n   * A default camera layer for `FirstPersonOnly` layer.\n   *\n   * @see [[getFirstPersonOnlyLayer]]\n   */\n  private static readonly _DEFAULT_FIRSTPERSON_ONLY_LAYER = 9;\n\n  /**\n   * A default camera layer for `ThirdPersonOnly` layer.\n   *\n   * @see [[getThirdPersonOnlyLayer]]\n   */\n  private static readonly _DEFAULT_THIRDPERSON_ONLY_LAYER = 10;\n\n  private readonly _firstPersonBone: GLTFNode;\n  private readonly _meshAnnotations: VRMRendererFirstPersonFlags[] = [];\n  private readonly _firstPersonBoneOffset: THREE.Vector3;\n\n  private _firstPersonOnlyLayer = VRMFirstPerson._DEFAULT_FIRSTPERSON_ONLY_LAYER;\n  private _thirdPersonOnlyLayer = VRMFirstPerson._DEFAULT_THIRDPERSON_ONLY_LAYER;\n\n  private _initialized = false;\n\n  /**\n   * Create a new VRMFirstPerson object.\n   *\n   * @param firstPersonBone A first person bone\n   * @param firstPersonBoneOffset An offset from the specified first person bone\n   * @param meshAnnotations A renderer settings. See the description of [[RendererFirstPersonFlags]] for more info\n   */\n  constructor(\n    firstPersonBone: GLTFNode,\n    firstPersonBoneOffset: THREE.Vector3,\n    meshAnnotations: VRMRendererFirstPersonFlags[],\n  ) {\n    this._firstPersonBone = firstPersonBone;\n    this._firstPersonBoneOffset = firstPersonBoneOffset;\n    this._meshAnnotations = meshAnnotations;\n  }\n\n  public get firstPersonBone(): GLTFNode {\n    return this._firstPersonBone;\n  }\n\n  public get meshAnnotations(): VRMRendererFirstPersonFlags[] {\n    return this._meshAnnotations;\n  }\n\n  public getFirstPersonWorldDirection(target: THREE.Vector3): THREE.Vector3 {\n    return target.copy(VECTOR3_FRONT).applyQuaternion(getWorldQuaternionLite(this._firstPersonBone, _quat));\n  }\n\n  /**\n   * A camera layer represents `FirstPersonOnly` layer.\n   * Note that **you must call [[setup]] first before you use the layer feature** or it does not work properly.\n   *\n   * The value is [[DEFAULT_FIRSTPERSON_ONLY_LAYER]] by default but you can change the layer by specifying via [[setup]] if you prefer.\n   *\n   * @see https://vrm.dev/en/univrm/api/univrm_use_firstperson/\n   * @see https://threejs.org/docs/#api/en/core/Layers\n   */\n  public get firstPersonOnlyLayer(): number {\n    return this._firstPersonOnlyLayer;\n  }\n\n  /**\n   * A camera layer represents `ThirdPersonOnly` layer.\n   * Note that **you must call [[setup]] first before you use the layer feature** or it does not work properly.\n   *\n   * The value is [[DEFAULT_THIRDPERSON_ONLY_LAYER]] by default but you can change the layer by specifying via [[setup]] if you prefer.\n   *\n   * @see https://vrm.dev/en/univrm/api/univrm_use_firstperson/\n   * @see https://threejs.org/docs/#api/en/core/Layers\n   */\n  public get thirdPersonOnlyLayer(): number {\n    return this._thirdPersonOnlyLayer;\n  }\n\n  public getFirstPersonBoneOffset(target: THREE.Vector3): THREE.Vector3 {\n    return target.copy(this._firstPersonBoneOffset);\n  }\n\n  /**\n   * Get current world position of the first person.\n   * The position takes [[FirstPersonBone]] and [[FirstPersonOffset]] into account.\n   *\n   * @param v3 target\n   * @returns Current world position of the first person\n   */\n  public getFirstPersonWorldPosition(v3: THREE.Vector3): THREE.Vector3 {\n    // UniVRM#VRMFirstPersonEditor\n    // var worldOffset = head.localToWorldMatrix.MultiplyPoint(component.FirstPersonOffset);\n    const offset = this._firstPersonBoneOffset;\n    const v4 = new THREE.Vector4(offset.x, offset.y, offset.z, 1.0);\n    v4.applyMatrix4(this._firstPersonBone.matrixWorld);\n    return v3.set(v4.x, v4.y, v4.z);\n  }\n\n  /**\n   * In this method, it assigns layers for every meshes based on mesh annotations.\n   * You must call this method first before you use the layer feature.\n   *\n   * This is an equivalent of [VRMFirstPerson.Setup](https://github.com/vrm-c/UniVRM/blob/master/Assets/VRM/UniVRM/Scripts/FirstPerson/VRMFirstPerson.cs) of the UniVRM.\n   *\n   * The `cameraLayer` parameter specifies which layer will be assigned for `FirstPersonOnly` / `ThirdPersonOnly`.\n   * In UniVRM, we specified those by naming each desired layer as `FIRSTPERSON_ONLY_LAYER` / `THIRDPERSON_ONLY_LAYER`\n   * but we are going to specify these layers at here since we are unable to name layers in Three.js.\n   *\n   * @param cameraLayer Specify which layer will be for `FirstPersonOnly` / `ThirdPersonOnly`.\n   */\n  public setup({\n    firstPersonOnlyLayer = VRMFirstPerson._DEFAULT_FIRSTPERSON_ONLY_LAYER,\n    thirdPersonOnlyLayer = VRMFirstPerson._DEFAULT_THIRDPERSON_ONLY_LAYER,\n  } = {}): void {\n    if (this._initialized) {\n      return;\n    }\n    this._initialized = true;\n    this._firstPersonOnlyLayer = firstPersonOnlyLayer;\n    this._thirdPersonOnlyLayer = thirdPersonOnlyLayer;\n\n    this._meshAnnotations.forEach((item) => {\n      if (item.firstPersonFlag === FirstPersonFlag.FirstPersonOnly) {\n        item.mesh.layers.set(this._firstPersonOnlyLayer);\n        item.mesh.traverse((child) => child.layers.set(this._firstPersonOnlyLayer));\n      } else if (item.firstPersonFlag === FirstPersonFlag.ThirdPersonOnly) {\n        item.mesh.layers.set(this._thirdPersonOnlyLayer);\n        item.mesh.traverse((child) => child.layers.set(this._thirdPersonOnlyLayer));\n      } else if (item.firstPersonFlag === FirstPersonFlag.Auto) {\n        this._createHeadlessModel(item.mesh);\n      }\n    });\n  }\n\n  private _excludeTriangles(triangles: number[], bws: number[][], skinIndex: number[][], exclude: number[]): number {\n    let count = 0;\n    if (bws != null && bws.length > 0) {\n      for (let i = 0; i < triangles.length; i += 3) {\n        const a = triangles[i];\n        const b = triangles[i + 1];\n        const c = triangles[i + 2];\n        const bw0 = bws[a];\n        const skin0 = skinIndex[a];\n\n        if (bw0[0] > 0 && exclude.includes(skin0[0])) continue;\n        if (bw0[1] > 0 && exclude.includes(skin0[1])) continue;\n        if (bw0[2] > 0 && exclude.includes(skin0[2])) continue;\n        if (bw0[3] > 0 && exclude.includes(skin0[3])) continue;\n\n        const bw1 = bws[b];\n        const skin1 = skinIndex[b];\n        if (bw1[0] > 0 && exclude.includes(skin1[0])) continue;\n        if (bw1[1] > 0 && exclude.includes(skin1[1])) continue;\n        if (bw1[2] > 0 && exclude.includes(skin1[2])) continue;\n        if (bw1[3] > 0 && exclude.includes(skin1[3])) continue;\n\n        const bw2 = bws[c];\n        const skin2 = skinIndex[c];\n        if (bw2[0] > 0 && exclude.includes(skin2[0])) continue;\n        if (bw2[1] > 0 && exclude.includes(skin2[1])) continue;\n        if (bw2[2] > 0 && exclude.includes(skin2[2])) continue;\n        if (bw2[3] > 0 && exclude.includes(skin2[3])) continue;\n\n        triangles[count++] = a;\n        triangles[count++] = b;\n        triangles[count++] = c;\n      }\n    }\n    return count;\n  }\n\n  private _createErasedMesh(src: THREE.SkinnedMesh, erasingBonesIndex: number[]): THREE.SkinnedMesh {\n    const dst = new THREE.SkinnedMesh(src.geometry.clone(), src.material);\n    dst.name = `${src.name}(erase)`;\n    dst.frustumCulled = src.frustumCulled;\n    dst.layers.set(this._firstPersonOnlyLayer);\n\n    const geometry = dst.geometry as THREE.BufferGeometry;\n    const skinIndexAttr = geometry.getAttribute('skinIndex').array;\n    const skinIndex = [];\n    for (let i = 0; i < skinIndexAttr.length; i += 4) {\n      skinIndex.push([skinIndexAttr[i], skinIndexAttr[i + 1], skinIndexAttr[i + 2], skinIndexAttr[i + 3]]);\n    }\n    const skinWeightAttr = geometry.getAttribute('skinWeight').array;\n    const skinWeight = [];\n    for (let i = 0; i < skinWeightAttr.length; i += 4) {\n      skinWeight.push([skinWeightAttr[i], skinWeightAttr[i + 1], skinWeightAttr[i + 2], skinWeightAttr[i + 3]]);\n    }\n    const oldTriangles = Array.from(geometry.getIndex().array);\n    const count = this._excludeTriangles(oldTriangles, skinWeight, skinIndex, erasingBonesIndex);\n    const newTriangle: number[] = [];\n    for (let i = 0; i < count; i++) {\n      newTriangle[i] = oldTriangles[i];\n    }\n    geometry.setIndex(newTriangle);\n\n    // mtoon material includes onBeforeRender. this is unsupported at SkinnedMesh#clone\n    if (src.onBeforeRender) {\n      dst.onBeforeRender = src.onBeforeRender;\n    }\n    dst.bind(new THREE.Skeleton(src.skeleton.bones, src.skeleton.boneInverses), new THREE.Matrix4());\n    return dst;\n  }\n\n  private _createHeadlessModelForSkinnedMesh(parent: THREE.Object3D, mesh: THREE.SkinnedMesh): void {\n    const eraseBoneIndexes: number[] = [];\n    mesh.skeleton.bones.forEach((bone, index) => {\n      if (this._isEraseTarget(bone)) eraseBoneIndexes.push(index);\n    });\n\n    // Unlike UniVRM we don't copy mesh if no invisible bone was found\n    if (!eraseBoneIndexes.length) {\n      mesh.layers.enable(this._thirdPersonOnlyLayer);\n      mesh.layers.enable(this._firstPersonOnlyLayer);\n      return;\n    }\n    mesh.layers.set(this._thirdPersonOnlyLayer);\n    const newMesh = this._createErasedMesh(mesh, eraseBoneIndexes);\n    parent.add(newMesh);\n  }\n\n  private _createHeadlessModel(node: GLTFNode): void {\n    if (node.type === 'Group') {\n      node.layers.set(this._thirdPersonOnlyLayer);\n      if (this._isEraseTarget(node)) {\n        node.traverse((child) => child.layers.set(this._thirdPersonOnlyLayer));\n      } else {\n        const parent = new THREE.Group();\n        parent.name = `_headless_${node.name}`;\n        parent.layers.set(this._firstPersonOnlyLayer);\n        node.parent!.add(parent);\n        node.children\n          .filter((child) => child.type === 'SkinnedMesh')\n          .forEach((child) => {\n            this._createHeadlessModelForSkinnedMesh(parent, child as THREE.SkinnedMesh);\n          });\n      }\n    } else if (node.type === 'SkinnedMesh') {\n      this._createHeadlessModelForSkinnedMesh(node.parent!, node as THREE.SkinnedMesh);\n    } else {\n      if (this._isEraseTarget(node)) {\n        node.layers.set(this._thirdPersonOnlyLayer);\n        node.traverse((child) => child.layers.set(this._thirdPersonOnlyLayer));\n      }\n    }\n  }\n\n  private _isEraseTarget(bone: GLTFNode): boolean {\n    if (bone.name === this._firstPersonBone.name) {\n      return true;\n    } else if (!bone.parent) {\n      return false;\n    } else {\n      return this._isEraseTarget(bone.parent!);\n    }\n  }\n}\n","import * as THREE from 'three';\nimport { VRMHumanoid } from '../humanoid';\nimport { GLTFMesh, GLTFNode, VRMSchema } from '../types';\nimport { VRMFirstPerson, VRMRendererFirstPersonFlags } from './VRMFirstPerson';\n\n/**\n * An importer that imports a [[VRMFirstPerson]] from a VRM extension of a GLTF.\n */\nexport class VRMFirstPersonImporter {\n  /**\n   * Import a [[VRMFirstPerson]] from a VRM.\n   *\n   * @param gltf A parsed result of GLTF taken from GLTFLoader\n   * @param humanoid A [[VRMHumanoid]] instance that represents the VRM\n   */\n  public async import(gltf: THREE.GLTF, humanoid: VRMHumanoid): Promise<VRMFirstPerson | null> {\n    const vrmExt: VRMSchema.VRM | undefined = gltf.parser.json.extensions && gltf.parser.json.extensions.VRM;\n    if (!vrmExt) {\n      return null;\n    }\n\n    const schemaFirstPerson: VRMSchema.FirstPerson | undefined = vrmExt.firstPerson;\n    if (!schemaFirstPerson) {\n      return null;\n    }\n\n    const firstPersonBoneIndex = schemaFirstPerson.firstPersonBone;\n\n    let firstPersonBone: GLTFNode | null;\n    if (firstPersonBoneIndex === undefined || firstPersonBoneIndex === -1) {\n      firstPersonBone = humanoid.getBoneNode(VRMSchema.HumanoidBoneName.Head);\n    } else {\n      firstPersonBone = await gltf.parser.getDependency('node', firstPersonBoneIndex);\n    }\n\n    if (!firstPersonBone) {\n      console.warn('VRMFirstPersonImporter: Could not find firstPersonBone of the VRM');\n      return null;\n    }\n\n    const firstPersonBoneOffset = schemaFirstPerson.firstPersonBoneOffset\n      ? new THREE.Vector3(\n          schemaFirstPerson.firstPersonBoneOffset.x,\n          schemaFirstPerson.firstPersonBoneOffset.y,\n          schemaFirstPerson.firstPersonBoneOffset.z,\n        )\n      : new THREE.Vector3(0.0, 0.06, 0.0); // fallback, taken from UniVRM implementation\n\n    const meshAnnotations: VRMRendererFirstPersonFlags[] = [];\n    const meshes: GLTFMesh[] = await gltf.parser.getDependencies('mesh');\n    meshes.forEach((mesh, meshIndex) => {\n      const flag = schemaFirstPerson.meshAnnotations\n        ? schemaFirstPerson.meshAnnotations.find((a) => a.mesh === meshIndex)\n        : undefined;\n      meshAnnotations.push(new VRMRendererFirstPersonFlags(flag && flag.firstPersonFlag, mesh));\n    });\n\n    return new VRMFirstPerson(firstPersonBone, firstPersonBoneOffset, meshAnnotations);\n  }\n}\n","export * from './VRMFirstPerson';\nexport * from './VRMFirstPersonImporter';\n","import { GLTFNode } from '../types';\nimport { VRMHumanLimit } from './VRMHumanLimit';\n\n/**\n * A class represents a single `humanBone` of a VRM.\n */\nexport class VRMHumanBone {\n  /**\n   * A [[GLTFNode]] (that actually is a `THREE.Object3D`) that represents the bone.\n   */\n  public readonly node: GLTFNode;\n\n  /**\n   * A [[VRMHumanLimit]] object that represents properties of the bone.\n   */\n  public readonly humanLimit: VRMHumanLimit;\n\n  /**\n   * Create a new VRMHumanBone.\n   *\n   * @param node A [[GLTFNode]] that represents the new bone\n   * @param humanLimit A [[VRMHumanLimit]] object that represents properties of the new bone\n   */\n  public constructor(node: GLTFNode, humanLimit: VRMHumanLimit) {\n    this.node = node;\n    this.humanLimit = humanLimit;\n  }\n}\n","import { GLTFNode, RawVector3, RawVector4, VRMPose, VRMSchema } from '../types';\nimport { VRMHumanBone } from './VRMHumanBone';\nimport { VRMHumanBoneArray } from './VRMHumanBoneArray';\nimport { VRMHumanBones } from './VRMHumanBones';\nimport { VRMHumanDescription } from './VRMHumanDescription';\n\n/**\n * A class represents humanoid of a VRM.\n */\nexport class VRMHumanoid {\n  /**\n   * A [[VRMHumanBones]] that contains all the human bones of the VRM.\n   * You might want to get these bones using [[VRMHumanoid.getBone]].\n   */\n  public readonly humanBones: VRMHumanBones;\n\n  /**\n   * A [[VRMHumanDescription]] that represents properties of the humanoid.\n   */\n  public readonly humanDescription: VRMHumanDescription;\n\n  /**\n   * A [[VRMPose]] that is its default state.\n   * You might use [[VRMHumanoid.setPose]] with this pose to reset its state.\n   */\n  public readonly restPose: VRMPose;\n\n  /**\n   * Create a new [[VRMHumanoid]].\n   * @param boneArray A [[VRMHumanBoneArray]] contains all the bones of the new humanoid\n   * @param humanDescription A [[VRMHumanDescription]] that represents properties of the new humanoid\n   */\n  public constructor(boneArray: VRMHumanBoneArray, humanDescription: VRMHumanDescription) {\n    this.humanBones = this._createHumanBones(boneArray);\n    this.humanDescription = humanDescription;\n\n    this.restPose = this.getPose();\n  }\n\n  /**\n   * Return the current pose of this humanoid as a [[VRMPose]].\n   */\n  public getPose(): VRMPose {\n    const pose: VRMPose = {};\n    Object.keys(this.humanBones).forEach(\n      (vrmBoneName) => {\n        const node = this.getBoneNode(vrmBoneName as VRMSchema.HumanoidBoneName)!;\n\n        // Ignore when there are no bone on the VRMHumanoid\n        if (!node) {\n          return;\n        }\n\n        // When there are two or more bones in a same name, we are not going to overwrite existing one\n        if (pose[vrmBoneName]) {\n          return;\n        }\n\n        pose[vrmBoneName] = {\n          position: node.position.toArray() as RawVector3,\n          rotation: node.quaternion.toArray() as RawVector4,\n        };\n      },\n      {} as VRMPose,\n    );\n    return pose;\n  }\n\n  /**\n   * Let the humanoid do a specified pose.\n   *\n   * @param poseObject A [[VRMPose]] that represents a single pose\n   */\n  public setPose(poseObject: VRMPose): void {\n    Object.keys(poseObject).forEach((boneName) => {\n      const state = poseObject[boneName]!;\n      const node = this.getBoneNode(boneName as VRMSchema.HumanoidBoneName);\n\n      // Ignore when there are no bone that is defined in the pose on the VRMHumanoid\n      if (!node) {\n        return;\n      }\n\n      const restState = this.restPose[boneName];\n      if (!restState) {\n        return;\n      }\n\n      if (state.position) {\n        // 元の状態に戻してから、移動分を追加\n        node.position.set(\n          restState.position![0] + state.position[0],\n          restState.position![1] + state.position[1],\n          restState.position![2] + state.position[2],\n        );\n      }\n      if (state.rotation) {\n        node.quaternion.fromArray(state.rotation);\n      }\n    });\n  }\n\n  /**\n   * Return a bone bound to a specified [[HumanBone]], as a [[VRMHumanBone]].\n   *\n   * See also: [[VRMHumanoid.getBones]]\n   *\n   * @param name Name of the bone you want\n   */\n  public getBone(name: VRMSchema.HumanoidBoneName): VRMHumanBone | undefined {\n    return this.humanBones[name][0] || undefined;\n  }\n\n  /**\n   * Return bones bound to a specified [[HumanBone]], as an array of [[VRMHumanBone]].\n   *\n   * See also: [[VRMHumanoid.getBone]]\n   *\n   * @param name Name of the bone you want\n   */\n  public getBones(name: VRMSchema.HumanoidBoneName): VRMHumanBone[] {\n    return this.humanBones[name];\n  }\n\n  /**\n   * Return a bone bound to a specified [[HumanBone]], as a THREE.Object3D.\n   *\n   * See also: [[VRMHumanoid.getBoneNodes]]\n   *\n   * @param name Name of the bone you want\n   */\n  public getBoneNode(name: VRMSchema.HumanoidBoneName): GLTFNode | null {\n    return (this.humanBones[name][0] && this.humanBones[name][0].node) || null;\n  }\n\n  /**\n   * Return bones bound to a specified [[HumanBone]], as an array of THREE.Object3D.\n   *\n   * See also: [[VRMHumanoid.getBoneNode]]\n   *\n   * @param name Name of the bone you want\n   */\n  public getBoneNodes(name: VRMSchema.HumanoidBoneName): GLTFNode[] {\n    return this.humanBones[name].map((bone) => bone.node);\n  }\n\n  /**\n   * Prepare a [[VRMHumanBones]] from a [[VRMHumanBoneArray]].\n   */\n  private _createHumanBones(boneArray: VRMHumanBoneArray): VRMHumanBones {\n    const bones: VRMHumanBones = Object.values(VRMSchema.HumanoidBoneName).reduce((accum, name) => {\n      accum[name] = [];\n      return accum;\n    }, {});\n\n    boneArray.forEach((bone) => {\n      bones[bone.name].push(bone.bone);\n    });\n\n    return bones;\n  }\n}\n","import * as THREE from 'three';\nimport { VRMSchema } from '../types';\nimport { VRMHumanBone } from './VRMHumanBone';\nimport { VRMHumanBoneArray } from './VRMHumanBoneArray';\nimport { VRMHumanDescription } from './VRMHumanDescription';\nimport { VRMHumanoid } from './VRMHumanoid';\n\n/**\n * An importer that imports a [[VRMHumanoid]] from a VRM extension of a GLTF.\n */\nexport class VRMHumanoidImporter {\n  /**\n   * Import a [[VRMHumanoid]] from a VRM.\n   *\n   * @param gltf A parsed result of GLTF taken from GLTFLoader\n   */\n  public async import(gltf: THREE.GLTF): Promise<VRMHumanoid | null> {\n    const vrmExt: VRMSchema.VRM | undefined = gltf.parser.json.extensions && gltf.parser.json.extensions.VRM;\n    if (!vrmExt) {\n      return null;\n    }\n\n    const schemaHumanoid: VRMSchema.Humanoid | undefined = vrmExt.humanoid;\n    if (!schemaHumanoid) {\n      return null;\n    }\n\n    const humanBoneArray: VRMHumanBoneArray = [];\n    if (schemaHumanoid.humanBones) {\n      await Promise.all(\n        schemaHumanoid.humanBones.map(async (bone) => {\n          if (!bone.bone || !bone.node) {\n            return;\n          }\n\n          const node = await gltf.parser.getDependency('node', bone.node);\n          humanBoneArray.push({\n            name: bone.bone,\n            bone: new VRMHumanBone(node, {\n              axisLength: bone.axisLength,\n              center: bone.center && new THREE.Vector3(bone.center.x, bone.center.y, bone.center.z),\n              max: bone.max && new THREE.Vector3(bone.max.x, bone.max.y, bone.max.z),\n              min: bone.min && new THREE.Vector3(bone.min.x, bone.min.y, bone.min.z),\n              useDefaultValues: bone.useDefaultValues,\n            }),\n          });\n        }),\n      );\n    }\n\n    const humanDescription: VRMHumanDescription = {\n      armStretch: schemaHumanoid.armStretch,\n      legStretch: schemaHumanoid.legStretch,\n      upperArmTwist: schemaHumanoid.upperArmTwist,\n      lowerArmTwist: schemaHumanoid.lowerArmTwist,\n      upperLegTwist: schemaHumanoid.upperLegTwist,\n      lowerLegTwist: schemaHumanoid.lowerLegTwist,\n      feetSpacing: schemaHumanoid.feetSpacing,\n      hasTranslationDoF: schemaHumanoid.hasTranslationDoF,\n    };\n\n    return new VRMHumanoid(humanBoneArray, humanDescription);\n  }\n}\n","export * from './VRMHumanBone';\nexport * from './VRMHumanBones';\nexport * from './VRMHumanDescription';\nexport * from './VRMHumanLimit';\nexport * from './VRMHumanoid';\nexport * from './VRMHumanoidImporter';\n","export * from './VRM';\nexport * from './VRMImporter';\nexport * from './reduceBones';\nexport * from './blendshape';\nexport * from './debug';\nexport * from './firstperson';\nexport * from './humanoid';\nexport * from './lookat';\nexport * from './springbone';\nexport * from './types';\nexport * from './material';\n","/**\n * Evaluate a hermite spline.\n *\n * @param y0 y on start\n * @param y1 y on end\n * @param t0 delta y on start\n * @param t1 delta y on end\n * @param x input value\n */\nconst hermiteSpline = (y0: number, y1: number, t0: number, t1: number, x: number): number => {\n  const xc = x * x * x;\n  const xs = x * x;\n  const dy = y1 - y0;\n  const h01 = -2.0 * xc + 3.0 * xs;\n  const h10 = xc - 2.0 * xs + x;\n  const h11 = xc - xs;\n  return y0 + dy * h01 + t0 * h10 + t1 * h11;\n};\n\n/**\n * Evaluate an AnimationCurve array. See AnimationCurve class of Unity for its details.\n *\n * See: https://docs.unity3d.com/ja/current/ScriptReference/AnimationCurve.html\n *\n * @param arr An array represents a curve\n * @param x An input value\n */\nconst evaluateCurve = (arr: number[], x: number): number => {\n  // -- sanity check -----------------------------------------------------------\n  if (arr.length < 8) {\n    throw new Error('evaluateCurve: Invalid curve detected! (Array length must be 8 at least)');\n  }\n  if (arr.length % 4 !== 0) {\n    throw new Error('evaluateCurve: Invalid curve detected! (Array length must be multiples of 4');\n  }\n\n  // -- check range ------------------------------------------------------------\n  let outNode;\n  for (outNode = 0; ; outNode++) {\n    if (arr.length <= 4 * outNode) {\n      return arr[4 * outNode - 3]; // too further!! assume as \"Clamp\"\n    } else if (x <= arr[4 * outNode]) {\n      break;\n    }\n  }\n\n  const inNode = outNode - 1;\n  if (inNode < 0) {\n    return arr[4 * inNode + 5]; // too behind!! assume as \"Clamp\"\n  }\n\n  // -- calculate local x ------------------------------------------------------\n  const x0 = arr[4 * inNode];\n  const x1 = arr[4 * outNode];\n  const xHermite = (x - x0) / (x1 - x0);\n\n  // -- finally do the hermite spline ------------------------------------------\n  const y0 = arr[4 * inNode + 1];\n  const y1 = arr[4 * outNode + 1];\n  const t0 = arr[4 * inNode + 3];\n  const t1 = arr[4 * outNode + 2];\n  return hermiteSpline(y0, y1, t0, t1, xHermite);\n};\n\n/**\n * This is an equivalent of CurveMapper class defined in UniVRM.\n * Will be used for [[VRMLookAtApplyer]]s, to define behavior of LookAt.\n *\n * See: https://github.com/vrm-c/UniVRM/blob/master/Assets/VRM/UniVRM/Scripts/LookAt/CurveMapper.cs\n */\nexport class CurveMapper {\n  /**\n   * An array represents the curve. See AnimationCurve class of Unity for its details.\n   *\n   * See: https://docs.unity3d.com/ja/current/ScriptReference/AnimationCurve.html\n   */\n  public curve: number[] = [0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 1.0, 0.0];\n\n  /**\n   * The maximum input range of the [[CurveMapper]].\n   */\n  public curveXRangeDegree = 90.0;\n\n  /**\n   * The maximum output value of the [[CurveMapper]].\n   */\n  public curveYRangeDegree = 10.0;\n\n  /**\n   * Create a new [[CurveMapper]].\n   *\n   * @param xRange The maximum input range\n   * @param yRange The maximum output value\n   * @param curve An array represents the curve\n   */\n  constructor(xRange?: number, yRange?: number, curve?: number[]) {\n    if (xRange !== undefined) {\n      this.curveXRangeDegree = xRange;\n    }\n\n    if (yRange !== undefined) {\n      this.curveYRangeDegree = yRange;\n    }\n\n    if (curve !== undefined) {\n      this.curve = curve;\n    }\n  }\n\n  /**\n   * Evaluate an input value and output a mapped value.\n   *\n   * @param src The input value\n   */\n  public map(src: number): number {\n    const clampedSrc = Math.min(Math.max(src, 0.0), this.curveXRangeDegree);\n    const x = clampedSrc / this.curveXRangeDegree;\n    return this.curveYRangeDegree * evaluateCurve(this.curve, x);\n  }\n}\n","import * as THREE from 'three';\nimport { VRMSchema } from '../types';\n\n/**\n * This class is used by [[VRMLookAtHead]], applies look at direction.\n * There are currently two variant of applier: [[VRMLookAtBoneApplyer]] and [[VRMLookAtBlendShapeApplyer]].\n */\nexport abstract class VRMLookAtApplyer {\n  /**\n   * It represents its type of applier.\n   */\n  public abstract readonly type: VRMSchema.FirstPersonLookAtTypeName;\n\n  /**\n   * Apply look at direction to its associated VRM model.\n   *\n   * @param euler `THREE.Euler` object that represents the look at direction\n   */\n  public abstract lookAt(euler: THREE.Euler): void;\n}\n","import * as THREE from 'three';\nimport { VRMBlendShapeProxy } from '../blendshape';\nimport { VRMSchema } from '../types';\nimport { CurveMapper } from './CurveMapper';\nimport { VRMLookAtApplyer } from './VRMLookAtApplyer';\n\n/**\n * This class is used by [[VRMLookAtHead]], applies look at direction to eye blend shapes of a VRM.\n */\nexport class VRMLookAtBlendShapeApplyer extends VRMLookAtApplyer {\n  public readonly type = VRMSchema.FirstPersonLookAtTypeName.BlendShape;\n\n  private readonly _curveHorizontal: CurveMapper;\n  private readonly _curveVerticalDown: CurveMapper;\n  private readonly _curveVerticalUp: CurveMapper;\n\n  private readonly _blendShapeProxy: VRMBlendShapeProxy;\n\n  /**\n   * Create a new VRMLookAtBlendShapeApplyer.\n   *\n   * @param blendShapeProxy A [[VRMBlendShapeProxy]] used by this applier\n   * @param curveHorizontal A [[CurveMapper]] used for transverse direction\n   * @param curveVerticalDown A [[CurveMapper]] used for down direction\n   * @param curveVerticalUp A [[CurveMapper]] used for up direction\n   */\n  constructor(\n    blendShapeProxy: VRMBlendShapeProxy,\n    curveHorizontal: CurveMapper,\n    curveVerticalDown: CurveMapper,\n    curveVerticalUp: CurveMapper,\n  ) {\n    super();\n\n    this._curveHorizontal = curveHorizontal;\n    this._curveVerticalDown = curveVerticalDown;\n    this._curveVerticalUp = curveVerticalUp;\n\n    this._blendShapeProxy = blendShapeProxy;\n  }\n\n  public name(): VRMSchema.FirstPersonLookAtTypeName {\n    return VRMSchema.FirstPersonLookAtTypeName.BlendShape;\n  }\n\n  public lookAt(euler: THREE.Euler): void {\n    const srcX = euler.x;\n    const srcY = euler.y;\n\n    if (srcX < 0.0) {\n      this._blendShapeProxy.setValue(VRMSchema.BlendShapePresetName.Lookup, 0.0);\n      this._blendShapeProxy.setValue(VRMSchema.BlendShapePresetName.Lookdown, this._curveVerticalDown.map(-srcX));\n    } else {\n      this._blendShapeProxy.setValue(VRMSchema.BlendShapePresetName.Lookdown, 0.0);\n      this._blendShapeProxy.setValue(VRMSchema.BlendShapePresetName.Lookup, this._curveVerticalUp.map(srcX));\n    }\n\n    if (srcY < 0.0) {\n      this._blendShapeProxy.setValue(VRMSchema.BlendShapePresetName.Lookleft, 0.0);\n      this._blendShapeProxy.setValue(VRMSchema.BlendShapePresetName.Lookright, this._curveHorizontal.map(-srcY));\n    } else {\n      this._blendShapeProxy.setValue(VRMSchema.BlendShapePresetName.Lookright, 0.0);\n      this._blendShapeProxy.setValue(VRMSchema.BlendShapePresetName.Lookleft, this._curveHorizontal.map(srcY));\n    }\n  }\n}\n","import * as THREE from 'three';\nimport { VRMHumanoid } from '../humanoid';\nimport { GLTFNode, VRMSchema } from '../types';\nimport { CurveMapper } from './CurveMapper';\nimport { VRMLookAtApplyer } from './VRMLookAtApplyer';\nimport { VRMLookAtHead } from './VRMLookAtHead';\n\nconst _euler = new THREE.Euler(0.0, 0.0, 0.0, VRMLookAtHead.EULER_ORDER);\n\n/**\n * This class is used by [[VRMLookAtHead]], applies look at direction to eye bones of a VRM.\n */\nexport class VRMLookAtBoneApplyer extends VRMLookAtApplyer {\n  public readonly type = VRMSchema.FirstPersonLookAtTypeName.Bone;\n\n  private readonly _curveHorizontalInner: CurveMapper;\n  private readonly _curveHorizontalOuter: CurveMapper;\n  private readonly _curveVerticalDown: CurveMapper;\n  private readonly _curveVerticalUp: CurveMapper;\n\n  private readonly _leftEye: GLTFNode | null;\n  private readonly _rightEye: GLTFNode | null;\n\n  /**\n   * Create a new VRMLookAtBoneApplyer.\n   *\n   * @param humanoid A [[VRMHumanoid]] used by this applier\n   * @param curveHorizontalInner A [[CurveMapper]] used for inner transverse direction\n   * @param curveHorizontalOuter A [[CurveMapper]] used for outer transverse direction\n   * @param curveVerticalDown A [[CurveMapper]] used for down direction\n   * @param curveVerticalUp A [[CurveMapper]] used for up direction\n   */\n  constructor(\n    humanoid: VRMHumanoid,\n    curveHorizontalInner: CurveMapper,\n    curveHorizontalOuter: CurveMapper,\n    curveVerticalDown: CurveMapper,\n    curveVerticalUp: CurveMapper,\n  ) {\n    super();\n\n    this._curveHorizontalInner = curveHorizontalInner;\n    this._curveHorizontalOuter = curveHorizontalOuter;\n    this._curveVerticalDown = curveVerticalDown;\n    this._curveVerticalUp = curveVerticalUp;\n\n    this._leftEye = humanoid.getBoneNode(VRMSchema.HumanoidBoneName.LeftEye);\n    this._rightEye = humanoid.getBoneNode(VRMSchema.HumanoidBoneName.RightEye);\n  }\n\n  public lookAt(euler: THREE.Euler): void {\n    const srcX = euler.x;\n    const srcY = euler.y;\n\n    // left\n    if (this._leftEye) {\n      if (srcX < 0.0) {\n        _euler.x = -this._curveVerticalDown.map(-srcX);\n      } else {\n        _euler.x = this._curveVerticalUp.map(srcX);\n      }\n\n      if (srcY < 0.0) {\n        _euler.y = -this._curveHorizontalInner.map(-srcY);\n      } else {\n        _euler.y = this._curveHorizontalOuter.map(srcY);\n      }\n\n      this._leftEye.quaternion.setFromEuler(_euler);\n    }\n\n    // right\n    if (this._rightEye) {\n      if (srcX < 0.0) {\n        _euler.x = -this._curveVerticalDown.map(-srcX);\n      } else {\n        _euler.x = this._curveVerticalUp.map(srcX);\n      }\n\n      if (srcY < 0.0) {\n        _euler.y = -this._curveHorizontalOuter.map(-srcY);\n      } else {\n        _euler.y = this._curveHorizontalInner.map(srcY);\n      }\n\n      this._rightEye.quaternion.setFromEuler(_euler);\n    }\n  }\n}\n","import * as THREE from 'three';\nimport { VRMFirstPerson } from '../firstperson/VRMFirstPerson';\nimport { getWorldQuaternionLite } from '../utils/math';\nimport { VRMLookAtApplyer } from './VRMLookAtApplyer';\n\nconst VECTOR3_FRONT = Object.freeze(new THREE.Vector3(0.0, 0.0, -1.0));\n\nconst _v3A = new THREE.Vector3();\nconst _v3B = new THREE.Vector3();\nconst _v3C = new THREE.Vector3();\nconst _quat = new THREE.Quaternion();\n\n/**\n * A class represents look at of a VRM.\n */\nexport class VRMLookAtHead {\n  public static readonly EULER_ORDER = 'YXZ'; // yaw-pitch-roll\n\n  /**\n   * Associated [[VRMFirstPerson]], will be used for direction calculation.\n   */\n  public readonly firstPerson: VRMFirstPerson;\n\n  /**\n   * Associated [[VRMLookAtApplyer]], its look at direction will be applied to the model using this applier.\n   */\n  public readonly applyer?: VRMLookAtApplyer;\n\n  /**\n   * If this is true, its look at direction will be updated automatically by calling [[VRMLookAtHead.update]] (which is called from [[VRM.update]]).\n   *\n   * See also: [[VRMLookAtHead.target]]\n   */\n  public autoUpdate = true;\n\n  /**\n   * The target object of the look at.\n   * Note that it does not make any sense if [[VRMLookAtHead.autoUpdate]] is disabled.\n   */\n  public target?: THREE.Object3D;\n\n  protected _euler: THREE.Euler = new THREE.Euler(0.0, 0.0, 0.0, VRMLookAtHead.EULER_ORDER);\n\n  /**\n   * Create a new VRMLookAtHead.\n   *\n   * @param firstPerson A [[VRMFirstPerson]] that will be associated with this new VRMLookAtHead\n   * @param applyer A [[VRMLookAtApplyer]] that will be associated with this new VRMLookAtHead\n   */\n  constructor(firstPerson: VRMFirstPerson, applyer?: VRMLookAtApplyer) {\n    this.firstPerson = firstPerson;\n    this.applyer = applyer;\n  }\n\n  /**\n   * Get its look at direction in world coordinate.\n   *\n   * @param target A target `THREE.Vector3`\n   */\n  public getLookAtWorldDirection(target: THREE.Vector3): THREE.Vector3 {\n    const rot = getWorldQuaternionLite(this.firstPerson.firstPersonBone, _quat);\n    return target\n      .copy(VECTOR3_FRONT)\n      .applyEuler(this._euler)\n      .applyQuaternion(rot);\n  }\n\n  /**\n   * Set its look at position.\n   * Note that its result will be instantly overwritten if [[VRMLookAtHead.autoUpdate]] is enabled.\n   *\n   * @param position A target position\n   */\n  public lookAt(position: THREE.Vector3): void {\n    this._calcEuler(this._euler, position);\n\n    if (this.applyer) {\n      this.applyer.lookAt(this._euler);\n    }\n  }\n\n  /**\n   * Update the VRMLookAtHead.\n   * If [[VRMLookAtHead.autoUpdate]] is disabled, it will do nothing.\n   *\n   * @param delta deltaTime\n   */\n  public update(delta: number): void {\n    if (this.target && this.autoUpdate) {\n      this.lookAt(this.target.getWorldPosition(_v3A));\n\n      if (this.applyer) {\n        this.applyer.lookAt(this._euler);\n      }\n    }\n  }\n\n  protected _calcEuler(target: THREE.Euler, position: THREE.Vector3): THREE.Euler {\n    const headPosition = this.firstPerson.getFirstPersonWorldPosition(_v3B);\n\n    // Look at direction in world coordinate\n    const lookAtDir = _v3C\n      .copy(position)\n      .sub(headPosition)\n      .normalize();\n\n    // Transform the direction into local coordinate from the first person bone\n    lookAtDir.applyQuaternion(getWorldQuaternionLite(this.firstPerson.firstPersonBone, _quat).inverse());\n\n    // convert the direction into euler\n    target.x = Math.atan2(lookAtDir.y, Math.sqrt(lookAtDir.x * lookAtDir.x + lookAtDir.z * lookAtDir.z));\n    target.y = Math.atan2(-lookAtDir.x, -lookAtDir.z);\n\n    return target;\n  }\n}\n","import * as THREE from 'three';\nimport { VRMBlendShapeProxy } from '../blendshape';\nimport { VRMFirstPerson } from '../firstperson';\nimport { VRMHumanoid } from '../humanoid';\nimport { VRMSchema } from '../types';\nimport { CurveMapper } from './CurveMapper';\nimport { VRMLookAtApplyer } from './VRMLookAtApplyer';\nimport { VRMLookAtBlendShapeApplyer } from './VRMLookAtBlendShapeApplyer';\nimport { VRMLookAtBoneApplyer } from './VRMLookAtBoneApplyer';\nimport { VRMLookAtHead } from './VRMLookAtHead';\n\n/**\n * An importer that imports a [[VRMLookAtHead]] from a VRM extension of a GLTF.\n */\nexport class VRMLookAtImporter {\n  /**\n   * Import a [[VRMLookAtHead]] from a VRM.\n   *\n   * @param gltf A parsed result of GLTF taken from GLTFLoader\n   * @param blendShapeProxy A [[VRMBlendShapeProxy]] instance that represents the VRM\n   * @param humanoid A [[VRMHumanoid]] instance that represents the VRM\n   */\n  public import(\n    gltf: THREE.GLTF,\n    firstPerson: VRMFirstPerson,\n    blendShapeProxy: VRMBlendShapeProxy,\n    humanoid: VRMHumanoid,\n  ): VRMLookAtHead | null {\n    const vrmExt: VRMSchema.VRM | undefined = gltf.parser.json.extensions && gltf.parser.json.extensions.VRM;\n    if (!vrmExt) {\n      return null;\n    }\n\n    const schemaFirstPerson: VRMSchema.FirstPerson | undefined = vrmExt.firstPerson;\n    if (!schemaFirstPerson) {\n      return null;\n    }\n\n    const applyer = this._importApplyer(schemaFirstPerson, blendShapeProxy, humanoid);\n    return new VRMLookAtHead(firstPerson, applyer || undefined);\n  }\n\n  protected _importApplyer(\n    schemaFirstPerson: VRMSchema.FirstPerson,\n    blendShapeProxy: VRMBlendShapeProxy,\n    humanoid: VRMHumanoid,\n  ): VRMLookAtApplyer | null {\n    const lookAtHorizontalInner = schemaFirstPerson.lookAtHorizontalInner;\n    const lookAtHorizontalOuter = schemaFirstPerson.lookAtHorizontalOuter;\n    const lookAtVerticalDown = schemaFirstPerson.lookAtVerticalDown;\n    const lookAtVerticalUp = schemaFirstPerson.lookAtVerticalUp;\n\n    switch (schemaFirstPerson.lookAtTypeName) {\n      case VRMSchema.FirstPersonLookAtTypeName.Bone: {\n        if (\n          lookAtHorizontalInner === undefined ||\n          lookAtHorizontalOuter === undefined ||\n          lookAtVerticalDown === undefined ||\n          lookAtVerticalUp === undefined\n        ) {\n          return null;\n        } else {\n          return new VRMLookAtBoneApplyer(\n            humanoid,\n            this._importCurveMapperBone(lookAtHorizontalInner),\n            this._importCurveMapperBone(lookAtHorizontalOuter),\n            this._importCurveMapperBone(lookAtVerticalDown),\n            this._importCurveMapperBone(lookAtVerticalUp),\n          );\n        }\n      }\n      case VRMSchema.FirstPersonLookAtTypeName.BlendShape: {\n        if (lookAtHorizontalOuter === undefined || lookAtVerticalDown === undefined || lookAtVerticalUp === undefined) {\n          return null;\n        } else {\n          return new VRMLookAtBlendShapeApplyer(\n            blendShapeProxy,\n            this._importCurveMapperBlendShape(lookAtHorizontalOuter),\n            this._importCurveMapperBlendShape(lookAtVerticalDown),\n            this._importCurveMapperBlendShape(lookAtVerticalUp),\n          );\n        }\n      }\n      default: {\n        return null;\n      }\n    }\n  }\n\n  private _importCurveMapperBone(map: VRMSchema.FirstPersonDegreeMap): CurveMapper {\n    return new CurveMapper(\n      typeof map.xRange === 'number' ? THREE.Math.DEG2RAD * map.xRange : undefined,\n      typeof map.yRange === 'number' ? THREE.Math.DEG2RAD * map.yRange : undefined,\n      map.curve,\n    );\n  }\n\n  private _importCurveMapperBlendShape(map: VRMSchema.FirstPersonDegreeMap): CurveMapper {\n    return new CurveMapper(\n      typeof map.xRange === 'number' ? THREE.Math.DEG2RAD * map.xRange : undefined,\n      map.yRange,\n      map.curve,\n    );\n  }\n}\n","export * from './CurveMapper';\nexport * from './VRMLookAtApplyer';\nexport * from './VRMLookAtBlendShapeApplyer';\nexport * from './VRMLookAtBoneApplyer';\nexport * from './VRMLookAtHead';\nexport * from './VRMLookAtImporter';\n","/* tslint:disable:member-ordering */\n\nimport * as THREE from 'three';\nimport { getTexelDecodingFunction } from './getTexelDecodingFunction';\nimport vertexShader from './shaders/mtoon.vert';\nimport fragmentShader from './shaders/mtoon.frag';\n\nconst TAU = 2.0 * Math.PI;\n\nexport interface MToonParameters extends THREE.ShaderMaterialParameters {\n  mToonVersion?: number; // _MToonVersion\n\n  cutoff?: number; // _Cutoff\n  color?: THREE.Vector4; // rgb of _Color\n  shadeColor?: THREE.Vector4; // _ShadeColor\n  map?: THREE.Texture; // _MainTex\n  mainTex?: THREE.Texture; // _MainTex (will be renamed to map)\n  mainTex_ST?: THREE.Vector4; // _MainTex_ST\n  shadeTexture?: THREE.Texture; // _ShadeTexture\n  bumpScale?: number; // _BumpScale\n  normalMap?: THREE.Texture; // _BumpMap\n  bumpMap?: THREE.Texture; // _BumpMap (will be renamed to normalMap)\n  receiveShadowRate?: number; // _ReceiveShadowRate\n  receiveShadowTexture?: THREE.Texture; // _ReceiveShadowTexture\n  shadingGradeRate?: number; // _ShadingGradeRate\n  shadingGradeTexture?: THREE.Texture; // _ShadingGradeTexture\n  shadeShift?: number; // _ShadeShift\n  shadeToony?: number; // _ShadeToony\n  lightColorAttenuation?: number; // _LightColorAttenuation\n  indirectLightIntensity?: number; // _IndirectLightIntensity\n  rimTexture?: THREE.Texture; // _RimTexture\n  rimColor?: THREE.Vector4; // _RimColor\n  rimLightingMix?: number; // _RimLightingMix\n  rimFresnelPower?: number; // _RimFresnelPower\n  rimLift?: number; // _RimLift\n  sphereAdd?: THREE.Texture; // _SphereAdd\n  emissionColor?: THREE.Vector4; // _EmissionColor\n  emissiveMap?: THREE.Texture; // _EmissionMap\n  emissionMap?: THREE.Texture; // _EmissionMap (will be renamed to emissiveMap)\n  outlineWidthTexture?: THREE.Texture; // _OutlineWidthTexture\n  outlineWidth?: number; // _OutlineWidth\n  outlineScaledMaxDistance?: number; // _OutlineScaledMaxDistance\n  outlineColor?: THREE.Vector4; // _OutlineColor\n  outlineLightingMix?: number; // _OutlineLightingMix\n  uvAnimMaskTexture?: THREE.Texture; // _UvAnimMaskTexture\n  uvAnimScrollX?: number; // _UvAnimScrollX\n  uvAnimScrollY?: number; // _UvAnimScrollY\n  uvAnimRotation?: number; // _uvAnimRotation\n\n  debugMode?: MToonMaterialDebugMode | number; // _DebugMode\n  blendMode?: MToonMaterialRenderMode | number; // _BlendMode\n  outlineWidthMode?: MToonMaterialOutlineWidthMode | number; // OutlineWidthMode\n  outlineColorMode?: MToonMaterialOutlineColorMode | number; // OutlineColorMode\n  cullMode?: MToonMaterialCullMode | number; // _CullMode\n  outlineCullMode?: MToonMaterialCullMode | number; // _OutlineCullMode\n  srcBlend?: number; // _SrcBlend\n  dstBlend?: number; // _DstBlend\n  zWrite?: number; // _ZWrite (will be renamed to depthWrite)\n\n  isOutline?: boolean;\n}\n\nexport enum MToonMaterialCullMode {\n  Off,\n  Front,\n  Back,\n}\n\nexport enum MToonMaterialDebugMode {\n  None,\n  Normal,\n  LitShadeRate,\n  UV,\n}\n\nexport enum MToonMaterialOutlineColorMode {\n  FixedColor,\n  MixedLighting,\n}\n\nexport enum MToonMaterialOutlineWidthMode {\n  None,\n  WorldCoordinates,\n  ScreenCoordinates,\n}\n\nexport enum MToonMaterialRenderMode {\n  Opaque,\n  Cutout,\n  Transparent,\n  TransparentWithZWrite,\n}\n\n/**\n * MToon is a material specification that has various features.\n * The spec and implementation are originally founded for Unity engine and this is a port of the material.\n *\n * See: https://github.com/Santarh/MToon\n */\nexport class MToonMaterial extends THREE.ShaderMaterial {\n  /**\n   * Readonly boolean that indicates this is a [[MToonMaterial]].\n   */\n  public readonly isMToonMaterial: boolean = true;\n\n  public cutoff = 0.5; // _Cutoff\n  public color: THREE.Vector4 = new THREE.Vector4(1.0, 1.0, 1.0, 1.0); // _Color\n  public shadeColor: THREE.Vector4 = new THREE.Vector4(0.97, 0.81, 0.86, 1.0); // _ShadeColor\n  public map: THREE.Texture | null = null; // _MainTex\n  public mainTex_ST: THREE.Vector4 = new THREE.Vector4(0.0, 0.0, 1.0, 1.0); // _MainTex_ST\n  public shadeTexture: THREE.Texture | null = null; // _ShadeTexture\n  // public shadeTexture_ST: THREE.Vector4 = new THREE.Vector4(0.0, 0.0, 1.0, 1.0); // _ShadeTexture_ST (unused)\n  public bumpScale = 1.0; // _BumpScale\n  public normalMap: THREE.Texture | null = null; // _BumpMap. again, THIS IS _BumpMap\n  // public bumpMap_ST: THREE.Vector4 = new THREE.Vector4(0.0, 0.0, 1.0, 1.0); // _BumpMap_ST (unused)\n  public receiveShadowRate = 1.0; // _ReceiveShadowRate\n  public receiveShadowTexture: THREE.Texture | null = null; // _ReceiveShadowTexture\n  // public receiveShadowTexture_ST: THREE.Vector4 = new THREE.Vector4(0.0, 0.0, 1.0, 1.0); // _ReceiveShadowTexture_ST (unused)\n  public shadingGradeRate = 1.0; // _ShadingGradeRate\n  public shadingGradeTexture: THREE.Texture | null = null; // _ShadingGradeTexture\n  // public shadingGradeTexture_ST: THREE.Vector4 = new THREE.Vector4(0.0, 0.0, 1.0, 1.0); // _ShadingGradeTexture_ST (unused)\n  public shadeShift = 0.0; // _ShadeShift\n  public shadeToony = 0.9; // _ShadeToony\n  public lightColorAttenuation = 0.0; // _LightColorAttenuation\n  public indirectLightIntensity = 0.1; // _IndirectLightIntensity\n  public rimTexture: THREE.Texture | null = null; // _RimTexture\n  public rimColor: THREE.Vector4 = new THREE.Vector4(0.0, 0.0, 0.0, 1.0); // _RimColor\n  public rimLightingMix = 0.0; // _RimLightingMix\n  public rimFresnelPower = 1.0; // _RimFresnelPower\n  public rimLift = 0.0; // _RimLift\n  public sphereAdd: THREE.Texture | null = null; // _SphereAdd\n  // public sphereAdd_ST: THREE.Vector4 = new THREE.Vector4(0.0, 0.0, 1.0, 1.0); // _SphereAdd_ST (unused)\n  public emissionColor: THREE.Vector4 = new THREE.Vector4(0.0, 0.0, 0.0, 1.0); // _EmissionColor\n  public emissiveMap: THREE.Texture | null = null; // _EmissionMap\n  // public emissionMap_ST: THREE.Vector4 = new THREE.Vector4(0.0, 0.0, 1.0, 1.0); // _EmissionMap_ST (unused)\n  public outlineWidthTexture: THREE.Texture | null = null; // _OutlineWidthTexture\n  // public outlineWidthTexture_ST: THREE.Vector4 = new THREE.Vector4(0.0, 0.0, 1.0, 1.0); // _OutlineWidthTexture_ST (unused)\n  public outlineWidth = 0.5; // _OutlineWidth\n  public outlineScaledMaxDistance = 1.0; // _OutlineScaledMaxDistance\n  public outlineColor: THREE.Vector4 = new THREE.Vector4(0.0, 0.0, 0.0, 1.0); // _OutlineColor\n  public outlineLightingMix = 1.0; // _OutlineLightingMix\n  public uvAnimMaskTexture: THREE.Texture | null = null; // _UvAnimMaskTexture\n  public uvAnimScrollX = 0.0; // _UvAnimScrollX\n  public uvAnimScrollY = 0.0; // _UvAnimScrollY\n  public uvAnimRotation = 0.0; // _uvAnimRotation\n\n  public shouldApplyUniforms = true; // when this is true, applyUniforms effects\n\n  private _debugMode: MToonMaterialDebugMode = MToonMaterialDebugMode.None; // _DebugMode\n  private _blendMode: MToonMaterialRenderMode = MToonMaterialRenderMode.Opaque; // _BlendMode\n  private _outlineWidthMode: MToonMaterialOutlineWidthMode = MToonMaterialOutlineWidthMode.None; // _OutlineWidthMode\n  private _outlineColorMode: MToonMaterialOutlineColorMode = MToonMaterialOutlineColorMode.FixedColor; // _OutlineColorMode\n  private _cullMode: MToonMaterialCullMode = MToonMaterialCullMode.Back; // _CullMode\n  private _outlineCullMode: MToonMaterialCullMode = MToonMaterialCullMode.Front; // _OutlineCullMode\n  // public srcBlend: number = 1.0; // _SrcBlend (is not supported)\n  // public dstBlend: number = 0.0; // _DstBlend (is not supported)\n  // public zWrite: number = 1.0; // _ZWrite (will be converted to depthWrite)\n\n  private _isOutline = false;\n\n  private readonly _colorSpaceGamma: boolean;\n\n  private _uvAnimOffsetX = 0.0;\n  private _uvAnimOffsetY = 0.0;\n  private _uvAnimPhase = 0.0;\n\n  // TODO: ここにcolorSpaceGammaあるのダサい\n  constructor(colorSpaceGamma: boolean, parameters?: MToonParameters) {\n    super();\n\n    this._colorSpaceGamma = colorSpaceGamma;\n\n    if (parameters === undefined) {\n      parameters = {};\n    }\n\n    // == these parameter has no compatibility with this implementation ========\n    [\n      'mToonVersion',\n      'shadeTexture_ST',\n      'bumpMap_ST',\n      'receiveShadowTexture_ST',\n      'shadingGradeTexture_ST',\n      'sphereAdd_ST',\n      'emissionMap_ST',\n      'outlineWidthTexture_ST',\n      'srcBlend',\n      'dstBlend',\n    ].forEach((key) => {\n      if ((parameters as any)[key] !== undefined) {\n        // console.warn(`THREE.${this.type}: The parameter \"${key}\" is not supported.`);\n        delete (parameters as any)[key];\n      }\n    });\n\n    // == enabling bunch of stuff ==============================================\n    parameters.fog = true;\n    parameters.lights = true;\n    parameters.clipping = true;\n\n    parameters.skinning = parameters.skinning || false;\n    parameters.morphTargets = parameters.morphTargets || false;\n    parameters.morphNormals = parameters.morphNormals || false;\n\n    // == uniforms =============================================================\n    parameters.uniforms = THREE.UniformsUtils.merge([\n      THREE.UniformsLib.common, // map\n      THREE.UniformsLib.normalmap, // normalMap\n      THREE.UniformsLib.emissivemap, // emissiveMap\n      THREE.UniformsLib.fog,\n      THREE.UniformsLib.lights,\n      {\n        cutoff: { value: 0.5 },\n        color: { value: new THREE.Color(1.0, 1.0, 1.0) },\n        colorAlpha: { value: 1.0 },\n        shadeColor: { value: new THREE.Color(0.97, 0.81, 0.86) },\n        mainTex_ST: { value: new THREE.Vector4(0.0, 0.0, 1.0, 1.0) },\n        shadeTexture: { value: null },\n        bumpScale: { value: 1.0 },\n        receiveShadowRate: { value: 1.0 },\n        receiveShadowTexture: { value: null },\n        shadingGradeRate: { value: 1.0 },\n        shadingGradeTexture: { value: null },\n        shadeShift: { value: 0.0 },\n        shadeToony: { value: 0.9 },\n        lightColorAttenuation: { value: 0.0 },\n        indirectLightIntensity: { value: 0.1 },\n        rimTexture: { value: null },\n        rimColor: { value: new THREE.Color(0.0, 0.0, 0.0) },\n        rimLightingMix: { value: 0.0 },\n        rimFresnelPower: { value: 1.0 },\n        rimLift: { value: 0.0 },\n        sphereAdd: { value: null },\n        emissionColor: { value: new THREE.Color(0.0, 0.0, 0.0) },\n        outlineWidthTexture: { value: null },\n        outlineWidth: { value: 0.5 },\n        outlineScaledMaxDistance: { value: 1.0 },\n        outlineColor: { value: new THREE.Color(0.0, 0.0, 0.0) },\n        outlineLightingMix: { value: 1.0 },\n        uvAnimMaskTexture: { value: null },\n        uvAnimOffsetX: { value: 0.0 },\n        uvAnimOffsetY: { value: 0.0 },\n        uvAnimTheta: { value: 0.0 },\n      },\n    ]);\n\n    // == finally compile the shader program ===================================\n    this.setValues(parameters);\n\n    // == update shader stuff ==================================================\n    this._updateShaderCode();\n    this._applyUniforms();\n  }\n\n  get mainTex(): THREE.Texture | null {\n    return this.map;\n  }\n\n  set mainTex(t: THREE.Texture | null) {\n    this.map = t;\n  }\n\n  get bumpMap(): THREE.Texture | null {\n    return this.normalMap;\n  }\n\n  set bumpMap(t: THREE.Texture | null) {\n    this.normalMap = t;\n  }\n\n  get emissionMap(): THREE.Texture | null {\n    return this.emissiveMap;\n  }\n\n  set emissionMap(t: THREE.Texture | null) {\n    this.emissiveMap = t;\n  }\n\n  get blendMode(): MToonMaterialRenderMode {\n    return this._blendMode;\n  }\n\n  set blendMode(m: MToonMaterialRenderMode) {\n    this._blendMode = m;\n\n    this.depthWrite = this._blendMode !== MToonMaterialRenderMode.Transparent;\n    this.transparent =\n      this._blendMode === MToonMaterialRenderMode.Transparent ||\n      this._blendMode === MToonMaterialRenderMode.TransparentWithZWrite;\n    this._updateShaderCode();\n  }\n\n  get debugMode(): MToonMaterialDebugMode {\n    return this._debugMode;\n  }\n\n  set debugMode(m: MToonMaterialDebugMode) {\n    this._debugMode = m;\n\n    this._updateShaderCode();\n  }\n\n  get outlineWidthMode(): MToonMaterialOutlineWidthMode {\n    return this._outlineWidthMode;\n  }\n\n  set outlineWidthMode(m: MToonMaterialOutlineWidthMode) {\n    this._outlineWidthMode = m;\n\n    this._updateShaderCode();\n  }\n\n  get outlineColorMode(): MToonMaterialOutlineColorMode {\n    return this._outlineColorMode;\n  }\n\n  set outlineColorMode(m: MToonMaterialOutlineColorMode) {\n    this._outlineColorMode = m;\n\n    this._updateShaderCode();\n  }\n\n  get cullMode(): MToonMaterialCullMode {\n    return this._cullMode;\n  }\n\n  set cullMode(m: MToonMaterialCullMode) {\n    this._cullMode = m;\n\n    this._updateCullFace();\n  }\n\n  get outlineCullMode(): MToonMaterialCullMode {\n    return this._outlineCullMode;\n  }\n\n  set outlineCullMode(m: MToonMaterialCullMode) {\n    this._outlineCullMode = m;\n\n    this._updateCullFace();\n  }\n\n  get zWrite(): number {\n    return this.depthWrite ? 1 : 0;\n  }\n\n  set zWrite(i: number) {\n    this.depthWrite = 0.5 <= i;\n  }\n\n  get isOutline(): boolean {\n    return this._isOutline;\n  }\n\n  set isOutline(b: boolean) {\n    this._isOutline = b;\n\n    this._updateShaderCode();\n    this._updateCullFace();\n  }\n\n  /**\n   * Update this material.\n   * Usually this will be called via [[VRM.update]] so you don't have to call this manually.\n   *\n   * @param delta deltaTime since last update\n   */\n  public updateVRMMaterials(delta: number): void {\n    this._uvAnimOffsetX = this._uvAnimOffsetX + delta * this.uvAnimScrollX;\n    this._uvAnimOffsetY = this._uvAnimOffsetY + delta * this.uvAnimScrollY;\n    this._uvAnimPhase = this._uvAnimPhase + delta * this.uvAnimRotation;\n\n    this._applyUniforms();\n  }\n\n  public copy(source: this): this {\n    super.copy(source);\n\n    // == copy members =========================================================\n    this.cutoff = source.cutoff;\n    this.color.copy(source.color);\n    this.shadeColor.copy(source.shadeColor);\n    this.map = source.map;\n    this.mainTex_ST.copy(source.mainTex_ST);\n    this.shadeTexture = source.shadeTexture;\n    this.bumpScale = source.bumpScale;\n    this.normalMap = source.normalMap;\n    this.receiveShadowRate = source.receiveShadowRate;\n    this.receiveShadowTexture = source.receiveShadowTexture;\n    this.shadingGradeRate = source.shadingGradeRate;\n    this.shadingGradeTexture = source.shadingGradeTexture;\n    this.shadeShift = source.shadeShift;\n    this.shadeToony = source.shadeToony;\n    this.lightColorAttenuation = source.lightColorAttenuation;\n    this.indirectLightIntensity = source.indirectLightIntensity;\n    this.rimTexture = source.rimTexture;\n    this.rimColor.copy(source.rimColor);\n    this.rimLightingMix = source.rimLightingMix;\n    this.rimFresnelPower = source.rimFresnelPower;\n    this.rimLift = source.rimLift;\n    this.sphereAdd = source.sphereAdd;\n    this.emissionColor.copy(source.emissionColor);\n    this.emissiveMap = source.emissiveMap;\n    this.outlineWidthTexture = source.outlineWidthTexture;\n    this.outlineWidth = source.outlineWidth;\n    this.outlineScaledMaxDistance = source.outlineScaledMaxDistance;\n    this.outlineColor.copy(source.outlineColor);\n    this.outlineLightingMix = source.outlineLightingMix;\n    this.uvAnimMaskTexture = source.uvAnimMaskTexture;\n    this.uvAnimScrollX = source.uvAnimScrollX;\n    this.uvAnimScrollY = source.uvAnimScrollY;\n    this.uvAnimRotation = source.uvAnimRotation;\n\n    this.debugMode = source.debugMode;\n    this.blendMode = source.blendMode;\n    this.outlineWidthMode = source.outlineWidthMode;\n    this.outlineColorMode = source.outlineColorMode;\n    this.cullMode = source.cullMode;\n    this.outlineCullMode = source.outlineCullMode;\n\n    this.isOutline = source.isOutline;\n\n    return this;\n  }\n\n  /**\n   * Apply updated uniform variables.\n   */\n  private _applyUniforms(): void {\n    this.uniforms.uvAnimOffsetX.value = this._uvAnimOffsetX;\n    this.uniforms.uvAnimOffsetY.value = this._uvAnimOffsetY;\n    this.uniforms.uvAnimTheta.value = TAU * this._uvAnimPhase;\n\n    if (!this.shouldApplyUniforms) {\n      return;\n    }\n    this.shouldApplyUniforms = false;\n\n    this.uniforms.cutoff.value = this.cutoff;\n    this.uniforms.color.value.setRGB(this.color.x, this.color.y, this.color.z);\n    if (!this._colorSpaceGamma) {\n      this.uniforms.color.value.convertSRGBToLinear();\n    }\n    this.uniforms.colorAlpha.value = this.color.w;\n    this.uniforms.shadeColor.value.setRGB(this.shadeColor.x, this.shadeColor.y, this.shadeColor.z);\n    if (!this._colorSpaceGamma) {\n      this.uniforms.shadeColor.value.convertSRGBToLinear();\n    }\n    this.uniforms.map.value = this.map;\n    this.uniforms.mainTex_ST.value.copy(this.mainTex_ST);\n    this.uniforms.shadeTexture.value = this.shadeTexture;\n    this.uniforms.bumpScale.value = this.bumpScale;\n    this.uniforms.normalMap.value = this.normalMap;\n    this.uniforms.receiveShadowRate.value = this.receiveShadowRate;\n    this.uniforms.receiveShadowTexture.value = this.receiveShadowTexture;\n    this.uniforms.shadingGradeRate.value = this.shadingGradeRate;\n    this.uniforms.shadingGradeTexture.value = this.shadingGradeTexture;\n    this.uniforms.shadeShift.value = this.shadeShift;\n    this.uniforms.shadeToony.value = this.shadeToony;\n    this.uniforms.lightColorAttenuation.value = this.lightColorAttenuation;\n    this.uniforms.indirectLightIntensity.value = this.indirectLightIntensity;\n    this.uniforms.rimTexture.value = this.rimTexture;\n    this.uniforms.rimColor.value.setRGB(this.rimColor.x, this.rimColor.y, this.rimColor.z);\n    if (!this._colorSpaceGamma) {\n      this.uniforms.rimColor.value.convertSRGBToLinear();\n    }\n    this.uniforms.rimLightingMix.value = this.rimLightingMix;\n    this.uniforms.rimFresnelPower.value = this.rimFresnelPower;\n    this.uniforms.rimLift.value = this.rimLift;\n    this.uniforms.sphereAdd.value = this.sphereAdd;\n    this.uniforms.emissionColor.value.setRGB(this.emissionColor.x, this.emissionColor.y, this.emissionColor.z);\n    if (!this._colorSpaceGamma) {\n      this.uniforms.emissionColor.value.convertSRGBToLinear();\n    }\n    this.uniforms.emissiveMap.value = this.emissiveMap;\n    this.uniforms.outlineWidthTexture.value = this.outlineWidthTexture;\n    this.uniforms.outlineWidth.value = this.outlineWidth;\n    this.uniforms.outlineScaledMaxDistance.value = this.outlineScaledMaxDistance;\n    this.uniforms.outlineColor.value.setRGB(this.outlineColor.x, this.outlineColor.y, this.outlineColor.z);\n    if (!this._colorSpaceGamma) {\n      this.uniforms.outlineColor.value.convertSRGBToLinear();\n    }\n    this.uniforms.outlineLightingMix.value = this.outlineLightingMix;\n    this.uniforms.uvAnimMaskTexture.value = this.uvAnimMaskTexture;\n\n    this._updateCullFace();\n  }\n\n  private _updateShaderCode(): void {\n    this.defines = {\n      OUTLINE: this._isOutline,\n      BLENDMODE_OPAQUE: this._blendMode === MToonMaterialRenderMode.Opaque,\n      BLENDMODE_CUTOUT: this._blendMode === MToonMaterialRenderMode.Cutout,\n      BLENDMODE_TRANSPARENT:\n        this._blendMode === MToonMaterialRenderMode.Transparent ||\n        this._blendMode === MToonMaterialRenderMode.TransparentWithZWrite,\n      USE_SHADETEXTURE: this.shadeTexture !== null,\n      USE_RECEIVESHADOWTEXTURE: this.receiveShadowTexture !== null,\n      USE_SHADINGGRADETEXTURE: this.shadingGradeTexture !== null,\n      USE_RIMTEXTURE: this.rimTexture !== null,\n      USE_SPHEREADD: this.sphereAdd !== null,\n      USE_OUTLINEWIDTHTEXTURE: this.outlineWidthTexture !== null,\n      USE_UVANIMMASKTEXTURE: this.uvAnimMaskTexture !== null,\n      DEBUG_NORMAL: this._debugMode === MToonMaterialDebugMode.Normal,\n      DEBUG_LITSHADERATE: this._debugMode === MToonMaterialDebugMode.LitShadeRate,\n      DEBUG_UV: this._debugMode === MToonMaterialDebugMode.UV,\n      OUTLINE_WIDTH_WORLD: this._outlineWidthMode === MToonMaterialOutlineWidthMode.WorldCoordinates,\n      OUTLINE_WIDTH_SCREEN: this._outlineWidthMode === MToonMaterialOutlineWidthMode.ScreenCoordinates,\n      OUTLINE_COLOR_FIXED: this._outlineColorMode === MToonMaterialOutlineColorMode.FixedColor,\n      OUTLINE_COLOR_MIXED: this._outlineColorMode === MToonMaterialOutlineColorMode.MixedLighting,\n    };\n\n    // == texture encodings ====================================================\n    const encodings =\n      (this.shadeTexture !== null\n        ? getTexelDecodingFunction('shadeTextureTexelToLinear', this.shadeTexture.encoding) + '\\n'\n        : '') +\n      (this.sphereAdd !== null\n        ? getTexelDecodingFunction('sphereAddTexelToLinear', this.sphereAdd.encoding) + '\\n'\n        : '');\n\n    // == generate shader code =================================================\n    this.vertexShader = vertexShader;\n    this.fragmentShader = encodings + fragmentShader;\n\n    // == set needsUpdate flag =================================================\n    this.needsUpdate = true;\n  }\n\n  private _updateCullFace(): void {\n    if (!this.isOutline) {\n      if (this.cullMode === MToonMaterialCullMode.Off) {\n        this.side = THREE.DoubleSide;\n      } else if (this.cullMode === MToonMaterialCullMode.Front) {\n        this.side = THREE.BackSide;\n      } else if (this.cullMode === MToonMaterialCullMode.Back) {\n        this.side = THREE.FrontSide;\n      }\n    } else {\n      if (this.outlineCullMode === MToonMaterialCullMode.Off) {\n        this.side = THREE.DoubleSide;\n      } else if (this.outlineCullMode === MToonMaterialCullMode.Front) {\n        this.side = THREE.BackSide;\n      } else if (this.outlineCullMode === MToonMaterialCullMode.Back) {\n        this.side = THREE.FrontSide;\n      }\n    }\n  }\n}\n","import * as THREE from 'three';\nimport { GLTFMesh, GLTFPrimitive, VRMSchema } from '../types';\nimport { MToonMaterial, MToonMaterialOutlineWidthMode, MToonMaterialRenderMode } from './MToonMaterial';\nimport { VRMUnlitMaterial, VRMUnlitMaterialRenderType } from './VRMUnlitMaterial';\n\n/**\n * Options for a [[VRMMaterialImporter]] instance.\n */\nexport interface VRMMaterialImporterOptions {\n  /**\n   * Whether the workflow should be linear or gamma.\n   *\n   * See also: https://threejs.org/docs/#api/en/renderers/WebGLRenderer.gammaOutput\n   */\n  colorSpaceGamma?: boolean;\n\n  /**\n   * A function that returns a `Promise` of environment map texture.\n   * The importer will attempt to call this function when it have to use an envmap.\n   */\n  requestEnvMap?: () => Promise<THREE.Texture | null>;\n}\n\n/**\n * An importer that imports VRM materials from a VRM extension of a GLTF.\n */\nexport class VRMMaterialImporter {\n  private readonly _colorSpaceGamma: boolean;\n  private readonly _requestEnvMap?: () => Promise<THREE.Texture | null>;\n\n  /**\n   * Create a new VRMMaterialImporter.\n   *\n   * @param options Options of the VRMMaterialImporter\n   */\n  constructor(options: VRMMaterialImporterOptions = {}) {\n    this._colorSpaceGamma = options.colorSpaceGamma || true;\n    this._requestEnvMap = options.requestEnvMap;\n  }\n\n  /**\n   * Convert all the materials of given GLTF based on VRM extension field `materialProperties`.\n   *\n   * @param gltf A parsed result of GLTF taken from GLTFLoader\n   */\n  public async convertGLTFMaterials(gltf: THREE.GLTF): Promise<THREE.Material[] | null> {\n    const vrmExt: VRMSchema.VRM | undefined = gltf.parser.json.extensions && gltf.parser.json.extensions.VRM;\n    if (!vrmExt) {\n      return null;\n    }\n\n    const materialProperties: VRMSchema.Material[] | undefined = vrmExt.materialProperties;\n    if (!materialProperties) {\n      return null;\n    }\n\n    const meshesMap: GLTFMesh[] = await gltf.parser.getDependencies('mesh');\n    const materialList: { [vrmMaterialIndex: number]: { surface: THREE.Material; outline?: THREE.Material } } = {};\n    const materials: THREE.Material[] = []; // result\n\n    await Promise.all(\n      meshesMap.map(async (mesh, meshIndex) => {\n        const primitives: GLTFPrimitive[] =\n          mesh.type === 'Group' ? (mesh.children as GLTFPrimitive[]) : [mesh as GLTFPrimitive];\n        await Promise.all(\n          primitives.map(async (primitive, primitiveIndex) => {\n            // if primitives material is not an array, make it an array\n            if (!Array.isArray(primitive.material)) {\n              primitive.material = [primitive.material];\n              (primitive.geometry as THREE.BufferGeometry).addGroup(\n                0,\n                (primitive.geometry as THREE.BufferGeometry).index.count,\n                0,\n              );\n            }\n\n            // create / push to cache (or pop from cache) vrm materials\n            const vrmMaterialIndex = gltf.parser.json.meshes![meshIndex].primitives[primitiveIndex].material!;\n\n            let props = materialProperties[vrmMaterialIndex];\n            if (!props) {\n              console.warn(\n                `VRMMaterialImporter: There are no material definition for material #${vrmMaterialIndex} on VRM extension.`,\n              );\n              props = { shader: 'VRM_USE_GLTFSHADER' }; // fallback\n            }\n\n            let vrmMaterials: { surface: THREE.Material; outline?: THREE.Material };\n            if (materialList[vrmMaterialIndex]) {\n              vrmMaterials = materialList[vrmMaterialIndex];\n            } else {\n              vrmMaterials = await this.createVRMMaterials(primitive.material[0], props, gltf);\n              materialList[vrmMaterialIndex] = vrmMaterials;\n\n              materials.push(vrmMaterials.surface);\n              if (vrmMaterials.outline) {\n                materials.push(vrmMaterials.outline);\n              }\n            }\n\n            // surface\n            primitive.material[0] = vrmMaterials.surface;\n\n            // envmap\n            if (this._requestEnvMap) {\n              this._requestEnvMap().then((envMap) => {\n                (vrmMaterials.surface as any).envMap = envMap;\n                vrmMaterials.surface.needsUpdate = true;\n              });\n            }\n\n            // render order\n            primitive.renderOrder = props.renderQueue || 2000;\n\n            // outline (\"2 pass shading using groups\" trick here)\n            if (vrmMaterials.outline) {\n              primitive.material[1] = vrmMaterials.outline;\n              (primitive.geometry as THREE.BufferGeometry).addGroup(\n                0,\n                (primitive.geometry as THREE.BufferGeometry).index.count,\n                1,\n              );\n            }\n          }),\n        );\n      }),\n    );\n\n    return materials;\n  }\n\n  public async createVRMMaterials(\n    originalMaterial: THREE.Material,\n    vrmProps: VRMSchema.Material,\n    gltf: THREE.GLTF,\n  ): Promise<{\n    surface: THREE.Material;\n    outline?: THREE.Material;\n  }> {\n    let newSurface: THREE.Material | undefined;\n    let newOutline: THREE.Material | undefined;\n\n    if (vrmProps.shader === 'VRM/MToon') {\n      const params = await this._extractMaterialProperties(originalMaterial, vrmProps, gltf);\n\n      // we need to get rid of these properties\n      ['srcBlend', 'dstBlend', 'isFirstSetup'].forEach((name) => {\n        if (params[name] !== undefined) {\n          delete params[name];\n        }\n      });\n\n      // these textures must be sRGB Encoding, depends on current colorspace\n      ['mainTex', 'shadeTexture', 'emission', 'sphereAdd'].forEach((name) => {\n        if (params[name] !== undefined) {\n          params[name].encoding = this._colorSpaceGamma ? THREE.LinearEncoding : THREE.sRGBEncoding;\n        }\n      });\n\n      // done\n      newSurface = new MToonMaterial(this._colorSpaceGamma, params);\n\n      // outline\n      if (params.outlineWidthMode !== MToonMaterialOutlineWidthMode.None) {\n        params.isOutline = true;\n        newOutline = new MToonMaterial(this._colorSpaceGamma, params);\n      }\n    } else if (vrmProps.shader === 'VRM/UnlitTexture') {\n      // this is very legacy\n      const params = await this._extractMaterialProperties(originalMaterial, vrmProps, gltf);\n      params.renderType = VRMUnlitMaterialRenderType.Opaque;\n      newSurface = new VRMUnlitMaterial(params);\n    } else if (vrmProps.shader === 'VRM/UnlitCutout') {\n      // this is very legacy\n      const params = await this._extractMaterialProperties(originalMaterial, vrmProps, gltf);\n      params.renderType = VRMUnlitMaterialRenderType.Cutout;\n      newSurface = new VRMUnlitMaterial(params);\n    } else if (vrmProps.shader === 'VRM/UnlitTransparent') {\n      // this is very legacy\n      const params = await this._extractMaterialProperties(originalMaterial, vrmProps, gltf);\n      params.renderType = VRMUnlitMaterialRenderType.Transparent;\n      newSurface = new VRMUnlitMaterial(params);\n    } else if (vrmProps.shader === 'VRM/UnlitTransparentZWrite') {\n      // this is very legacy\n      const params = await this._extractMaterialProperties(originalMaterial, vrmProps, gltf);\n      params.renderType = VRMUnlitMaterialRenderType.TransparentWithZWrite;\n      newSurface = new VRMUnlitMaterial(params);\n    } else {\n      if (vrmProps.shader !== 'VRM_USE_GLTFSHADER') {\n        console.warn(`Unknown shader detected: \"${vrmProps.shader}\"`);\n        // then presume as VRM_USE_GLTFSHADER\n      }\n\n      newSurface = this._convertGLTFMaterial(originalMaterial.clone());\n    }\n\n    newSurface.name = originalMaterial.name;\n    newSurface.userData = JSON.parse(JSON.stringify(originalMaterial.userData));\n    newSurface.userData.vrmMaterialProperties = vrmProps;\n\n    if (newOutline) {\n      newOutline.name = originalMaterial.name + ' (Outline)';\n      newOutline.userData = JSON.parse(JSON.stringify(originalMaterial.userData));\n      newOutline.userData.vrmMaterialProperties = vrmProps;\n    }\n\n    return {\n      surface: newSurface,\n      outline: newOutline,\n    };\n  }\n\n  private _renameMaterialProperty(name: string): string {\n    if (name[0] !== '_') {\n      console.warn(`VRMMaterials: Given property name \"${name}\" might be invalid`);\n      return name;\n    }\n    name = name.substring(1);\n\n    if (!/[A-Z]/.test(name[0])) {\n      console.warn(`VRMMaterials: Given property name \"${name}\" might be invalid`);\n      return name;\n    }\n    return name[0].toLowerCase() + name.substring(1);\n  }\n\n  private _convertGLTFMaterial(material: THREE.Material): THREE.Material {\n    if ((material as any).isMeshStandardMaterial) {\n      const mtl = material as THREE.MeshStandardMaterial;\n\n      if (this._colorSpaceGamma) {\n        if (mtl.map) {\n          mtl.map.encoding = THREE.LinearEncoding;\n        }\n        if (mtl.emissiveMap) {\n          mtl.emissiveMap.encoding = THREE.LinearEncoding;\n        }\n      } else {\n        (mtl as any).color.convertSRGBToLinear(); // TODO: `as any` is temporal, since there are no declaration in @types/three\n        (mtl as any).emissive.convertSRGBToLinear(); // TODO: `as any` is temporal, since there are no declaration in @types/three\n      }\n    }\n\n    if ((material as any).isMeshBasicMaterial) {\n      const mtl = material as THREE.MeshBasicMaterial;\n\n      if (this._colorSpaceGamma) {\n        if (mtl.map) {\n          mtl.map.encoding = THREE.LinearEncoding;\n        }\n      } else {\n        (mtl as any).color.convertSRGBToLinear(); // TODO: `as any` is temporal, since there are no declaration in @types/three\n      }\n    }\n\n    return material;\n  }\n\n  private _extractMaterialProperties(\n    originalMaterial: THREE.Material,\n    vrmProps: VRMSchema.Material,\n    gltf: THREE.GLTF,\n  ): Promise<any> {\n    const taskList: Array<Promise<any>> = [];\n    const params: any = {};\n\n    // extract texture properties\n    if (vrmProps.textureProperties) {\n      for (const name of Object.keys(vrmProps.textureProperties)) {\n        const newName = this._renameMaterialProperty(name);\n        const textureIndex = vrmProps.textureProperties[name];\n\n        taskList.push(\n          gltf.parser.getDependency('texture', textureIndex).then((texture: THREE.Texture) => {\n            params[newName] = texture;\n          }),\n        );\n      }\n    }\n\n    // extract float properties\n    if (vrmProps.floatProperties) {\n      for (const name of Object.keys(vrmProps.floatProperties)) {\n        const newName = this._renameMaterialProperty(name);\n        params[newName] = vrmProps.floatProperties[name];\n      }\n    }\n\n    // extract vector (color tbh) properties\n    if (vrmProps.vectorProperties) {\n      for (const name of Object.keys(vrmProps.vectorProperties)) {\n        let newName = this._renameMaterialProperty(name);\n\n        // if this is textureST (same name as texture name itself), add '_ST'\n        // this is my most favorite MToon feature tbh\n        const isTextureST = [\n          '_MainTex',\n          '_ShadeTexture',\n          '_BumpMap',\n          '_ReceiveShadowTexture',\n          '_ShadingGradeTexture',\n          '_SphereAdd',\n          '_EmissionMap',\n          '_OutlineWidthTexture',\n        ].some((textureName) => name === textureName);\n        if (isTextureST) {\n          newName += '_ST';\n        }\n\n        params[newName] = new THREE.Vector4(...vrmProps.vectorProperties[name]);\n      }\n    }\n\n    // TODO: f (https://github.com/dwango/UniVRM/issues/172)\n    if (vrmProps.keywordMap!._ALPHATEST_ON && params.blendMode === MToonMaterialRenderMode.Opaque) {\n      params.blendMode = MToonMaterialRenderMode.Cutout;\n    }\n\n    // set whether it needs skinning and morphing or not\n    params.skinning = (originalMaterial as any).skinning || false;\n    params.morphTargets = (originalMaterial as any).morphTargets || false;\n    params.morphNormals = (originalMaterial as any).morphNormals || false;\n\n    return Promise.all(taskList).then(() => params);\n  }\n}\n","/* tslint:disable:member-ordering */\n\nimport * as THREE from 'three';\nimport vertexShader from './shaders/unlit.vert';\nimport fragmentShader from './shaders/unlit.frag';\n\nexport interface VRMUnlitMaterialParameters extends THREE.ShaderMaterialParameters {\n  cutoff?: number; // _Cutoff\n  map?: THREE.Texture; // _MainTex\n  mainTex?: THREE.Texture; // _MainTex (will be renamed to map)\n  mainTex_ST?: THREE.Vector4; // _MainTex_ST\n\n  renderType?: VRMUnlitMaterialRenderType | number;\n}\n\nexport enum VRMUnlitMaterialRenderType {\n  Opaque,\n  Cutout,\n  Transparent,\n  TransparentWithZWrite,\n}\n\n/**\n * This is a material that is an equivalent of \"VRM/Unlit***\" on VRM spec, those materials are already kinda deprecated though...\n */\nexport class VRMUnlitMaterial extends THREE.ShaderMaterial {\n  /**\n   * Readonly boolean that indicates this is a [[VRMUnlitMaterial]].\n   */\n  public readonly isVRMUnlitMaterial: boolean = true;\n\n  public cutoff = 0.5;\n  public map: THREE.Texture | null = null; // _MainTex\n  public mainTex_ST: THREE.Vector4 = new THREE.Vector4(0.0, 0.0, 1.0, 1.0); // _MainTex_ST\n  private _renderType: VRMUnlitMaterialRenderType = VRMUnlitMaterialRenderType.Opaque;\n\n  public shouldApplyUniforms = true; // when this is true, applyUniforms effects\n\n  constructor(parameters?: VRMUnlitMaterialParameters) {\n    super();\n\n    if (parameters === undefined) {\n      parameters = {};\n    }\n\n    // == enabling bunch of stuff ==============================================\n    parameters.fog = true;\n    parameters.clipping = true;\n\n    parameters.skinning = parameters.skinning || false;\n    parameters.morphTargets = parameters.morphTargets || false;\n    parameters.morphNormals = parameters.morphNormals || false;\n\n    // == uniforms =============================================================\n    parameters.uniforms = THREE.UniformsUtils.merge([\n      THREE.UniformsLib.common, // map\n      THREE.UniformsLib.fog,\n      {\n        cutoff: { value: 0.5 },\n        mainTex_ST: { value: new THREE.Vector4(0.0, 0.0, 1.0, 1.0) },\n      },\n    ]);\n\n    // == finally compile the shader program ===================================\n    this.setValues(parameters);\n\n    // == update shader stuff ==================================================\n    this._updateShaderCode();\n    this._applyUniforms();\n  }\n\n  get mainTex(): THREE.Texture | null {\n    return this.map;\n  }\n\n  set mainTex(t: THREE.Texture | null) {\n    this.map = t;\n  }\n\n  get renderType(): VRMUnlitMaterialRenderType {\n    return this._renderType;\n  }\n\n  set renderType(t: VRMUnlitMaterialRenderType) {\n    this._renderType = t;\n\n    this.depthWrite = this._renderType !== VRMUnlitMaterialRenderType.Transparent;\n    this.transparent =\n      this._renderType === VRMUnlitMaterialRenderType.Transparent ||\n      this._renderType === VRMUnlitMaterialRenderType.TransparentWithZWrite;\n    this._updateShaderCode();\n  }\n\n  /**\n   * Update this material.\n   * Usually this will be called via [[VRM.update]] so you don't have to call this manually.\n   *\n   * @param delta deltaTime since last update\n   */\n  public updateVRMMaterials(delta: number): void {\n    this._applyUniforms();\n  }\n\n  public copy(source: this): this {\n    super.copy(source);\n\n    // == copy members =========================================================\n    this.cutoff = source.cutoff;\n    this.map = source.map;\n    this.mainTex_ST.copy(source.mainTex_ST);\n    this.renderType = source.renderType;\n\n    return this;\n  }\n\n  /**\n   * Apply updated uniform variables.\n   */\n  private _applyUniforms(): void {\n    if (!this.shouldApplyUniforms) {\n      return;\n    }\n    this.shouldApplyUniforms = false;\n\n    this.uniforms.cutoff.value = this.cutoff;\n    this.uniforms.map.value = this.map;\n    this.uniforms.mainTex_ST.value.copy(this.mainTex_ST);\n  }\n\n  private _updateShaderCode(): void {\n    this.defines = {\n      RENDERTYPE_OPAQUE: this._renderType === VRMUnlitMaterialRenderType.Opaque,\n      RENDERTYPE_CUTOUT: this._renderType === VRMUnlitMaterialRenderType.Cutout,\n      RENDERTYPE_TRANSPARENT:\n        this._renderType === VRMUnlitMaterialRenderType.Transparent ||\n        this._renderType === VRMUnlitMaterialRenderType.TransparentWithZWrite,\n    };\n\n    this.vertexShader = vertexShader;\n    this.fragmentShader = fragmentShader;\n\n    // == set needsUpdate flag =================================================\n    this.needsUpdate = true;\n  }\n}\n","import * as THREE from 'three';\n\nexport const getEncodingComponents = (encoding: THREE.TextureEncoding): [string, string] => {\n  switch (encoding) {\n    case THREE.LinearEncoding:\n      return ['Linear', '( value )'];\n    case THREE.sRGBEncoding:\n      return ['sRGB', '( value )'];\n    case THREE.RGBEEncoding:\n      return ['RGBE', '( value )'];\n    case THREE.RGBM7Encoding:\n      return ['RGBM', '( value, 7.0 )'];\n    case THREE.RGBM16Encoding:\n      return ['RGBM', '( value, 16.0 )'];\n    case THREE.RGBDEncoding:\n      return ['RGBD', '( value, 256.0 )'];\n    case THREE.GammaEncoding:\n      return ['Gamma', '( value, float( GAMMA_FACTOR ) )'];\n    default:\n      throw new Error('unsupported encoding: ' + encoding);\n  }\n};\n\nexport const getTexelDecodingFunction = (functionName: string, encoding: THREE.TextureEncoding): string => {\n  const components = getEncodingComponents(encoding);\n  return 'vec4 ' + functionName + '( vec4 value ) { return ' + components[0] + 'ToLinear' + components[1] + '; }';\n};\n","export * from './MToonMaterial';\nexport * from './VRMMaterialImporter';\nexport * from './VRMUnlitMaterial';\n","export default \"// #define PHONG\\n\\n#ifdef BLENDMODE_CUTOUT\\n  uniform float cutoff;\\n#endif\\n\\nuniform vec3 color;\\nuniform float colorAlpha;\\nuniform vec3 shadeColor;\\n#ifdef USE_SHADETEXTURE\\n  uniform sampler2D shadeTexture;\\n#endif\\n\\nuniform float receiveShadowRate;\\n#ifdef USE_RECEIVESHADOWTEXTURE\\n  uniform sampler2D receiveShadowTexture;\\n#endif\\n\\nuniform float shadingGradeRate;\\n#ifdef USE_SHADINGGRADETEXTURE\\n  uniform sampler2D shadingGradeTexture;\\n#endif\\n\\nuniform float shadeShift;\\nuniform float shadeToony;\\nuniform float lightColorAttenuation;\\nuniform float indirectLightIntensity;\\n\\n#ifdef USE_RIMTEXTURE\\n  uniform sampler2D rimTexture;\\n#endif\\nuniform vec3 rimColor;\\nuniform float rimLightingMix;\\nuniform float rimFresnelPower;\\nuniform float rimLift;\\n\\n#ifdef USE_SPHEREADD\\n  uniform sampler2D sphereAdd;\\n#endif\\n\\nuniform vec3 emissionColor;\\n\\nuniform vec3 outlineColor;\\nuniform float outlineLightingMix;\\n\\n#ifdef USE_UVANIMMASKTEXTURE\\n  uniform sampler2D uvAnimMaskTexture;\\n#endif\\n\\nuniform float uvAnimOffsetX;\\nuniform float uvAnimOffsetY;\\nuniform float uvAnimTheta;\\n\\n#include <common>\\n#include <packing>\\n#include <dithering_pars_fragment>\\n#include <color_pars_fragment>\\n\\n// #include <uv_pars_fragment>\\n#if defined( USE_MAP ) || defined( USE_SHADETEXTURE ) || defined( USE_NORMALMAP ) || defined( USE_RECEIVESHADOWTEXTURE ) || defined( USE_SHADINGGRADETEXTURE ) || defined( USE_RIMTEXTURE ) || defined( USE_EMISSIVEMAP ) || defined( USE_OUTLINEWIDTHTEXTURE ) || defined( USE_UVANIMMASKTEXTURE )\\n  varying vec2 vUv;\\n#endif\\n\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n// #include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n// #include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n// #include <envmap_pars_fragment>\\n// #include <gradientmap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <bsdfs>\\n#include <lights_pars_begin>\\n\\n// #include <lights_phong_pars_fragment>\\nvarying vec3 vViewPosition;\\n\\n#ifndef FLAT_SHADED\\n  varying vec3 vNormal;\\n#endif\\n\\n#define Material_LightProbeLOD( material ) (0)\\n\\n#include <shadowmap_pars_fragment>\\n// #include <bumpmap_pars_fragment>\\n\\n// #include <normalmap_pars_fragment>\\n#ifdef USE_NORMALMAP\\n  uniform sampler2D normalMap;\\n  uniform float bumpScale;\\n\\n  // this number is very random, this is still a 対処療法\\n  #define UV_DERIVATIVE_EPSILON 1E-6\\n\\n  // Per-Pixel Tangent Space Normal Mapping\\n  // http://hacksoflife.blogspot.ch/2009/11/per-pixel-tangent-space-normal-mapping.html\\n  vec3 perturbNormal2Arb( vec2 uv, vec3 eye_pos, vec3 surf_norm ) {\\n    // Workaround for Adreno 3XX dFd*( vec3 ) bug. See #9988\\n    vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\\n    vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\\n    vec2 st0 = dFdx( uv.st );\\n    vec2 st1 = dFdy( uv.st );\\n\\n    float scale = sign( st1.t * st0.s - st0.t * st1.s ); // we do not care about the magnitude\\n    vec3 S = ( q0 * st1.t - q1 * st0.t ) * scale;\\n    vec3 T = ( - q0 * st1.s + q1 * st0.s ) * scale;\\n\\n    // Workaround for the issue that happens when delta of uv = 0.0\\n    if ( length( S ) == 0.0 || length( T ) == 0.0 ) {\\n      return surf_norm;\\n    }\\n\\n    S = normalize( S );\\n    T = normalize( T );\\n    vec3 N = normalize( surf_norm );\\n\\n    vec3 mapN = texture2D( normalMap, uv ).xyz * 2.0 - 1.0;\\n\\n    mapN.xy *= bumpScale;\\n\\n    #ifdef DOUBLE_SIDED\\n      // Workaround for Adreno GPUs gl_FrontFacing bug. See #15850 and #10331\\n      // http://hacksoflife.blogspot.com/2009/11/per-pixel-tangent-space-normal-mapping.html?showComment=1522254677437#c5087545147696715943\\n      vec3 NfromST = cross( S, T );\\n      if( dot( NfromST, N ) > 0.0 ) {\\n        S *= -1.0;\\n        T *= -1.0;\\n      }\\n    #else\\n      mapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\\n    #endif\\n\\n    mat3 tsn = mat3( S, T, N );\\n\\n    return normalize( tsn * mapN );\\n  }\\n#endif\\n\\n// #include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\n\\n// == lighting stuff ===========================================================\\nfloat getLightIntensity(\\n  const in IncidentLight directLight,\\n  const in GeometricContext geometry,\\n  const in float shadow,\\n  const in float shadingGrade\\n) {\\n  float lightIntensity = dot( geometry.normal, directLight.direction );\\n  lightIntensity = 0.5 + 0.5 * lightIntensity;\\n  lightIntensity = lightIntensity * shadow;\\n  lightIntensity = lightIntensity * shadingGrade;\\n  lightIntensity = lightIntensity * 2.0 - 1.0;\\n  return smoothstep( shadeShift, shadeShift + ( 1.0 - shadeToony ), lightIntensity );\\n}\\n\\nvec3 getLighting( const in vec3 lightColor ) {\\n  vec3 lighting = lightColor;\\n  lighting = mix(\\n    lighting,\\n    vec3( max( 0.001, max( lighting.x, max( lighting.y, lighting.z ) ) ) ),\\n    lightColorAttenuation\\n  );\\n\\n  #ifndef PHYSICALLY_CORRECT_LIGHTS\\n    lighting *= PI;\\n  #endif\\n\\n  return lighting;\\n}\\n\\nvec3 getDiffuse(\\n  const in vec3 lit,\\n  const in vec3 shade,\\n  const in float lightIntensity,\\n  const in vec3 lighting\\n) {\\n  #ifdef DEBUG_LITSHADERATE\\n    return vec3( BRDF_Diffuse_Lambert( lightIntensity * lighting ) );\\n  #endif\\n\\n  return lighting * BRDF_Diffuse_Lambert( mix( shade, lit, lightIntensity ) );\\n}\\n\\nvec3 calcDirectDiffuse(\\n  const in vec2 uv,\\n  const in vec3 lit,\\n  const in vec3 shade,\\n  in GeometricContext geometry,\\n  inout ReflectedLight reflectedLight\\n) {\\n  IncidentLight directLight;\\n  vec3 lightingSum = vec3( 0.0 );\\n\\n  float shadingGrade = 1.0;\\n  #ifdef USE_SHADINGGRADETEXTURE\\n    shadingGrade = 1.0 - shadingGradeRate * ( 1.0 - texture2D( shadingGradeTexture, uv ).r );\\n  #endif\\n\\n  float receiveShadow = receiveShadowRate;\\n  #ifdef USE_RECEIVESHADOWTEXTURE\\n    receiveShadow *= texture2D( receiveShadowTexture, uv ).a;\\n  #endif\\n\\n  #if ( NUM_POINT_LIGHTS > 0 )\\n    PointLight pointLight;\\n\\n    #pragma unroll_loop\\n    for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n      pointLight = pointLights[ i ];\\n      getPointDirectLightIrradiance( pointLight, geometry, directLight );\\n\\n      float atten = 1.0;\\n      #ifdef USE_SHADOWMAP\\n        atten = all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\\n      #endif\\n\\n      float shadow = 1.0 - receiveShadow * ( 1.0 - ( 0.5 + 0.5 * atten ) );\\n      float lightIntensity = getLightIntensity( directLight, geometry, shadow, shadingGrade );\\n      vec3 lighting = getLighting( directLight.color );\\n      reflectedLight.directDiffuse += getDiffuse( lit, shade, lightIntensity, lighting );\\n      lightingSum += lighting;\\n    }\\n  #endif\\n\\n  #if ( NUM_SPOT_LIGHTS > 0 )\\n    SpotLight spotLight;\\n\\n    #pragma unroll_loop\\n    for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n      spotLight = spotLights[ i ];\\n      getSpotDirectLightIrradiance( spotLight, geometry, directLight );\\n\\n      float atten = 1.0;\\n      #ifdef USE_SHADOWMAP\\n        atten = all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\\n      #endif\\n\\n      float shadow = 1.0 - receiveShadow * ( 1.0 - ( 0.5 + 0.5 * atten ) );\\n      float lightIntensity = getLightIntensity( directLight, geometry, shadow, shadingGrade );\\n      vec3 lighting = getLighting( directLight.color );\\n      reflectedLight.directDiffuse += getDiffuse( lit, shade, lightIntensity, lighting );\\n      lightingSum += lighting;\\n    }\\n  #endif\\n\\n  #if ( NUM_DIR_LIGHTS > 0 )\\n    DirectionalLight directionalLight;\\n\\n    #pragma unroll_loop\\n    for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n      directionalLight = directionalLights[ i ];\\n      getDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\\n\\n      float atten = 1.0;\\n      #ifdef USE_SHADOWMAP\\n        atten = all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\\n      #endif\\n\\n      float shadow = 1.0 - receiveShadow * ( 1.0 - ( 0.5 + 0.5 * atten ) );\\n      float lightIntensity = getLightIntensity( directLight, geometry, shadow, shadingGrade );\\n      vec3 lighting = getLighting( directLight.color );\\n      reflectedLight.directDiffuse += getDiffuse( lit, shade, lightIntensity, lighting );\\n      lightingSum += lighting;\\n    }\\n  #endif\\n\\n  return lightingSum;\\n}\\n\\n// == post correction ==========================================================\\nvoid postCorrection() {\\n  #include <tonemapping_fragment>\\n  #include <encodings_fragment>\\n  #include <fog_fragment>\\n  #include <premultiplied_alpha_fragment>\\n  #include <dithering_fragment>\\n}\\n\\n// == main procedure ===========================================================\\nvoid main() {\\n  #include <clipping_planes_fragment>\\n\\n  vec2 uv = vec2(0.5, 0.5);\\n\\n  #if defined( USE_MAP ) || defined( USE_SHADETEXTURE ) || defined( USE_NORMALMAP ) || defined( USE_RECEIVESHADOWTEXTURE ) || defined( USE_SHADINGGRADETEXTURE ) || defined( USE_RIMTEXTURE ) || defined( USE_EMISSIVEMAP ) || defined( USE_OUTLINEWIDTHTEXTURE ) || defined( USE_UVANIMMASKTEXTURE )\\n    uv = vUv;\\n\\n    float uvAnimMask = 1.0;\\n    #ifdef USE_UVANIMMASKTEXTURE\\n      uvAnimMask = texture2D( uvAnimMaskTexture, uv ).x;\\n    #endif\\n\\n    uv = uv + vec2( uvAnimOffsetX, uvAnimOffsetY ) * uvAnimMask;\\n    float uvRotCos = cos( uvAnimTheta * uvAnimMask );\\n    float uvRotSin = sin( uvAnimTheta * uvAnimMask );\\n    uv = mat2( uvRotCos, uvRotSin, -uvRotSin, uvRotCos ) * ( uv - 0.5 ) + 0.5;\\n  #endif\\n\\n  #ifdef DEBUG_UV\\n    gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\\n    #if defined( USE_MAP ) || defined( USE_SHADETEXTURE ) || defined( USE_NORMALMAP ) || defined( USE_RECEIVESHADOWTEXTURE ) || defined( USE_SHADINGGRADETEXTURE ) || defined( USE_RIMTEXTURE ) || defined( USE_EMISSIVEMAP ) || defined( USE_OUTLINEWIDTHTEXTURE ) || defined( USE_UVANIMMASKTEXTURE )\\n      gl_FragColor = vec4( uv, 0.0, 1.0 );\\n    #endif\\n    return;\\n  #endif\\n\\n  vec4 diffuseColor = vec4( color, colorAlpha );\\n  ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n  vec3 totalEmissiveRadiance = emissionColor;\\n\\n  #include <logdepthbuf_fragment>\\n\\n  // #include <map_fragment>\\n  #ifdef USE_MAP\\n    diffuseColor *= mapTexelToLinear( texture2D( map, uv ) );\\n  #endif\\n\\n  #include <color_fragment>\\n  // #include <alphamap_fragment>\\n\\n  // -- MToon: alpha -----------------------------------------------------------\\n  // #include <alphatest_fragment>\\n  #ifdef BLENDMODE_CUTOUT\\n    if ( diffuseColor.a <= cutoff ) { discard; }\\n    diffuseColor.a = 1.0;\\n  #endif\\n\\n  #ifdef BLENDMODE_OPAQUE\\n    diffuseColor.a = 1.0;\\n  #endif\\n\\n  #if defined( OUTLINE ) && defined( OUTLINE_COLOR_FIXED ) // omitting DebugMode\\n    gl_FragColor = vec4( outlineColor, diffuseColor.a );\\n    postCorrection();\\n    return;\\n  #endif\\n\\n  // #include <specularmap_fragment>\\n  #include <normal_fragment_begin>\\n\\n  #ifdef OUTLINE\\n    normal *= -1.0;\\n  #endif\\n\\n  // #include <normal_fragment_maps>\\n  #ifdef USE_NORMALMAP\\n    normal = perturbNormal2Arb( uv, -vViewPosition, normal );\\n  #endif\\n\\n  // #include <emissivemap_fragment>\\n  #ifdef USE_EMISSIVEMAP\\n    totalEmissiveRadiance *= emissiveMapTexelToLinear( texture2D( emissiveMap, uv ) ).rgb;\\n  #endif\\n\\n  #ifdef DEBUG_NORMAL\\n    gl_FragColor = vec4( 0.5 + 0.5 * normal, 1.0 );\\n    return;\\n  #endif\\n\\n  // -- MToon: lighting --------------------------------------------------------\\n  // accumulation\\n  // #include <lights_phong_fragment>\\n  // #include <lights_fragment_begin>\\n  vec3 lit = diffuseColor.rgb;\\n  vec3 shade = shadeColor;\\n  #ifdef USE_SHADETEXTURE\\n    shade *= shadeTextureTexelToLinear( texture2D( shadeTexture, uv ) ).rgb;\\n  #endif\\n\\n  GeometricContext geometry;\\n\\n  geometry.position = - vViewPosition;\\n  geometry.normal = normal;\\n  geometry.viewDir = normalize( vViewPosition );\\n\\n  vec3 lighting = calcDirectDiffuse( uv, diffuseColor.rgb, shade, geometry, reflectedLight );\\n\\n  vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\\n  #if ( NUM_HEMI_LIGHTS > 0 )\\n    #pragma unroll_loop\\n    for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\\n      irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\\n    }\\n  #endif\\n\\n  // #include <lights_fragment_maps>\\n  #ifdef USE_LIGHTMAP\\n    vec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).rgb * lightMapIntensity;\\n    #ifndef PHYSICALLY_CORRECT_LIGHTS\\n      lightMapIrradiance *= PI; // factor of PI should not be present; included here to prevent breakage\\n    #endif\\n    irradiance += lightMapIrradiance;\\n  #endif\\n\\n  // #include <lights_fragment_end>\\n  reflectedLight.indirectDiffuse += indirectLightIntensity * irradiance * BRDF_Diffuse_Lambert( lit );\\n\\n  // modulation\\n  #include <aomap_fragment>\\n\\n  vec3 col = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\\n\\n  #if defined( OUTLINE ) && defined( OUTLINE_COLOR_MIXED ) // omitting DebugMode\\n    gl_FragColor = vec4(\\n      outlineColor.rgb * mix( vec3( 1.0 ), col, outlineLightingMix ),\\n      diffuseColor.a\\n    );\\n    postCorrection();\\n    return;\\n  #endif\\n\\n  // -- MToon: parametric rim lighting -----------------------------------------\\n  vec3 viewDir = normalize( vViewPosition );\\n  vec3 rimMix = mix(vec3(1.0), lighting + indirectLightIntensity * irradiance, rimLightingMix);\\n  vec3 rim = rimColor * pow( saturate( 1.0 - dot( viewDir, normal ) + rimLift ), rimFresnelPower );\\n  #ifdef USE_RIMTEXTURE\\n    rim *= texture2D( rimTexture, uv ).rgb;\\n  #endif\\n  col += rim;\\n\\n  // -- MToon: additive matcap -------------------------------------------------\\n  #ifdef USE_SPHEREADD\\n    {\\n      vec3 x = normalize( vec3( viewDir.z, 0.0, -viewDir.x ) );\\n      vec3 y = cross( viewDir, x ); // guaranteed to be normalized\\n      vec2 sphereUv = 0.5 + 0.5 * vec2( dot( x, normal ), -dot( y, normal ) );\\n      vec3 matcap = sphereAddTexelToLinear( texture2D( sphereAdd, sphereUv ) ).xyz;\\n      col += matcap;\\n    }\\n  #endif\\n\\n  // -- MToon: Emission --------------------------------------------------------\\n  col += totalEmissiveRadiance;\\n\\n  // #include <envmap_fragment>\\n\\n  // -- Almost done! -----------------------------------------------------------\\n  gl_FragColor = vec4( col, diffuseColor.a );\\n  postCorrection();\\n}\"","export default \"// #define PHONG\\n\\nvarying vec3 vViewPosition;\\n\\n#ifndef FLAT_SHADED\\n  varying vec3 vNormal;\\n#endif\\n\\n#include <common>\\n\\n// #include <uv_pars_vertex>\\n#if defined( USE_MAP ) || defined( USE_SHADETEXTURE ) || defined( USE_NORMALMAP ) || defined( USE_RECEIVESHADOWTEXTURE ) || defined( USE_SHADINGGRADETEXTURE ) || defined( USE_RIMTEXTURE ) || defined( USE_EMISSIVEMAP ) || defined( USE_OUTLINEWIDTHTEXTURE ) || defined( USE_UVANIMMASKTEXTURE )\\n  varying vec2 vUv;\\n  uniform vec4 mainTex_ST;\\n#endif\\n\\n#include <uv2_pars_vertex>\\n// #include <displacementmap_pars_vertex>\\n// #include <envmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\n\\n#ifdef USE_OUTLINEWIDTHTEXTURE\\n  uniform sampler2D outlineWidthTexture;\\n#endif\\n\\nuniform float outlineWidth;\\nuniform float outlineScaledMaxDistance;\\n\\nvoid main() {\\n\\n  // #include <uv_vertex>\\n  #if defined( USE_MAP ) || defined( USE_SHADETEXTURE ) || defined( USE_NORMALMAP ) || defined( USE_RECEIVESHADOWTEXTURE ) || defined( USE_SHADINGGRADETEXTURE ) || defined( USE_RIMTEXTURE ) || defined( USE_EMISSIVEMAP ) || defined( USE_OUTLINEWIDTHTEXTURE ) || defined( USE_UVANIMMASKTEXTURE )\\n    vUv = vec2( mainTex_ST.p * uv.x + mainTex_ST.s, mainTex_ST.q * uv.y + mainTex_ST.t );\\n  #endif\\n\\n  #include <uv2_vertex>\\n  #include <color_vertex>\\n\\n  #include <beginnormal_vertex>\\n  #include <morphnormal_vertex>\\n  #include <skinbase_vertex>\\n  #include <skinnormal_vertex>\\n  #include <defaultnormal_vertex>\\n\\n  #ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED\\n    vNormal = normalize( transformedNormal );\\n  #endif\\n\\n  #include <begin_vertex>\\n\\n  #include <morphtarget_vertex>\\n  #include <skinning_vertex>\\n  // #include <displacementmap_vertex>\\n  #include <project_vertex>\\n  #include <logdepthbuf_vertex>\\n  #include <clipping_planes_vertex>\\n\\n  vViewPosition = - mvPosition.xyz;\\n\\n  float outlineTex = 1.0;\\n\\n  #ifdef OUTLINE\\n    #ifdef USE_OUTLINEWIDTHTEXTURE\\n      outlineTex = texture2D( outlineWidthTexture, vUv ).r;\\n    #endif\\n\\n    #ifdef OUTLINE_WIDTH_WORLD\\n      vec3 outlineOffset = 0.01 * outlineWidth * outlineTex * normalize( objectNormal );\\n      gl_Position += projectionMatrix * modelViewMatrix * vec4( outlineOffset, 0.0 );\\n    #endif\\n\\n    #ifdef OUTLINE_WIDTH_SCREEN\\n      vec3 clipNormal = ( projectionMatrix * modelViewMatrix * vec4( normalize( objectNormal ), 0.0 ) ).xyz;\\n      vec2 projectedNormal = normalize( clipNormal.xy );\\n      projectedNormal *= min( gl_Position.w, outlineScaledMaxDistance );\\n      projectedNormal.x *= projectionMatrix[ 0 ].x / projectionMatrix[ 1 ].y;\\n      gl_Position.xy += 0.01 * outlineWidth * outlineTex * projectedNormal.xy;\\n    #endif\\n\\n    gl_Position.z += 1E-6 * gl_Position.w; // anti-artifact magic\\n  #endif\\n\\n  #include <worldpos_vertex>\\n  // #include <envmap_vertex>\\n  #include <shadowmap_vertex>\\n  #include <fog_vertex>\\n\\n}\"","export default \"#ifdef RENDERTYPE_CUTOUT\\n  uniform float cutoff;\\n#endif\\n\\n#include <common>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n// #include <alphamap_pars_fragment>\\n// #include <aomap_pars_fragment>\\n// #include <lightmap_pars_fragment>\\n// #include <envmap_pars_fragment>\\n#include <fog_pars_fragment>\\n// #include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\n\\n// == main procedure ===========================================================\\nvoid main() {\\n  #include <clipping_planes_fragment>\\n\\n  vec4 diffuseColor = vec4( 1.0 );\\n\\n  #include <logdepthbuf_fragment>\\n\\n  // #include <map_fragment>\\n  #ifdef USE_MAP\\n    diffuseColor *= mapTexelToLinear( texture2D( map, vUv ) );\\n  #endif\\n\\n  #include <color_fragment>\\n  // #include <alphamap_fragment>\\n\\n  // MToon: alpha\\n  // #include <alphatest_fragment>\\n  #ifdef RENDERTYPE_CUTOUT\\n    if ( diffuseColor.a <= cutoff ) { discard; }\\n    diffuseColor.a = 1.0;\\n  #endif\\n\\n  #ifdef RENDERTYPE_OPAQUE\\n    diffuseColor.a = 1.0;\\n  #endif\\n\\n  // #include <specularmap_fragment>\\n\\n  ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\n  // accumulation (baked indirect lighting only)\\n  #ifdef USE_LIGHTMAP\\n    reflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\\n  #else\\n    reflectedLight.indirectDiffuse += vec3( 1.0 );\\n  #endif\\n\\n  // modulation\\n  // #include <aomap_fragment>\\n\\n  reflectedLight.indirectDiffuse *= diffuseColor.rgb;\\n  vec3 outgoingLight = reflectedLight.indirectDiffuse;\\n\\n  // #include <envmap_fragment>\\n\\n  gl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\n  #include <premultiplied_alpha_fragment>\\n  #include <tonemapping_fragment>\\n  #include <encodings_fragment>\\n  #include <fog_fragment>\\n}\"","export default \"#include <common>\\n\\n// #include <uv_pars_vertex>\\n#ifdef USE_MAP\\n  varying vec2 vUv;\\n  uniform vec4 mainTex_ST;\\n#endif\\n\\n#include <uv2_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\n\\nvoid main() {\\n\\n  // #include <uv_vertex>\\n  #ifdef USE_MAP\\n    vUv = vec2( mainTex_ST.p * uv.x + mainTex_ST.s, mainTex_ST.q * uv.y + mainTex_ST.t );\\n  #endif\\n\\n  #include <uv2_vertex>\\n  #include <color_vertex>\\n  #include <skinbase_vertex>\\n\\n  #ifdef USE_ENVMAP\\n\\n  #include <beginnormal_vertex>\\n  #include <morphnormal_vertex>\\n  #include <skinnormal_vertex>\\n  #include <defaultnormal_vertex>\\n\\n  #endif\\n\\n  #include <begin_vertex>\\n  #include <morphtarget_vertex>\\n  #include <skinning_vertex>\\n  #include <project_vertex>\\n  #include <logdepthbuf_vertex>\\n\\n  #include <worldpos_vertex>\\n  #include <clipping_planes_vertex>\\n  #include <envmap_vertex>\\n  #include <fog_vertex>\\n\\n}\"","import * as THREE from 'three';\n\nexport function reduceBones(root: THREE.Object3D): void {\n  // Traverse an entire tree\n  root.traverse((obj) => {\n    if (obj.type !== 'SkinnedMesh') {\n      return;\n    }\n\n    const mesh = obj as THREE.SkinnedMesh;\n    const geometry = (mesh.geometry as THREE.BufferGeometry).clone();\n    mesh.geometry = geometry;\n    const attribute = geometry.getAttribute('skinIndex');\n\n    // generate reduced bone list\n    const bones: THREE.Bone[] = []; // new list of bone\n    const boneInverses: THREE.Matrix4[] = []; // new list of boneInverse\n    const boneIndexMap: { [index: number]: number } = {}; // map of old bone index vs. new bone index\n    const array = (attribute.array as any).map((index: number) => {\n      // new skinIndex buffer\n      if (boneIndexMap[index] === undefined) {\n        boneIndexMap[index] = bones.length;\n        bones.push(mesh.skeleton.bones[index]);\n        boneInverses.push(mesh.skeleton.boneInverses[index]);\n      }\n      return boneIndexMap[index];\n    });\n\n    // attach new skinIndex buffer\n    geometry.removeAttribute('skinIndex');\n    geometry.addAttribute('skinIndex', new THREE.BufferAttribute(array, 4, false));\n    mesh.bind(new THREE.Skeleton(bones, boneInverses), new THREE.Matrix4());\n    //                                                 ^^^^^^^^^^^^^^^^^^^ transform of meshes should be ignored\n    // See: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins\n  });\n}\n","import * as THREE from 'three';\nimport { getWorldQuaternionLite } from '../utils/math';\n// based on\n// http://rocketjump.skr.jp/unity3d/109/\n// https://github.com/dwango/UniVRM/blob/master/Scripts/SpringBone/VRMSpringBone.cs\n\nexport const GIZMO_RENDER_ORDER = 10000;\nconst IDENTITY_MATRIX4 = Object.freeze(new THREE.Matrix4());\nconst IDENTITY_QUATERNION = Object.freeze(new THREE.Quaternion());\n\n// 計算中の一時保存用変数（一度インスタンスを作ったらあとは使い回す）\nconst _v3A = new THREE.Vector3();\nconst _v3B = new THREE.Vector3();\nconst _v3C = new THREE.Vector3();\nconst _quatA = new THREE.Quaternion();\nconst _matA = new THREE.Matrix4();\nconst _matB = new THREE.Matrix4();\n\n/**\n * A class represents a single spring bone of a VRM.\n * It should be managed by a [[VRMSpringBoneManager]].\n */\nexport class VRMSpringBone {\n  /**\n   * Radius of the bone, will be used for collision.\n   */\n  public readonly radius: number;\n\n  /**\n   * Stiffness force of the bone. Increasing the value = faster convergence (feels \"harder\").\n   * On UniVRM, its range on GUI is between `0.0` and `4.0` .\n   */\n  public readonly stiffnessForce: number;\n\n  /**\n   * Power of the gravity against this bone.\n   * The \"power\" used in here is very far from scientific physics term...\n   */\n  public readonly gravityPower: number;\n\n  /**\n   * Direction of the gravity against this bone.\n   * Usually it should be normalized.\n   */\n  public readonly gravityDir: THREE.Vector3;\n\n  /**\n   * Drag force of the bone. Increasing the value = less oscillation (feels \"heavier\").\n   * On UniVRM, its range on GUI is between `0.0` and `1.0` .\n   */\n  public readonly dragForce: number;\n\n  /**\n   * An Object3D attached to this bone.\n   */\n  public readonly bone: THREE.Object3D;\n\n  /**\n   * Colliders (as `THREE.Mesh` ) attached to this bone.\n   */\n  public readonly colliders: THREE.Mesh[];\n\n  /**\n   * Current position of child tail, in world unit. Will be used for verlet integration.\n   */\n  protected _currentTail: THREE.Vector3;\n\n  /**\n   * Previous position of child tail, in world unit. Will be used for verlet integration.\n   */\n  protected _prevTail: THREE.Vector3;\n\n  /**\n   * Next position of child tail, in world unit. Will be used for verlet integration.\n   * Actually used only in [[update]] and it's kind of temporary variable.\n   */\n  protected _nextTail: THREE.Vector3;\n\n  /**\n   * Initial axis of the bone, in local unit.\n   */\n  protected _boneAxis: THREE.Vector3;\n\n  /**\n   * Length of the bone in **world unit**. Will be used for normalization in update loop.\n   * It's same as local unit length unless there are scale transformation in world matrix.\n   */\n  protected _worldBoneLength: number;\n\n  /**\n   * World position of this bone, kind of temporary variable.\n   */\n  protected _worldPosition: THREE.Vector3;\n\n  /**\n   * Rotation of parent bone, in world unit.\n   * We should update this constantly in [[update]].\n   */\n  private _parentWorldRotation: THREE.Quaternion;\n\n  /**\n   * Initial state of the local matrix of the bone.\n   */\n  private _initialLocalMatrix: THREE.Matrix4;\n\n  /**\n   * Initial state of the rotation of the bone.\n   */\n  private _initialLocalRotation: THREE.Quaternion;\n\n  /**\n   * Initial state of the position of its child.\n   */\n  private _initialLocalChildPosition: THREE.Vector3;\n\n  /**\n   * Create a new VRMSpringBone.\n   *\n   * @param bone An Object3D that will be attached to this bone\n   * @param radius Radius of the bone\n   * @param stiffness Stiffness force of the bone\n   * @param gravityDir Direction of the gravity against this bone\n   * @param gravityPower Power of the gravity against this bone\n   * @param dragForce Drag force of the bone\n   * @param colliders Colliders that will be attached to this bone\n   */\n  constructor(\n    bone: THREE.Object3D,\n    radius: number,\n    stiffiness: number,\n    gravityDir: THREE.Vector3,\n    gravityPower: number,\n    dragForce: number,\n    colliders: THREE.Mesh[] = [],\n  ) {\n    this.bone = bone; // uniVRMでの parent\n    this.bone.matrixAutoUpdate = false; // updateにより計算されるのでthree.js内での自動処理は不要\n\n    this.radius = radius;\n    this.stiffnessForce = stiffiness;\n    this.gravityDir = gravityDir;\n    this.gravityPower = gravityPower;\n    this.dragForce = dragForce;\n    this.colliders = colliders;\n\n    this._worldPosition = new THREE.Vector3().setFromMatrixPosition(this.bone.matrixWorld);\n\n    this._parentWorldRotation = new THREE.Quaternion();\n\n    this._initialLocalMatrix = this.bone.matrix.clone();\n    this._initialLocalRotation = this.bone.quaternion.clone();\n    this._initialLocalChildPosition = ((): THREE.Vector3 => {\n      if (this.bone.children.length === 0) {\n        // 末端のボーン。子ボーンがいないため「自分の少し先」が子ボーンということにする\n        // https://github.com/dwango/UniVRM/blob/master/Assets/VRM/UniVRM/Scripts/SpringBone/VRMSpringBone.cs#L246\n        return this.bone.position\n          .clone()\n          .normalize()\n          .multiplyScalar(0.07); // magic number! derives from original source\n      } else {\n        const firstChild = this.bone.children[0];\n        return firstChild.position.clone();\n      }\n    })();\n\n    this._currentTail = this.bone.localToWorld(this._initialLocalChildPosition.clone());\n    this._prevTail = this._currentTail.clone();\n    this._nextTail = this._currentTail.clone();\n\n    this._boneAxis = this._initialLocalChildPosition.clone().normalize();\n    this._worldBoneLength = this.bone\n      .localToWorld(_v3A.copy(this._initialLocalChildPosition))\n      .sub(this._worldPosition)\n      .length();\n  }\n\n  /**\n   * Reset the state of this bone.\n   * You might want to call [[VRMSpringBoneManager.reset]] instead.\n   */\n  public reset(): void {\n    this.bone.matrix.copy(this._initialLocalMatrix);\n\n    this.bone.localToWorld(this._currentTail.copy(this._initialLocalChildPosition));\n    this._prevTail.copy(this._currentTail);\n    this._nextTail.copy(this._currentTail);\n\n    // ボーンの姿勢を手動で操作したので、matrixWorldも更新しておく\n    this.bone.updateMatrix();\n    this.bone.matrixWorld.multiplyMatrices(this._getParentMatrixWorld(), this.bone.matrix);\n    this._worldPosition.setFromMatrixPosition(this.bone.matrixWorld);\n  }\n\n  /**\n   * Update the state of this bone.\n   * You might want to call [[VRMSpringBoneManager.update]] instead.\n   *\n   * @param delta deltaTime\n   */\n  public update(delta: number): void {\n    if (delta <= 0) return;\n\n    // 親スプリングボーンの姿勢は常に変化している。\n    // それに基づいて処理直前に自分のworldMatrixを更新しておく\n    this.bone.matrixWorld.multiplyMatrices(this._getParentMatrixWorld(), this.bone.matrix);\n\n    if (this.bone.parent) {\n      // SpringBoneは親から順に処理されていくため、\n      // 親のmatrixWorldは最新状態の前提でworldMatrixからquaternionを取り出す。\n      // 制限はあるけれど、計算は少ないのでgetWorldQuaternionではなくこの方法を取る。\n      getWorldQuaternionLite(this.bone.parent, this._parentWorldRotation);\n    } else {\n      this._parentWorldRotation.copy(IDENTITY_QUATERNION);\n    }\n\n    // 更新済みのworldMatrixからworldPositionを取り出す。\n    // `getWorldPosition()` は負荷が高いので利用しない。\n    this._worldPosition.setFromMatrixPosition(this.bone.matrixWorld);\n    const stiffness = this.stiffnessForce * delta;\n    const external = _v3B.copy(this.gravityDir).multiplyScalar(this.gravityPower * delta);\n\n    // verlet積分で次の位置を計算\n    this._nextTail\n      .copy(this._currentTail)\n      .add(\n        _v3A\n          .copy(this._currentTail)\n          .sub(this._prevTail)\n          .multiplyScalar(1 - this.dragForce),\n      ) // 前フレームの移動を継続する(減衰もあるよ)\n      .add(\n        _v3A\n          .copy(this._boneAxis)\n          .applyMatrix4(this._initialLocalMatrix)\n          .applyMatrix4(this._getParentMatrixWorld())\n          .sub(this._worldPosition)\n          .normalize()\n          .multiplyScalar(stiffness),\n      ) // 親の回転による子ボーンの移動目標\n      .add(external); // 外力による移動量\n\n    // normalize bone length\n    this._nextTail\n      .sub(this._worldPosition)\n      .normalize()\n      .multiplyScalar(this._worldBoneLength)\n      .add(this._worldPosition);\n\n    // Collisionで移動\n    this._collision(this._nextTail);\n\n    this._prevTail.copy(this._currentTail);\n    this._currentTail.copy(this._nextTail);\n\n    // Apply rotation, convert vector3 thing into actual quaternion\n    // Original UniVRM is doing world unit calculus at here but we're gonna do this on local unit\n    // since Three.js is not good at world coordination stuff\n    const initialWorldMatrixInv = _matA.getInverse(\n      _matB.copy(this._getParentMatrixWorld()).multiply(this._initialLocalMatrix),\n    );\n    const applyRotation = _quatA.setFromUnitVectors(\n      this._boneAxis,\n      _v3A\n        .copy(this._nextTail)\n        .applyMatrix4(initialWorldMatrixInv)\n        .normalize(),\n    );\n\n    this.bone.quaternion.copy(this._initialLocalRotation).multiply(applyRotation);\n\n    // We need to update its matrixWorld manually, since we tweaked the bone by our hand\n    this.bone.updateMatrix();\n    this.bone.matrixWorld.multiplyMatrices(this._getParentMatrixWorld(), this.bone.matrix);\n  }\n\n  /**\n   * Do collision math against every colliders attached to this bone.\n   *\n   * @param tail The tail you want to process\n   */\n  private _collision(tail: THREE.Vector3): void {\n    this.colliders.forEach((collider) => {\n      const colliderWorldPosition = _v3A.setFromMatrixPosition(collider.matrixWorld);\n      const colliderRadius = collider.geometry.boundingSphere.radius;\n      const r = this.radius + colliderRadius;\n\n      if (tail.distanceToSquared(colliderWorldPosition) <= r * r) {\n        // ヒット。Colliderの半径方向に押し出す\n        const normal = _v3B.subVectors(tail, colliderWorldPosition).normalize();\n        const posFromCollider = _v3C.addVectors(colliderWorldPosition, normal.multiplyScalar(r));\n\n        // normalize bone length\n        tail.copy(\n          posFromCollider\n            .sub(this._worldPosition)\n            .normalize()\n            .multiplyScalar(this._worldBoneLength)\n            .add(this._worldPosition),\n        );\n      }\n    });\n  }\n\n  /**\n   * Returns the world matrix of its parent object.\n   */\n  private _getParentMatrixWorld(): THREE.Matrix4 {\n    return this.bone.parent ? this.bone.parent.matrixWorld : IDENTITY_MATRIX4;\n  }\n}\n","import * as THREE from 'three';\nimport { GLTFNode, VRMSchema } from '../types';\nimport { GIZMO_RENDER_ORDER, VRMSpringBone } from './VRMSpringBone';\nimport { VRMSpringBoneColliderGroup, VRMSpringBoneColliderMesh } from './VRMSpringBoneColliderGroup';\nimport { VRMSpringBoneGroup, VRMSpringBoneManager } from './VRMSpringBoneManager';\n\n/**\n * An importer that imports a [[VRMSpringBoneManager]] from a VRM extension of a GLTF.\n */\nexport class VRMSpringBoneImporter {\n  /**\n   * Import a [[VRMLookAtHead]] from a VRM.\n   *\n   * @param gltf A parsed result of GLTF taken from GLTFLoader\n   */\n  public async import(gltf: THREE.GLTF): Promise<VRMSpringBoneManager | null> {\n    if (\n      !gltf.parser.json.extensions ||\n      !gltf.parser.json.extensions.VRM ||\n      !gltf.parser.json.extensions.VRM.secondaryAnimation\n    ) {\n      return null;\n    }\n\n    // 衝突判定球体メッシュ。\n    const colliderGroups = await this._getColliderMeshGroups(gltf);\n    colliderGroups.forEach((group) => gltf.scene.add(...group.colliders));\n\n    // 同じ属性（stiffinessやdragForceが同じ）のボーンはboneGroupにまとめられている。\n    // 一列だけではないことに注意。\n    const springBoneGroupList = await this._getSpringBoneGroupList(gltf, colliderGroups);\n\n    return new VRMSpringBoneManager(springBoneGroupList);\n  }\n\n  protected get _isColiderMeshVisible(): boolean {\n    return false;\n  }\n\n  protected _createSpringBone(\n    gltf: THREE.GLTF,\n    bone: THREE.Object3D,\n    hitRadius: number,\n    stiffiness: number,\n    gravityDir: THREE.Vector3,\n    gravityPower: number,\n    dragForce: number,\n    colliders: THREE.Mesh[] = [],\n  ): VRMSpringBone {\n    return new VRMSpringBone(bone, hitRadius, stiffiness, gravityDir, gravityPower, dragForce, colliders);\n  }\n\n  private async _getSpringBoneGroupList(\n    gltf: THREE.GLTF,\n    colliderGroups: VRMSpringBoneColliderGroup[],\n  ): Promise<VRMSpringBoneGroup[]> {\n    const springBoneGroups: VRMSchema.SecondaryAnimationSpring[] = gltf.parser.json.extensions!.VRM!.secondaryAnimation!\n      .boneGroups;\n\n    const springBoneGroupList: VRMSpringBoneGroup[] = [];\n\n    springBoneGroups.forEach((vrmBoneGroup) => {\n      if (\n        vrmBoneGroup.stiffiness === undefined ||\n        vrmBoneGroup.gravityDir === undefined ||\n        vrmBoneGroup.gravityDir.x === undefined ||\n        vrmBoneGroup.gravityDir.y === undefined ||\n        vrmBoneGroup.gravityDir.z === undefined ||\n        vrmBoneGroup.gravityPower === undefined ||\n        vrmBoneGroup.dragForce === undefined ||\n        vrmBoneGroup.hitRadius === undefined ||\n        vrmBoneGroup.colliderGroups === undefined ||\n        vrmBoneGroup.bones === undefined\n      ) {\n        return;\n      }\n\n      const stiffiness = vrmBoneGroup.stiffiness;\n      const gravityDir = new THREE.Vector3(\n        vrmBoneGroup.gravityDir.x,\n        vrmBoneGroup.gravityDir.y,\n        vrmBoneGroup.gravityDir.z,\n      );\n      const gravityPower = vrmBoneGroup.gravityPower;\n      const dragForce = vrmBoneGroup.dragForce;\n      const hitRadius = vrmBoneGroup.hitRadius;\n\n      const colliders: VRMSpringBoneColliderMesh[] = [];\n      vrmBoneGroup.colliderGroups.forEach((colliderIndex) => {\n        colliders.push(...colliderGroups[colliderIndex].colliders);\n      });\n\n      const springBoneGroup: VRMSpringBoneGroup = [];\n      vrmBoneGroup.bones.forEach(async (nodeIndex) => {\n        // VRMの情報から「揺れモノ」ボーンのルートが取れる\n        const springRootBone: GLTFNode = await gltf.parser.getDependency('node', nodeIndex);\n\n        // it's weird but there might be cases we can't find the root bone\n        if (!springRootBone) {\n          return;\n        }\n\n        springRootBone.traverse((bone) => {\n          const springBone = this._createSpringBone(\n            gltf,\n            bone,\n            hitRadius,\n            stiffiness,\n            gravityDir,\n            gravityPower,\n            dragForce,\n            colliders,\n          );\n          springBoneGroup.push(springBone);\n        });\n      });\n\n      springBoneGroupList.push(springBoneGroup);\n    });\n\n    return springBoneGroupList;\n  }\n\n  /**\n   * Create an array of [[VRMSpringBoneColliderGroup]].\n   */\n  private async _getColliderMeshGroups(gltf: THREE.GLTF): Promise<VRMSpringBoneColliderGroup[]> {\n    const vrmExt: VRMSchema.VRM | undefined = gltf.parser.json.extensions && gltf.parser.json.extensions.VRM;\n    if (vrmExt === undefined) {\n      return [];\n    }\n    const secondaryAnimation = vrmExt.secondaryAnimation;\n    if (secondaryAnimation === undefined) {\n      return [];\n    }\n    const vrmColliderGroups = secondaryAnimation.colliderGroups;\n    if (vrmColliderGroups === undefined) {\n      return [];\n    }\n\n    const colliderGroups: VRMSpringBoneColliderGroup[] = [];\n    vrmColliderGroups.forEach(async (colliderGroup) => {\n      if (colliderGroup.node === undefined || colliderGroup.colliders === undefined) {\n        return;\n      }\n\n      const bone = await gltf.parser.getDependency('node', colliderGroup.node);\n      const colliders: VRMSpringBoneColliderMesh[] = [];\n      colliderGroup.colliders.forEach((collider) => {\n        if (\n          collider.offset === undefined ||\n          collider.offset.x === undefined ||\n          collider.offset.y === undefined ||\n          collider.offset.z === undefined ||\n          collider.radius === undefined\n        ) {\n          return;\n        }\n\n        const offsetMatrix = new THREE.Matrix4().makeTranslation(\n          collider.offset.x,\n          collider.offset.y,\n          -collider.offset.z, // this is pretty weird. See: https://github.com/dwango/UniVRM/issues/65\n        );\n        const visible = this._isColiderMeshVisible;\n        const colliderMesh = new THREE.Mesh(\n          new THREE.SphereBufferGeometry(collider.radius, 8, 4),\n          new THREE.MeshBasicMaterial({\n            color: 0xff00ff,\n            visible,\n            wireframe: true,\n            transparent: true,\n            depthTest: false,\n          }),\n        );\n        (colliderMesh.material as any).renderOrder = GIZMO_RENDER_ORDER;\n\n        // the name have to be this in order to exclude colliders from bounding box\n        // (See Viewer.ts, search for child.name === 'vrmColliderSphere')\n        colliderMesh.name = 'vrmColliderSphere';\n\n        // We will use the radius of the sphere for collision vs bones.\n        // `boundingSphere` must be created to compute the radius.\n        colliderMesh.geometry.computeBoundingSphere();\n\n        // The colliderMesh must sync with the bone.\n        // Attaching bone's matrix to the colliderMesh at every update.\n        // (colliderMesh will move automecicallty)\n        colliderMesh.updateMatrixWorld = (): void => {\n          colliderMesh.matrixWorld.copy(bone.matrixWorld).multiply(offsetMatrix);\n        };\n        colliders.push(colliderMesh);\n      });\n\n      const colliderMeshGroup = {\n        node: colliderGroup.node,\n        colliders,\n      };\n      colliderGroups.push(colliderMeshGroup);\n    });\n\n    return colliderGroups;\n  }\n}\n","import { VRMSpringBone } from './VRMSpringBone';\n\n/**\n * Represents a single spring bone group of a VRM.\n */\nexport type VRMSpringBoneGroup = VRMSpringBone[];\n\n/**\n * A class manages every spring bones on a VRM.\n */\nexport class VRMSpringBoneManager {\n  public readonly springBoneGroupList: VRMSpringBoneGroup[] = [];\n\n  /**\n   * Create a new [[VRMSpringBoneManager]]\n   *\n   * @param springBoneGroupList An array of [[VRMSpringBoneGroup]]\n   */\n  public constructor(springBoneGroupList: VRMSpringBoneGroup[]) {\n    this.springBoneGroupList = springBoneGroupList;\n  }\n\n  /**\n   * Update every spring bone attached to this manager.\n   *\n   * @param delta deltaTime\n   */\n  public lateUpdate(delta: number): void {\n    this.springBoneGroupList.forEach((springBoneGroup) => {\n      springBoneGroup.forEach((springBone) => {\n        springBone.update(delta);\n      });\n    });\n  }\n\n  /**\n   * Reset every spring bone attached to this manager.\n   */\n  public reset(): void {\n    this.springBoneGroupList.forEach((springBoneGroup) => {\n      springBoneGroup.forEach((springBone) => {\n        springBone.reset();\n      });\n    });\n  }\n}\n","export * from './VRMSpringBone';\nexport * from './VRMSpringBoneColliderGroup';\nexport * from './VRMSpringBoneImporter';\nexport * from './VRMSpringBoneManager';\n","// Typedoc does not support export declarations yet\n// then we have to use `namespace` instead of export declarations for now.\n// See: https://github.com/TypeStrong/typedoc/pull/801\n\n// eslint-disable-next-line @typescript-eslint/no-namespace\nexport namespace VRMSchema {\n  /**\n   * VRM extension is for 3d humanoid avatars (and models) in VR applications.\n   */\n  export interface VRM {\n    blendShapeMaster?: BlendShape;\n    /**\n     * Version of exporter that vrm created. UniVRM-0.53.0\n     */\n    exporterVersion?: string;\n    firstPerson?: FirstPerson;\n    humanoid?: Humanoid;\n    materialProperties?: Material[];\n    meta?: Meta;\n    secondaryAnimation?: SecondaryAnimation;\n    /**\n     * Version of VRM specification. 0.0\n     */\n    specVersion?: string;\n  }\n\n  /**\n   * BlendShapeAvatar of UniVRM\n   */\n  export interface BlendShape {\n    blendShapeGroups?: BlendShapeGroup[];\n  }\n\n  export interface BlendShapeGroup {\n    /**\n     * Low level blendshape references.\n     */\n    binds?: BlendShapeBind[];\n    /**\n     * 0 or 1. Do not allow an intermediate value. Value should rounded\n     */\n    isBinary?: boolean;\n    /**\n     * Material animation references.\n     */\n    materialValues?: BlendShapeMaterialbind[];\n    /**\n     * Expression name\n     */\n    name?: string;\n    /**\n     * Predefined Expression name\n     */\n    presetName?: BlendShapePresetName;\n  }\n\n  export interface BlendShapeBind {\n    index?: number;\n    mesh?: number;\n    /**\n     * SkinnedMeshRenderer.SetBlendShapeWeight\n     */\n    weight?: number;\n  }\n\n  export interface BlendShapeMaterialbind {\n    materialName?: string;\n    propertyName?: string;\n    targetValue?: number[];\n  }\n\n  /**\n   * Predefined Expression name\n   */\n  export enum BlendShapePresetName {\n    A = 'a',\n    Angry = 'angry',\n    Blink = 'blink',\n    BlinkL = 'blink_l',\n    BlinkR = 'blink_r',\n    E = 'e',\n    Fun = 'fun',\n    I = 'i',\n    Joy = 'joy',\n    Lookdown = 'lookdown',\n    Lookleft = 'lookleft',\n    Lookright = 'lookright',\n    Lookup = 'lookup',\n    Neutral = 'neutral',\n    O = 'o',\n    Sorrow = 'sorrow',\n    U = 'u',\n    Unknown = 'unknown',\n  }\n\n  export interface FirstPerson {\n    /**\n     * The bone whose rendering should be turned off in first-person view. Usually Head is\n     * specified.\n     */\n    firstPersonBone?: number;\n    /**\n     * The target position of the VR headset in first-person view. It is assumed that an offset\n     * from the head bone to the VR headset is added.\n     */\n    firstPersonBoneOffset?: Vector3;\n    lookAtHorizontalInner?: FirstPersonDegreeMap;\n    lookAtHorizontalOuter?: FirstPersonDegreeMap;\n    /**\n     * Eye controller mode.\n     */\n    lookAtTypeName?: FirstPersonLookAtTypeName;\n    lookAtVerticalDown?: FirstPersonDegreeMap;\n    lookAtVerticalUp?: FirstPersonDegreeMap;\n    /**\n     * Switch display / undisplay for each mesh in first-person view or the others.\n     */\n    meshAnnotations?: FirstPersonMeshannotation[];\n  }\n\n  /**\n   * Eye controller setting.\n   */\n  export interface FirstPersonDegreeMap {\n    /**\n     * None linear mapping params. time, value, inTangent, outTangent\n     */\n    curve?: number[];\n    /**\n     * Look at input clamp range degree.\n     */\n    xRange?: number;\n    /**\n     * Look at map range degree from xRange.\n     */\n    yRange?: number;\n  }\n\n  /**\n   * Eye controller mode.\n   */\n  export enum FirstPersonLookAtTypeName {\n    BlendShape = 'BlendShape',\n    Bone = 'Bone',\n  }\n\n  export interface FirstPersonMeshannotation {\n    firstPersonFlag?: string;\n    mesh?: number;\n  }\n\n  export interface Humanoid {\n    /**\n     * Unity's HumanDescription.armStretch\n     */\n    armStretch?: number;\n    /**\n     * Unity's HumanDescription.feetSpacing\n     */\n    feetSpacing?: number;\n    /**\n     * Unity's HumanDescription.hasTranslationDoF\n     */\n    hasTranslationDoF?: boolean;\n    humanBones?: HumanoidBone[];\n    /**\n     * Unity's HumanDescription.legStretch\n     */\n    legStretch?: number;\n    /**\n     * Unity's HumanDescription.lowerArmTwist\n     */\n    lowerArmTwist?: number;\n    /**\n     * Unity's HumanDescription.lowerLegTwist\n     */\n    lowerLegTwist?: number;\n    /**\n     * Unity's HumanDescription.upperArmTwist\n     */\n    upperArmTwist?: number;\n    /**\n     * Unity's HumanDescription.upperLegTwist\n     */\n    upperLegTwist?: number;\n  }\n\n  export interface HumanoidBone {\n    /**\n     * Unity's HumanLimit.axisLength\n     */\n    axisLength?: number;\n    /**\n     * Human bone name.\n     */\n    bone?: HumanoidBoneName;\n    /**\n     * Unity's HumanLimit.center\n     */\n    center?: Vector3;\n    /**\n     * Unity's HumanLimit.max\n     */\n    max?: Vector3;\n    /**\n     * Unity's HumanLimit.min\n     */\n    min?: Vector3;\n    /**\n     * Reference node index\n     */\n    node?: number;\n    /**\n     * Unity's HumanLimit.useDefaultValues\n     */\n    useDefaultValues?: boolean;\n  }\n\n  /**\n   * Human bone name.\n   */\n  export enum HumanoidBoneName {\n    Chest = 'chest',\n    Head = 'head',\n    Hips = 'hips',\n    Jaw = 'jaw',\n    LeftEye = 'leftEye',\n    LeftFoot = 'leftFoot',\n    LeftHand = 'leftHand',\n    LeftIndexDistal = 'leftIndexDistal',\n    LeftIndexIntermediate = 'leftIndexIntermediate',\n    LeftIndexProximal = 'leftIndexProximal',\n    LeftLittleDistal = 'leftLittleDistal',\n    LeftLittleIntermediate = 'leftLittleIntermediate',\n    LeftLittleProximal = 'leftLittleProximal',\n    LeftLowerArm = 'leftLowerArm',\n    LeftLowerLeg = 'leftLowerLeg',\n    LeftMiddleDistal = 'leftMiddleDistal',\n    LeftMiddleIntermediate = 'leftMiddleIntermediate',\n    LeftMiddleProximal = 'leftMiddleProximal',\n    LeftRingDistal = 'leftRingDistal',\n    LeftRingIntermediate = 'leftRingIntermediate',\n    LeftRingProximal = 'leftRingProximal',\n    LeftShoulder = 'leftShoulder',\n    LeftThumbDistal = 'leftThumbDistal',\n    LeftThumbIntermediate = 'leftThumbIntermediate',\n    LeftThumbProximal = 'leftThumbProximal',\n    LeftToes = 'leftToes',\n    LeftUpperArm = 'leftUpperArm',\n    LeftUpperLeg = 'leftUpperLeg',\n    Neck = 'neck',\n    RightEye = 'rightEye',\n    RightFoot = 'rightFoot',\n    RightHand = 'rightHand',\n    RightIndexDistal = 'rightIndexDistal',\n    RightIndexIntermediate = 'rightIndexIntermediate',\n    RightIndexProximal = 'rightIndexProximal',\n    RightLittleDistal = 'rightLittleDistal',\n    RightLittleIntermediate = 'rightLittleIntermediate',\n    RightLittleProximal = 'rightLittleProximal',\n    RightLowerArm = 'rightLowerArm',\n    RightLowerLeg = 'rightLowerLeg',\n    RightMiddleDistal = 'rightMiddleDistal',\n    RightMiddleIntermediate = 'rightMiddleIntermediate',\n    RightMiddleProximal = 'rightMiddleProximal',\n    RightRingDistal = 'rightRingDistal',\n    RightRingIntermediate = 'rightRingIntermediate',\n    RightRingProximal = 'rightRingProximal',\n    RightShoulder = 'rightShoulder',\n    RightThumbDistal = 'rightThumbDistal',\n    RightThumbIntermediate = 'rightThumbIntermediate',\n    RightThumbProximal = 'rightThumbProximal',\n    RightToes = 'rightToes',\n    RightUpperArm = 'rightUpperArm',\n    RightUpperLeg = 'rightUpperLeg',\n    Spine = 'spine',\n    UpperChest = 'upperChest',\n  }\n\n  export interface Material {\n    floatProperties?: { [key: string]: any };\n    keywordMap?: { [key: string]: any };\n    name?: string;\n    renderQueue?: number;\n    shader?: string;\n    tagMap?: { [key: string]: any };\n    textureProperties?: { [key: string]: any };\n    vectorProperties?: { [key: string]: any };\n  }\n\n  export interface Meta {\n    /**\n     * A person who can perform with this avatar\n     */\n    allowedUserName?: MetaAllowedUserName;\n    /**\n     * Author of VRM model\n     */\n    author?: string;\n    /**\n     * For commercial use\n     */\n    commercialUssageName?: MetaUssageName;\n    /**\n     * Contact Information of VRM model author\n     */\n    contactInformation?: string;\n    /**\n     * License type\n     */\n    licenseName?: MetaLicenseName;\n    /**\n     * If “Other” is selected, put the URL link of the license document here.\n     */\n    otherLicenseUrl?: string;\n    /**\n     * If there are any conditions not mentioned above, put the URL link of the license document\n     * here.\n     */\n    otherPermissionUrl?: string;\n    /**\n     * Reference of VRM model\n     */\n    reference?: string;\n    /**\n     * Permission to perform sexual acts with this avatar\n     */\n    sexualUssageName?: MetaUssageName;\n    /**\n     * Thumbnail of VRM model\n     */\n    texture?: number;\n    /**\n     * Title of VRM model\n     */\n    title?: string;\n    /**\n     * Version of VRM model\n     */\n    version?: string;\n    /**\n     * Permission to perform violent acts with this avatar\n     */\n    violentUssageName?: MetaUssageName;\n  }\n\n  /**\n   * A person who can perform with this avatar\n   */\n  export enum MetaAllowedUserName {\n    Everyone = 'Everyone',\n    ExplicitlyLicensedPerson = 'ExplicitlyLicensedPerson',\n    OnlyAuthor = 'OnlyAuthor',\n  }\n\n  /**\n   * For commercial use\n   *\n   * Permission to perform sexual acts with this avatar\n   *\n   * Permission to perform violent acts with this avatar\n   */\n  export enum MetaUssageName {\n    Allow = 'Allow',\n    Disallow = 'Disallow',\n  }\n\n  /**\n   * License type\n   */\n  export enum MetaLicenseName {\n    Cc0 = 'CC0',\n    CcBy = 'CC_BY',\n    CcByNc = 'CC_BY_NC',\n    CcByNcNd = 'CC_BY_NC_ND',\n    CcByNcSa = 'CC_BY_NC_SA',\n    CcByNd = 'CC_BY_ND',\n    CcBySa = 'CC_BY_SA',\n    Other = 'Other',\n    RedistributionProhibited = 'Redistribution_Prohibited',\n  }\n\n  /**\n   * The setting of automatic animation of string-like objects such as tails and hairs.\n   */\n  export interface SecondaryAnimation {\n    boneGroups?: SecondaryAnimationSpring[];\n    colliderGroups?: SecondaryAnimationCollidergroup[];\n  }\n\n  export interface SecondaryAnimationSpring {\n    /**\n     * Specify the node index of the root bone of the swaying object.\n     */\n    bones?: number[];\n    /**\n     * The reference point of a swaying object can be set at any location except the origin.\n     * When implementing UI moving with warp, the parent node to move with warp can be specified\n     * if you don't want to make the object swaying with warp movement.\n     */\n    center?: number;\n    /**\n     * Specify the index of the collider group for collisions with swaying objects.\n     */\n    colliderGroups?: number[];\n    /**\n     * Annotation comment\n     */\n    comment?: string;\n    /**\n     * The resistance (deceleration) of automatic animation.\n     */\n    dragForce?: number;\n    /**\n     * The direction of gravity. Set (0, -1, 0) for simulating the gravity. Set (1, 0, 0) for\n     * simulating the wind.\n     */\n    gravityDir?: Vector3;\n    /**\n     * The strength of gravity.\n     */\n    gravityPower?: number;\n    /**\n     * The radius of the sphere used for the collision detection with colliders.\n     */\n    hitRadius?: number;\n    /**\n     * The resilience of the swaying object (the power of returning to the initial pose).\n     */\n    stiffiness?: number;\n  }\n\n  export interface SecondaryAnimationCollidergroup {\n    colliders?: SecondaryAnimationCollider[];\n    /**\n     * The node of the collider group for setting up collision detections.\n     */\n    node?: number;\n  }\n\n  export interface SecondaryAnimationCollider {\n    /**\n     * The local coordinate from the node of the collider group.\n     */\n    offset?: Vector3;\n    /**\n     * The radius of the collider.\n     */\n    radius?: number;\n  }\n\n  export interface Vector3 {\n    x?: number;\n    y?: number;\n    z?: number;\n  }\n}\n","// Typedoc does not support export declarations yet\n// then we have to use `namespace` instead of export declarations for now.\n// See: https://github.com/TypeStrong/typedoc/pull/801\n\n// import * as GLTFSchema from './GLTFSchema';\n// import * as VRMSchema from './VRMSchema';\n\n// export { GLTFSchema, VRMSchema };\n\nexport * from './GLTFSchema';\nexport * from './VRMSchema';\n\nexport * from './types';\n","import * as THREE from 'three';\n\nfunction disposeMaterial(material: any): void {\n  Object.keys(material).forEach((propertyName) => {\n    if (!!material[propertyName] && typeof material[propertyName].dispose === 'function') {\n      material[propertyName].dispose();\n    }\n  });\n\n  material.dispose();\n  material = undefined;\n}\n\nfunction dispose(object3D: any): void {\n  if (object3D.geometry) {\n    object3D.geometry.dispose();\n    object3D.geometry = undefined;\n  }\n\n  if (!!object3D.material && Array.isArray(object3D.material)) {\n    object3D.material.forEach((material: THREE.Material) => disposeMaterial(material));\n  } else if (object3D.material) {\n    disposeMaterial(object3D.material);\n  }\n}\n\nexport function deepDispose(object3D: THREE.Object3D): void {\n  object3D.traverse(dispose);\n}\n","import * as THREE from 'three';\n\n/**\n * Clamp an input number within [ `0.0` - `1.0` ].\n *\n * @param value The input value\n */\nexport function saturate(value: number): number {\n  return Math.max(Math.min(value, 1.0), 0.0);\n}\n\n/**\n * Map the range of an input value from [ `min` - `max` ] to [ `0.0` - `1.0` ].\n * If input value is less than `min` , it returns `0.0`.\n * If input value is greater than `max` , it returns `1.0`.\n *\n * See also: https://threejs.org/docs/#api/en/math/Math.smoothstep\n *\n * @param x The value that will be mapped into the specified range\n * @param min Minimum value of the range\n * @param max Maximum value of the range\n */\nexport function linstep(x: number, min: number, max: number): number {\n  if (x <= min) return 0;\n  if (x >= max) return 1;\n\n  return (x - min) / (max - min);\n}\n\nconst _position = new THREE.Vector3();\nconst _scale = new THREE.Vector3();\nconst _rotation = new THREE.Quaternion();\n\n/**\n * Extract world position of an object from its world space matrix, in cheaper way.\n *\n * @param object The object\n * @param out Target vector\n */\nexport function getWorldPositionLite(object: THREE.Object3D, out: THREE.Vector3): THREE.Vector3 {\n  object.matrixWorld.decompose(out, _rotation, _scale);\n  return out;\n}\n\n/**\n * Extract world scale of an object from its world space matrix, in cheaper way.\n *\n * @param object The object\n * @param out Target vector\n */\nexport function getWorldScaleLite(object: THREE.Object3D, out: THREE.Vector3): THREE.Vector3 {\n  object.matrixWorld.decompose(_position, _rotation, out);\n  return out;\n}\n\n/**\n * Extract world rotation of an object from its world space matrix, in cheaper way.\n *\n * @param object The object\n * @param out Target vector\n */\nexport function getWorldQuaternionLite(object: THREE.Object3D, out: THREE.Quaternion): THREE.Quaternion {\n  object.matrixWorld.decompose(_position, out, _scale);\n  return out;\n}\n","export function renameMaterialProperty(name: string): string {\n  if (name[0] !== '_') {\n    console.warn(`renameMaterialProperty: Given property name \"${name}\" might be invalid`);\n    return name;\n  }\n  name = name.substring(1);\n\n  if (!/[A-Z]/.test(name[0])) {\n    console.warn(`renameMaterialProperty: Given property name \"${name}\" might be invalid`);\n    return name;\n  }\n  return name[0].toLowerCase() + name.substring(1);\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}