{"ast":null,"code":"import THREE from 'three';\n\nvar __three_vrm__ =\n/******/\nfunction (modules) {\n  // webpackBootstrap\n\n  /******/\n  // The module cache\n\n  /******/\n  var installedModules = {};\n  /******/\n\n  /******/\n  // The require function\n\n  /******/\n\n  function __webpack_require__(moduleId) {\n    /******/\n\n    /******/\n    // Check if module is in cache\n\n    /******/\n    if (installedModules[moduleId]) {\n      /******/\n      return installedModules[moduleId].exports;\n      /******/\n    }\n    /******/\n    // Create a new module (and put it into the cache)\n\n    /******/\n\n\n    var module = installedModules[moduleId] = {\n      /******/\n      i: moduleId,\n\n      /******/\n      l: false,\n\n      /******/\n      exports: {}\n      /******/\n\n    };\n    /******/\n\n    /******/\n    // Execute the module function\n\n    /******/\n\n    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n    /******/\n\n    /******/\n    // Flag the module as loaded\n\n    /******/\n\n    module.l = true;\n    /******/\n\n    /******/\n    // Return the exports of the module\n\n    /******/\n\n    return module.exports;\n    /******/\n  }\n  /******/\n\n  /******/\n\n  /******/\n  // expose the modules object (__webpack_modules__)\n\n  /******/\n\n\n  __webpack_require__.m = modules;\n  /******/\n\n  /******/\n  // expose the module cache\n\n  /******/\n\n  __webpack_require__.c = installedModules;\n  /******/\n\n  /******/\n  // define getter function for harmony exports\n\n  /******/\n\n  __webpack_require__.d = function (exports, name, getter) {\n    /******/\n    if (!__webpack_require__.o(exports, name)) {\n      /******/\n      Object.defineProperty(exports, name, {\n        enumerable: true,\n        get: getter\n      });\n      /******/\n    }\n    /******/\n\n  };\n  /******/\n\n  /******/\n  // define __esModule on exports\n\n  /******/\n\n\n  __webpack_require__.r = function (exports) {\n    /******/\n    if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n      /******/\n      Object.defineProperty(exports, Symbol.toStringTag, {\n        value: 'Module'\n      });\n      /******/\n    }\n    /******/\n\n\n    Object.defineProperty(exports, '__esModule', {\n      value: true\n    });\n    /******/\n  };\n  /******/\n\n  /******/\n  // create a fake namespace object\n\n  /******/\n  // mode & 1: value is a module id, require it\n\n  /******/\n  // mode & 2: merge all properties of value into the ns\n\n  /******/\n  // mode & 4: return value when already ns object\n\n  /******/\n  // mode & 8|1: behave like require\n\n  /******/\n\n\n  __webpack_require__.t = function (value, mode) {\n    /******/\n    if (mode & 1) value = __webpack_require__(value);\n    /******/\n\n    if (mode & 8) return value;\n    /******/\n\n    if (mode & 4 && typeof value === 'object' && value && value.__esModule) return value;\n    /******/\n\n    var ns = Object.create(null);\n    /******/\n\n    __webpack_require__.r(ns);\n    /******/\n\n\n    Object.defineProperty(ns, 'default', {\n      enumerable: true,\n      value: value\n    });\n    /******/\n\n    if (mode & 2 && typeof value != 'string') for (var key in value) __webpack_require__.d(ns, key, function (key) {\n      return value[key];\n    }.bind(null, key));\n    /******/\n\n    return ns;\n    /******/\n  };\n  /******/\n\n  /******/\n  // getDefaultExport function for compatibility with non-harmony modules\n\n  /******/\n\n\n  __webpack_require__.n = function (module) {\n    /******/\n    var getter = module && module.__esModule ?\n    /******/\n    function getDefault() {\n      return module['default'];\n    } :\n    /******/\n    function getModuleExports() {\n      return module;\n    };\n    /******/\n\n    __webpack_require__.d(getter, 'a', getter);\n    /******/\n\n\n    return getter;\n    /******/\n  };\n  /******/\n\n  /******/\n  // Object.prototype.hasOwnProperty.call\n\n  /******/\n\n\n  __webpack_require__.o = function (object, property) {\n    return Object.prototype.hasOwnProperty.call(object, property);\n  };\n  /******/\n\n  /******/\n  // __webpack_public_path__\n\n  /******/\n\n\n  __webpack_require__.p = \"\";\n  /******/\n\n  /******/\n\n  /******/\n  // Load entry module and return exports\n\n  /******/\n\n  return __webpack_require__(__webpack_require__.s = \"./src/assign.ts\");\n  /******/\n}(\n/************************************************************************/\n\n/******/\n{\n  /***/\n  \"./src/assign.ts\":\n  /*!***********************!*\\\r\n    !*** ./src/assign.ts ***!\r\n    \\***********************/\n\n  /*! no static exports found */\n\n  /***/\n  function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n\n    var __three_vrm__ = __webpack_require__(\n    /*! . */\n    \"./src/index.ts\");\n\n    Object.assign(THREE, __three_vrm__);\n    /***/\n  },\n\n  /***/\n  \"./src/index.ts\":\n  /*!**********************!*\\\r\n    !*** ./src/index.ts ***!\r\n    \\**********************/\n\n  /*! no static exports found */\n\n  /***/\n  function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    function __export(m) {\n      for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n    }\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n\n    __export(__webpack_require__(\n    /*! ./vrm/ */\n    \"./src/vrm/index.ts\"));\n    /***/\n\n  },\n\n  /***/\n  \"./src/vrm/VRM.ts\":\n  /*!************************!*\\\r\n    !*** ./src/vrm/VRM.ts ***!\r\n    \\************************/\n\n  /*! no static exports found */\n\n  /***/\n  function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n      return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) {\n          try {\n            step(generator.next(value));\n          } catch (e) {\n            reject(e);\n          }\n        }\n\n        function rejected(value) {\n          try {\n            step(generator[\"throw\"](value));\n          } catch (e) {\n            reject(e);\n          }\n        }\n\n        function step(result) {\n          result.done ? resolve(result.value) : new P(function (resolve) {\n            resolve(result.value);\n          }).then(fulfilled, rejected);\n        }\n\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n      });\n    };\n\n    var __generator = this && this.__generator || function (thisArg, body) {\n      var _ = {\n        label: 0,\n        sent: function () {\n          if (t[0] & 1) throw t[1];\n          return t[1];\n        },\n        trys: [],\n        ops: []\n      },\n          f,\n          y,\n          t,\n          g;\n      return g = {\n        next: verb(0),\n        \"throw\": verb(1),\n        \"return\": verb(2)\n      }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n        return this;\n      }), g;\n\n      function verb(n) {\n        return function (v) {\n          return step([n, v]);\n        };\n      }\n\n      function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n\n        while (_) try {\n          if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n          if (y = 0, t) op = [op[0] & 2, t.value];\n\n          switch (op[0]) {\n            case 0:\n            case 1:\n              t = op;\n              break;\n\n            case 4:\n              _.label++;\n              return {\n                value: op[1],\n                done: false\n              };\n\n            case 5:\n              _.label++;\n              y = op[1];\n              op = [0];\n              continue;\n\n            case 7:\n              op = _.ops.pop();\n\n              _.trys.pop();\n\n              continue;\n\n            default:\n              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n                _ = 0;\n                continue;\n              }\n\n              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n                _.label = op[1];\n                break;\n              }\n\n              if (op[0] === 6 && _.label < t[1]) {\n                _.label = t[1];\n                t = op;\n                break;\n              }\n\n              if (t && _.label < t[2]) {\n                _.label = t[2];\n\n                _.ops.push(op);\n\n                break;\n              }\n\n              if (t[2]) _.ops.pop();\n\n              _.trys.pop();\n\n              continue;\n          }\n\n          op = body.call(thisArg, _);\n        } catch (e) {\n          op = [6, e];\n          y = 0;\n        } finally {\n          f = t = 0;\n        }\n\n        if (op[0] & 5) throw op[1];\n        return {\n          value: op[0] ? op[1] : void 0,\n          done: true\n        };\n      }\n    };\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n\n    var disposer_1 = __webpack_require__(\n    /*! ./utils/disposer */\n    \"./src/vrm/utils/disposer.ts\");\n\n    var VRMImporter_1 = __webpack_require__(\n    /*! ./VRMImporter */\n    \"./src/vrm/VRMImporter.ts\");\n\n    var VRM = function () {\n      function VRM(params) {\n        this.scene = params.scene;\n        this.humanoid = params.humanoid;\n        this.blendShapeProxy = params.blendShapeProxy;\n        this.firstPerson = params.firstPerson;\n        this.lookAt = params.lookAt;\n        this.materials = params.materials;\n        this.springBoneManager = params.springBoneManager;\n        this.meta = params.meta;\n      }\n\n      VRM.from = function (gltf, options) {\n        if (options === void 0) {\n          options = {};\n        }\n\n        return __awaiter(this, void 0, Promise, function () {\n          var importer;\n          return __generator(this, function (_a) {\n            switch (_a.label) {\n              case 0:\n                importer = new VRMImporter_1.VRMImporter(options);\n                return [4, importer.import(gltf)];\n\n              case 1:\n                return [2, _a.sent()];\n            }\n          });\n        });\n      };\n\n      VRM.prototype.update = function (delta) {\n        if (this.lookAt) {\n          this.lookAt.update(delta);\n        }\n\n        if (this.blendShapeProxy) {\n          this.blendShapeProxy.update();\n        }\n\n        if (this.springBoneManager) {\n          this.springBoneManager.lateUpdate(delta);\n        }\n\n        if (this.materials) {\n          this.materials.forEach(function (material) {\n            if (material.updateVRMMaterials) {\n              material.updateVRMMaterials(delta);\n            }\n          });\n        }\n      };\n\n      VRM.prototype.dispose = function () {\n        var scene = this.scene;\n\n        if (scene) {\n          while (scene.children.length > 0) {\n            var object = scene.children[scene.children.length - 1];\n            disposer_1.deepDispose(object);\n            scene.remove(object);\n          }\n        }\n      };\n\n      return VRM;\n    }();\n\n    exports.VRM = VRM;\n    /***/\n  },\n\n  /***/\n  \"./src/vrm/VRMImporter.ts\":\n  /*!********************************!*\\\r\n    !*** ./src/vrm/VRMImporter.ts ***!\r\n    \\********************************/\n\n  /*! no static exports found */\n\n  /***/\n  function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n      return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) {\n          try {\n            step(generator.next(value));\n          } catch (e) {\n            reject(e);\n          }\n        }\n\n        function rejected(value) {\n          try {\n            step(generator[\"throw\"](value));\n          } catch (e) {\n            reject(e);\n          }\n        }\n\n        function step(result) {\n          result.done ? resolve(result.value) : new P(function (resolve) {\n            resolve(result.value);\n          }).then(fulfilled, rejected);\n        }\n\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n      });\n    };\n\n    var __generator = this && this.__generator || function (thisArg, body) {\n      var _ = {\n        label: 0,\n        sent: function () {\n          if (t[0] & 1) throw t[1];\n          return t[1];\n        },\n        trys: [],\n        ops: []\n      },\n          f,\n          y,\n          t,\n          g;\n      return g = {\n        next: verb(0),\n        \"throw\": verb(1),\n        \"return\": verb(2)\n      }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n        return this;\n      }), g;\n\n      function verb(n) {\n        return function (v) {\n          return step([n, v]);\n        };\n      }\n\n      function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n\n        while (_) try {\n          if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n          if (y = 0, t) op = [op[0] & 2, t.value];\n\n          switch (op[0]) {\n            case 0:\n            case 1:\n              t = op;\n              break;\n\n            case 4:\n              _.label++;\n              return {\n                value: op[1],\n                done: false\n              };\n\n            case 5:\n              _.label++;\n              y = op[1];\n              op = [0];\n              continue;\n\n            case 7:\n              op = _.ops.pop();\n\n              _.trys.pop();\n\n              continue;\n\n            default:\n              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n                _ = 0;\n                continue;\n              }\n\n              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n                _.label = op[1];\n                break;\n              }\n\n              if (op[0] === 6 && _.label < t[1]) {\n                _.label = t[1];\n                t = op;\n                break;\n              }\n\n              if (t && _.label < t[2]) {\n                _.label = t[2];\n\n                _.ops.push(op);\n\n                break;\n              }\n\n              if (t[2]) _.ops.pop();\n\n              _.trys.pop();\n\n              continue;\n          }\n\n          op = body.call(thisArg, _);\n        } catch (e) {\n          op = [6, e];\n          y = 0;\n        } finally {\n          f = t = 0;\n        }\n\n        if (op[0] & 5) throw op[1];\n        return {\n          value: op[0] ? op[1] : void 0,\n          done: true\n        };\n      }\n    };\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n\n    var blendshape_1 = __webpack_require__(\n    /*! ./blendshape */\n    \"./src/vrm/blendshape/index.ts\");\n\n    var firstperson_1 = __webpack_require__(\n    /*! ./firstperson */\n    \"./src/vrm/firstperson/index.ts\");\n\n    var VRMHumanoidImporter_1 = __webpack_require__(\n    /*! ./humanoid/VRMHumanoidImporter */\n    \"./src/vrm/humanoid/VRMHumanoidImporter.ts\");\n\n    var VRMLookAtImporter_1 = __webpack_require__(\n    /*! ./lookat/VRMLookAtImporter */\n    \"./src/vrm/lookat/VRMLookAtImporter.ts\");\n\n    var material_1 = __webpack_require__(\n    /*! ./material */\n    \"./src/vrm/material/index.ts\");\n\n    var reduceBones_1 = __webpack_require__(\n    /*! ./reduceBones */\n    \"./src/vrm/reduceBones.ts\");\n\n    var VRMSpringBoneImporter_1 = __webpack_require__(\n    /*! ./springbone/VRMSpringBoneImporter */\n    \"./src/vrm/springbone/VRMSpringBoneImporter.ts\");\n\n    var VRM_1 = __webpack_require__(\n    /*! ./VRM */\n    \"./src/vrm/VRM.ts\");\n\n    var VRMImporter = function () {\n      function VRMImporter(options) {\n        if (options === void 0) {\n          options = {};\n        }\n\n        this._blendShapeImporter = options.blendShapeImporter || new blendshape_1.VRMBlendShapeImporter();\n        this._lookAtImporter = options.lookAtImporter || new VRMLookAtImporter_1.VRMLookAtImporter();\n        this._humanoidImporter = options.humanoidImporter || new VRMHumanoidImporter_1.VRMHumanoidImporter();\n        this._firstPersonImporter = options.firstPersonImporter || new firstperson_1.VRMFirstPersonImporter();\n        this._materialImporter = options.materialImporter || new material_1.VRMMaterialImporter();\n        this._springBoneImporter = options.springBoneImporter || new VRMSpringBoneImporter_1.VRMSpringBoneImporter();\n      }\n\n      VRMImporter.prototype.import = function (gltf) {\n        return __awaiter(this, void 0, Promise, function () {\n          var vrmExt, scene, materials, humanoid, firstPerson, _a, blendShapeProxy, lookAt, _b, springBoneManager;\n\n          return __generator(this, function (_c) {\n            switch (_c.label) {\n              case 0:\n                if (gltf.parser.json.extensions === undefined || gltf.parser.json.extensions.VRM === undefined) {\n                  throw new Error('Could not find VRM extension on the GLTF');\n                }\n\n                vrmExt = gltf.parser.json.extensions.VRM;\n                scene = gltf.scene;\n                scene.updateMatrixWorld(false);\n                scene.traverse(function (object3d) {\n                  if (object3d.isMesh) {\n                    object3d.frustumCulled = false;\n                  }\n                });\n                reduceBones_1.reduceBones(scene);\n                return [4, this._materialImporter.convertGLTFMaterials(gltf)];\n\n              case 1:\n                materials = _c.sent() || undefined;\n                return [4, this._humanoidImporter.import(gltf)];\n\n              case 2:\n                humanoid = _c.sent() || undefined;\n                if (!humanoid) return [3, 4];\n                return [4, this._firstPersonImporter.import(gltf, humanoid)];\n\n              case 3:\n                _a = _c.sent() || undefined;\n                return [3, 5];\n\n              case 4:\n                _a = undefined;\n                _c.label = 5;\n\n              case 5:\n                firstPerson = _a;\n                return [4, this._blendShapeImporter.import(gltf)];\n\n              case 6:\n                blendShapeProxy = _c.sent() || undefined;\n                if (!(firstPerson && blendShapeProxy && humanoid)) return [3, 8];\n                return [4, this._lookAtImporter.import(gltf, firstPerson, blendShapeProxy, humanoid)];\n\n              case 7:\n                _b = _c.sent() || undefined;\n                return [3, 9];\n\n              case 8:\n                _b = undefined;\n                _c.label = 9;\n\n              case 9:\n                lookAt = _b;\n                return [4, this._springBoneImporter.import(gltf)];\n\n              case 10:\n                springBoneManager = _c.sent() || undefined;\n                return [2, new VRM_1.VRM({\n                  scene: gltf.scene,\n                  meta: vrmExt.meta,\n                  materials: materials,\n                  humanoid: humanoid,\n                  firstPerson: firstPerson,\n                  blendShapeProxy: blendShapeProxy,\n                  lookAt: lookAt,\n                  springBoneManager: springBoneManager\n                })];\n            }\n          });\n        });\n      };\n\n      return VRMImporter;\n    }();\n\n    exports.VRMImporter = VRMImporter;\n    /***/\n  },\n\n  /***/\n  \"./src/vrm/blendshape/VRMBlendShapeGroup.ts\":\n  /*!**************************************************!*\\\r\n    !*** ./src/vrm/blendshape/VRMBlendShapeGroup.ts ***!\r\n    \\**************************************************/\n\n  /*! no static exports found */\n\n  /***/\n  function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    var __extends = this && this.__extends || function () {\n      var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (d, b) {\n          d.__proto__ = b;\n        } || function (d, b) {\n          for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n        };\n\n        return extendStatics(d, b);\n      };\n\n      return function (d, b) {\n        extendStatics(d, b);\n\n        function __() {\n          this.constructor = d;\n        }\n\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n      };\n    }();\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n\n    var THREE = __webpack_require__(\n    /*! three */\n    \"three\");\n\n    var VRMBlendShapeMaterialValueType;\n\n    (function (VRMBlendShapeMaterialValueType) {\n      VRMBlendShapeMaterialValueType[VRMBlendShapeMaterialValueType[\"NUMBER\"] = 0] = \"NUMBER\";\n      VRMBlendShapeMaterialValueType[VRMBlendShapeMaterialValueType[\"VECTOR2\"] = 1] = \"VECTOR2\";\n      VRMBlendShapeMaterialValueType[VRMBlendShapeMaterialValueType[\"VECTOR3\"] = 2] = \"VECTOR3\";\n      VRMBlendShapeMaterialValueType[VRMBlendShapeMaterialValueType[\"VECTOR4\"] = 3] = \"VECTOR4\";\n      VRMBlendShapeMaterialValueType[VRMBlendShapeMaterialValueType[\"COLOR\"] = 4] = \"COLOR\";\n    })(VRMBlendShapeMaterialValueType || (VRMBlendShapeMaterialValueType = {}));\n\n    var _v2 = new THREE.Vector2();\n\n    var _v3 = new THREE.Vector3();\n\n    var _v4 = new THREE.Vector4();\n\n    var _color = new THREE.Color();\n\n    var VRMBlendShapeGroup = function (_super) {\n      __extends(VRMBlendShapeGroup, _super);\n\n      function VRMBlendShapeGroup(expressionName) {\n        var _this = _super.call(this) || this;\n\n        _this.weight = 0.0;\n        _this.isBinary = false;\n        _this._binds = [];\n        _this._materialValues = [];\n        _this.name = \"BlendShapeController_\" + expressionName;\n        _this.type = 'BlendShapeController';\n        _this.visible = false;\n        return _this;\n      }\n\n      VRMBlendShapeGroup.prototype.addBind = function (args) {\n        var weight = args.weight / 100;\n\n        this._binds.push({\n          meshes: args.meshes,\n          morphTargetIndex: args.morphTargetIndex,\n          weight: weight\n        });\n      };\n\n      VRMBlendShapeGroup.prototype.addMaterialValue = function (args) {\n        var material = args.material;\n        var propertyName = args.propertyName;\n        var value = material[propertyName];\n\n        if (!value) {\n          return;\n        }\n\n        value = args.defaultValue || value;\n        var type;\n        var defaultValue;\n        var targetValue;\n        var deltaValue;\n\n        if (value.isVector2) {\n          type = VRMBlendShapeMaterialValueType.VECTOR2;\n          defaultValue = value.clone();\n          targetValue = new THREE.Vector2().fromArray(args.targetValue);\n          deltaValue = targetValue.clone().sub(defaultValue);\n        } else if (value.isVector3) {\n          type = VRMBlendShapeMaterialValueType.VECTOR3;\n          defaultValue = value.clone();\n          targetValue = new THREE.Vector3().fromArray(args.targetValue);\n          deltaValue = targetValue.clone().sub(defaultValue);\n        } else if (value.isVector4) {\n          type = VRMBlendShapeMaterialValueType.VECTOR4;\n          defaultValue = value.clone();\n          targetValue = new THREE.Vector4().fromArray([args.targetValue[2], args.targetValue[3], args.targetValue[0], args.targetValue[1]]);\n          deltaValue = targetValue.clone().sub(defaultValue);\n        } else if (value.isColor) {\n          type = VRMBlendShapeMaterialValueType.COLOR;\n          defaultValue = value.clone();\n          targetValue = new THREE.Color().fromArray(args.targetValue);\n          deltaValue = targetValue.clone().sub(defaultValue);\n        } else {\n          type = VRMBlendShapeMaterialValueType.NUMBER;\n          defaultValue = value;\n          targetValue = args.targetValue[0];\n          deltaValue = targetValue - defaultValue;\n        }\n\n        this._materialValues.push({\n          material: material,\n          propertyName: propertyName,\n          defaultValue: defaultValue,\n          targetValue: targetValue,\n          deltaValue: deltaValue,\n          type: type\n        });\n      };\n\n      VRMBlendShapeGroup.prototype.applyWeight = function () {\n        var w = this.isBinary ? this.weight < 0.5 ? 0.0 : 1.0 : this.weight;\n\n        this._binds.forEach(function (bind) {\n          bind.meshes.forEach(function (mesh) {\n            if (!mesh.morphTargetInfluences) {\n              return;\n            }\n\n            mesh.morphTargetInfluences[bind.morphTargetIndex] += w * bind.weight;\n          });\n        });\n\n        this._materialValues.forEach(function (materialValue) {\n          var prop = materialValue.material[materialValue.propertyName];\n\n          if (prop === undefined) {\n            return;\n          }\n\n          if (materialValue.type === VRMBlendShapeMaterialValueType.NUMBER) {\n            var deltaValue = materialValue.deltaValue;\n            materialValue.material[materialValue.propertyName] += deltaValue * w;\n          } else if (materialValue.type === VRMBlendShapeMaterialValueType.VECTOR2) {\n            var deltaValue = materialValue.deltaValue;\n            materialValue.material[materialValue.propertyName].add(_v2.copy(deltaValue).multiplyScalar(w));\n          } else if (materialValue.type === VRMBlendShapeMaterialValueType.VECTOR3) {\n            var deltaValue = materialValue.deltaValue;\n            materialValue.material[materialValue.propertyName].add(_v3.copy(deltaValue).multiplyScalar(w));\n          } else if (materialValue.type === VRMBlendShapeMaterialValueType.VECTOR4) {\n            var deltaValue = materialValue.deltaValue;\n            materialValue.material[materialValue.propertyName].add(_v4.copy(deltaValue).multiplyScalar(w));\n          } else if (materialValue.type === VRMBlendShapeMaterialValueType.COLOR) {\n            var deltaValue = materialValue.deltaValue;\n            materialValue.material[materialValue.propertyName].add(_color.copy(deltaValue).multiplyScalar(w));\n          }\n\n          if (typeof materialValue.material.shouldApplyUniforms === 'boolean') {\n            materialValue.material.shouldApplyUniforms = true;\n          }\n        });\n      };\n\n      VRMBlendShapeGroup.prototype.clearAppliedWeight = function () {\n        this._binds.forEach(function (bind) {\n          bind.meshes.forEach(function (mesh) {\n            if (!mesh.morphTargetInfluences) {\n              return;\n            }\n\n            mesh.morphTargetInfluences[bind.morphTargetIndex] = 0.0;\n          });\n        });\n\n        this._materialValues.forEach(function (materialValue) {\n          var prop = materialValue.material[materialValue.propertyName];\n\n          if (prop === undefined) {\n            return;\n          }\n\n          if (materialValue.type === VRMBlendShapeMaterialValueType.NUMBER) {\n            var defaultValue = materialValue.defaultValue;\n            materialValue.material[materialValue.propertyName] = defaultValue;\n          } else if (materialValue.type === VRMBlendShapeMaterialValueType.VECTOR2) {\n            var defaultValue = materialValue.defaultValue;\n            materialValue.material[materialValue.propertyName].copy(defaultValue);\n          } else if (materialValue.type === VRMBlendShapeMaterialValueType.VECTOR3) {\n            var defaultValue = materialValue.defaultValue;\n            materialValue.material[materialValue.propertyName].copy(defaultValue);\n          } else if (materialValue.type === VRMBlendShapeMaterialValueType.VECTOR4) {\n            var defaultValue = materialValue.defaultValue;\n            materialValue.material[materialValue.propertyName].copy(defaultValue);\n          } else if (materialValue.type === VRMBlendShapeMaterialValueType.COLOR) {\n            var defaultValue = materialValue.defaultValue;\n            materialValue.material[materialValue.propertyName].copy(defaultValue);\n          }\n\n          if (typeof materialValue.material.shouldApplyUniforms === 'boolean') {\n            materialValue.material.shouldApplyUniforms = true;\n          }\n        });\n      };\n\n      return VRMBlendShapeGroup;\n    }(THREE.Object3D);\n\n    exports.VRMBlendShapeGroup = VRMBlendShapeGroup;\n    /***/\n  },\n\n  /***/\n  \"./src/vrm/blendshape/VRMBlendShapeImporter.ts\":\n  /*!*****************************************************!*\\\r\n    !*** ./src/vrm/blendshape/VRMBlendShapeImporter.ts ***!\r\n    \\*****************************************************/\n\n  /*! no static exports found */\n\n  /***/\n  function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n      return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) {\n          try {\n            step(generator.next(value));\n          } catch (e) {\n            reject(e);\n          }\n        }\n\n        function rejected(value) {\n          try {\n            step(generator[\"throw\"](value));\n          } catch (e) {\n            reject(e);\n          }\n        }\n\n        function step(result) {\n          result.done ? resolve(result.value) : new P(function (resolve) {\n            resolve(result.value);\n          }).then(fulfilled, rejected);\n        }\n\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n      });\n    };\n\n    var __generator = this && this.__generator || function (thisArg, body) {\n      var _ = {\n        label: 0,\n        sent: function () {\n          if (t[0] & 1) throw t[1];\n          return t[1];\n        },\n        trys: [],\n        ops: []\n      },\n          f,\n          y,\n          t,\n          g;\n      return g = {\n        next: verb(0),\n        \"throw\": verb(1),\n        \"return\": verb(2)\n      }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n        return this;\n      }), g;\n\n      function verb(n) {\n        return function (v) {\n          return step([n, v]);\n        };\n      }\n\n      function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n\n        while (_) try {\n          if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n          if (y = 0, t) op = [op[0] & 2, t.value];\n\n          switch (op[0]) {\n            case 0:\n            case 1:\n              t = op;\n              break;\n\n            case 4:\n              _.label++;\n              return {\n                value: op[1],\n                done: false\n              };\n\n            case 5:\n              _.label++;\n              y = op[1];\n              op = [0];\n              continue;\n\n            case 7:\n              op = _.ops.pop();\n\n              _.trys.pop();\n\n              continue;\n\n            default:\n              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n                _ = 0;\n                continue;\n              }\n\n              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n                _.label = op[1];\n                break;\n              }\n\n              if (op[0] === 6 && _.label < t[1]) {\n                _.label = t[1];\n                t = op;\n                break;\n              }\n\n              if (t && _.label < t[2]) {\n                _.label = t[2];\n\n                _.ops.push(op);\n\n                break;\n              }\n\n              if (t[2]) _.ops.pop();\n\n              _.trys.pop();\n\n              continue;\n          }\n\n          op = body.call(thisArg, _);\n        } catch (e) {\n          op = [6, e];\n          y = 0;\n        } finally {\n          f = t = 0;\n        }\n\n        if (op[0] & 5) throw op[1];\n        return {\n          value: op[0] ? op[1] : void 0,\n          done: true\n        };\n      }\n    };\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n\n    var types_1 = __webpack_require__(\n    /*! ../types */\n    \"./src/vrm/types/index.ts\");\n\n    var renameMaterialProperty_1 = __webpack_require__(\n    /*! ../utils/renameMaterialProperty */\n    \"./src/vrm/utils/renameMaterialProperty.ts\");\n\n    var VRMBlendShapeGroup_1 = __webpack_require__(\n    /*! ./VRMBlendShapeGroup */\n    \"./src/vrm/blendshape/VRMBlendShapeGroup.ts\");\n\n    var VRMBlendShapeProxy_1 = __webpack_require__(\n    /*! ./VRMBlendShapeProxy */\n    \"./src/vrm/blendshape/VRMBlendShapeProxy.ts\");\n\n    var VRMBlendShapeImporter = function () {\n      function VRMBlendShapeImporter() {}\n\n      VRMBlendShapeImporter.prototype.import = function (gltf) {\n        return __awaiter(this, void 0, Promise, function () {\n          var vrmExt, schemaBlendShape, blendShape, blendShapeGroups, blendShapePresetMap;\n\n          var _this = this;\n\n          return __generator(this, function (_a) {\n            switch (_a.label) {\n              case 0:\n                vrmExt = gltf.parser.json.extensions && gltf.parser.json.extensions.VRM;\n\n                if (!vrmExt) {\n                  return [2, null];\n                }\n\n                schemaBlendShape = vrmExt.blendShapeMaster;\n\n                if (!schemaBlendShape) {\n                  return [2, null];\n                }\n\n                blendShape = new VRMBlendShapeProxy_1.VRMBlendShapeProxy();\n                blendShapeGroups = schemaBlendShape.blendShapeGroups;\n\n                if (!blendShapeGroups) {\n                  return [2, blendShape];\n                }\n\n                blendShapePresetMap = {};\n                return [4, Promise.all(blendShapeGroups.map(function (schemaGroup) {\n                  return __awaiter(_this, void 0, void 0, function () {\n                    var name, presetName, group, materialValues;\n\n                    var _this = this;\n\n                    return __generator(this, function (_a) {\n                      name = schemaGroup.name;\n\n                      if (name === undefined) {\n                        console.warn('VRMBlendShapeImporter: One of blendShapeGroups has no name');\n                        return [2];\n                      }\n\n                      if (schemaGroup.presetName && schemaGroup.presetName !== types_1.VRMSchema.BlendShapePresetName.Unknown && !blendShapePresetMap[schemaGroup.presetName]) {\n                        presetName = schemaGroup.presetName;\n                        blendShapePresetMap[schemaGroup.presetName] = name;\n                      }\n\n                      group = new VRMBlendShapeGroup_1.VRMBlendShapeGroup(name);\n                      gltf.scene.add(group);\n                      group.isBinary = schemaGroup.isBinary || false;\n\n                      if (schemaGroup.binds) {\n                        schemaGroup.binds.forEach(function (bind) {\n                          return __awaiter(_this, void 0, void 0, function () {\n                            var morphMeshes, primitives, morphTargetIndex;\n                            return __generator(this, function (_a) {\n                              switch (_a.label) {\n                                case 0:\n                                  if (bind.mesh === undefined || bind.index === undefined) {\n                                    return [2];\n                                  }\n\n                                  return [4, gltf.parser.getDependency('mesh', bind.mesh)];\n\n                                case 1:\n                                  morphMeshes = _a.sent();\n                                  primitives = morphMeshes.type === 'Group' ? morphMeshes.children : [morphMeshes];\n                                  morphTargetIndex = bind.index;\n\n                                  if (!primitives.every(function (primitive) {\n                                    return Array.isArray(primitive.morphTargetInfluences) && morphTargetIndex < primitive.morphTargetInfluences.length;\n                                  })) {\n                                    console.warn(\"VRMBlendShapeImporter: \" + schemaGroup.name + \" attempts to index \" + morphTargetIndex + \"th morph but not found.\");\n                                    return [2];\n                                  }\n\n                                  group.addBind({\n                                    meshes: primitives,\n                                    morphTargetIndex: morphTargetIndex,\n                                    weight: bind.weight || 100\n                                  });\n                                  return [2];\n                              }\n                            });\n                          });\n                        });\n                      }\n\n                      materialValues = schemaGroup.materialValues;\n\n                      if (materialValues) {\n                        materialValues.forEach(function (materialValue) {\n                          if (materialValue.materialName === undefined || materialValue.propertyName === undefined || materialValue.targetValue === undefined) {\n                            return;\n                          }\n\n                          var materials = [];\n                          gltf.scene.traverse(function (object) {\n                            if (object.material) {\n                              var material = object.material;\n\n                              if (Array.isArray(material)) {\n                                materials.push.apply(materials, material.filter(function (mtl) {\n                                  return mtl.name === materialValue.materialName && materials.indexOf(mtl) === -1;\n                                }));\n                              } else if (material.name === materialValue.materialName && materials.indexOf(material) === -1) {\n                                materials.push(material);\n                              }\n                            }\n                          });\n                          materials.forEach(function (material) {\n                            group.addMaterialValue({\n                              material: material,\n                              propertyName: renameMaterialProperty_1.renameMaterialProperty(materialValue.propertyName),\n                              targetValue: materialValue.targetValue\n                            });\n                          });\n                        });\n                      }\n\n                      blendShape.registerBlendShapeGroup(name, presetName, group);\n                      return [2];\n                    });\n                  });\n                }))];\n\n              case 1:\n                _a.sent();\n\n                return [2, blendShape];\n            }\n          });\n        });\n      };\n\n      return VRMBlendShapeImporter;\n    }();\n\n    exports.VRMBlendShapeImporter = VRMBlendShapeImporter;\n    /***/\n  },\n\n  /***/\n  \"./src/vrm/blendshape/VRMBlendShapeProxy.ts\":\n  /*!**************************************************!*\\\r\n    !*** ./src/vrm/blendshape/VRMBlendShapeProxy.ts ***!\r\n    \\**************************************************/\n\n  /*! no static exports found */\n\n  /***/\n  function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n\n    var math_1 = __webpack_require__(\n    /*! ../utils/math */\n    \"./src/vrm/utils/math.ts\");\n\n    var VRMBlendShapeProxy = function () {\n      function VRMBlendShapeProxy() {\n        this._blendShapeGroups = {};\n        this._blendShapePresetMap = {};\n      }\n\n      Object.defineProperty(VRMBlendShapeProxy.prototype, \"expressions\", {\n        get: function () {\n          return Object.keys(this._blendShapeGroups);\n        },\n        enumerable: true,\n        configurable: true\n      });\n\n      VRMBlendShapeProxy.prototype.getBlendShapeGroup = function (name) {\n        var presetName = this._blendShapePresetMap[name];\n        var controller = presetName ? this._blendShapeGroups[presetName] : this._blendShapeGroups[name];\n\n        if (!controller) {\n          console.warn(\"no blend shape found by \" + name);\n          return undefined;\n        }\n\n        return controller;\n      };\n\n      VRMBlendShapeProxy.prototype.registerBlendShapeGroup = function (name, presetName, controller) {\n        this._blendShapeGroups[name] = controller;\n\n        if (presetName) {\n          this._blendShapePresetMap[presetName] = name;\n        }\n      };\n\n      VRMBlendShapeProxy.prototype.getValue = function (name) {\n        var controller = this.getBlendShapeGroup(name);\n        return controller && controller.weight || null;\n      };\n\n      VRMBlendShapeProxy.prototype.setValue = function (name, weight) {\n        var controller = this.getBlendShapeGroup(name);\n\n        if (controller) {\n          controller.weight = math_1.saturate(weight);\n        }\n      };\n\n      VRMBlendShapeProxy.prototype.getBlendShapeTrackName = function (name) {\n        var controller = this.getBlendShapeGroup(name);\n        return controller ? controller.name + \".weight\" : null;\n      };\n\n      VRMBlendShapeProxy.prototype.update = function () {\n        var _this = this;\n\n        Object.keys(this._blendShapeGroups).forEach(function (name) {\n          var controller = _this._blendShapeGroups[name];\n          controller.clearAppliedWeight();\n        });\n        Object.keys(this._blendShapeGroups).forEach(function (name) {\n          var controller = _this._blendShapeGroups[name];\n          controller.applyWeight();\n        });\n      };\n\n      return VRMBlendShapeProxy;\n    }();\n\n    exports.VRMBlendShapeProxy = VRMBlendShapeProxy;\n    /***/\n  },\n\n  /***/\n  \"./src/vrm/blendshape/index.ts\":\n  /*!*************************************!*\\\r\n    !*** ./src/vrm/blendshape/index.ts ***!\r\n    \\*************************************/\n\n  /*! no static exports found */\n\n  /***/\n  function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    function __export(m) {\n      for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n    }\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n\n    __export(__webpack_require__(\n    /*! ./VRMBlendShapeGroup */\n    \"./src/vrm/blendshape/VRMBlendShapeGroup.ts\"));\n\n    __export(__webpack_require__(\n    /*! ./VRMBlendShapeImporter */\n    \"./src/vrm/blendshape/VRMBlendShapeImporter.ts\"));\n\n    __export(__webpack_require__(\n    /*! ./VRMBlendShapeProxy */\n    \"./src/vrm/blendshape/VRMBlendShapeProxy.ts\"));\n    /***/\n\n  },\n\n  /***/\n  \"./src/vrm/debug/VRMDebug.ts\":\n  /*!***********************************!*\\\r\n    !*** ./src/vrm/debug/VRMDebug.ts ***!\r\n    \\***********************************/\n\n  /*! no static exports found */\n\n  /***/\n  function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    var __extends = this && this.__extends || function () {\n      var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (d, b) {\n          d.__proto__ = b;\n        } || function (d, b) {\n          for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n        };\n\n        return extendStatics(d, b);\n      };\n\n      return function (d, b) {\n        extendStatics(d, b);\n\n        function __() {\n          this.constructor = d;\n        }\n\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n      };\n    }();\n\n    var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n      return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) {\n          try {\n            step(generator.next(value));\n          } catch (e) {\n            reject(e);\n          }\n        }\n\n        function rejected(value) {\n          try {\n            step(generator[\"throw\"](value));\n          } catch (e) {\n            reject(e);\n          }\n        }\n\n        function step(result) {\n          result.done ? resolve(result.value) : new P(function (resolve) {\n            resolve(result.value);\n          }).then(fulfilled, rejected);\n        }\n\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n      });\n    };\n\n    var __generator = this && this.__generator || function (thisArg, body) {\n      var _ = {\n        label: 0,\n        sent: function () {\n          if (t[0] & 1) throw t[1];\n          return t[1];\n        },\n        trys: [],\n        ops: []\n      },\n          f,\n          y,\n          t,\n          g;\n      return g = {\n        next: verb(0),\n        \"throw\": verb(1),\n        \"return\": verb(2)\n      }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n        return this;\n      }), g;\n\n      function verb(n) {\n        return function (v) {\n          return step([n, v]);\n        };\n      }\n\n      function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n\n        while (_) try {\n          if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n          if (y = 0, t) op = [op[0] & 2, t.value];\n\n          switch (op[0]) {\n            case 0:\n            case 1:\n              t = op;\n              break;\n\n            case 4:\n              _.label++;\n              return {\n                value: op[1],\n                done: false\n              };\n\n            case 5:\n              _.label++;\n              y = op[1];\n              op = [0];\n              continue;\n\n            case 7:\n              op = _.ops.pop();\n\n              _.trys.pop();\n\n              continue;\n\n            default:\n              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n                _ = 0;\n                continue;\n              }\n\n              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n                _.label = op[1];\n                break;\n              }\n\n              if (op[0] === 6 && _.label < t[1]) {\n                _.label = t[1];\n                t = op;\n                break;\n              }\n\n              if (t && _.label < t[2]) {\n                _.label = t[2];\n\n                _.ops.push(op);\n\n                break;\n              }\n\n              if (t[2]) _.ops.pop();\n\n              _.trys.pop();\n\n              continue;\n          }\n\n          op = body.call(thisArg, _);\n        } catch (e) {\n          op = [6, e];\n          y = 0;\n        } finally {\n          f = t = 0;\n        }\n\n        if (op[0] & 5) throw op[1];\n        return {\n          value: op[0] ? op[1] : void 0,\n          done: true\n        };\n      }\n    };\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n\n    var THREE = __webpack_require__(\n    /*! three */\n    \"three\");\n\n    var VRM_1 = __webpack_require__(\n    /*! ../VRM */\n    \"./src/vrm/VRM.ts\");\n\n    var VRMImporterDebug_1 = __webpack_require__(\n    /*! ./VRMImporterDebug */\n    \"./src/vrm/debug/VRMImporterDebug.ts\");\n\n    var VRMDebug = function (_super) {\n      __extends(VRMDebug, _super);\n\n      function VRMDebug(params, debugOption) {\n        if (debugOption === void 0) {\n          debugOption = {};\n        }\n\n        var _this = _super.call(this, params) || this;\n\n        if (!debugOption.disableBoxHelper) {\n          _this.scene.add(new THREE.BoxHelper(_this.scene));\n        }\n\n        if (!debugOption.disableSkeletonHelper) {\n          _this.scene.add(new THREE.SkeletonHelper(_this.scene));\n        }\n\n        return _this;\n      }\n\n      VRMDebug.from = function (gltf, options, debugOption) {\n        if (options === void 0) {\n          options = {};\n        }\n\n        if (debugOption === void 0) {\n          debugOption = {};\n        }\n\n        return __awaiter(this, void 0, Promise, function () {\n          var importer;\n          return __generator(this, function (_a) {\n            switch (_a.label) {\n              case 0:\n                importer = new VRMImporterDebug_1.VRMImporterDebug(options);\n                return [4, importer.import(gltf, debugOption)];\n\n              case 1:\n                return [2, _a.sent()];\n            }\n          });\n        });\n      };\n\n      VRMDebug.prototype.update = function (delta) {\n        _super.prototype.update.call(this, delta);\n      };\n\n      return VRMDebug;\n    }(VRM_1.VRM);\n\n    exports.VRMDebug = VRMDebug;\n    /***/\n  },\n\n  /***/\n  \"./src/vrm/debug/VRMDebugOptions.ts\":\n  /*!******************************************!*\\\r\n    !*** ./src/vrm/debug/VRMDebugOptions.ts ***!\r\n    \\******************************************/\n\n  /*! no static exports found */\n\n  /***/\n  function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n    /***/\n  },\n\n  /***/\n  \"./src/vrm/debug/VRMImporterDebug.ts\":\n  /*!*******************************************!*\\\r\n    !*** ./src/vrm/debug/VRMImporterDebug.ts ***!\r\n    \\*******************************************/\n\n  /*! no static exports found */\n\n  /***/\n  function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    var __extends = this && this.__extends || function () {\n      var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (d, b) {\n          d.__proto__ = b;\n        } || function (d, b) {\n          for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n        };\n\n        return extendStatics(d, b);\n      };\n\n      return function (d, b) {\n        extendStatics(d, b);\n\n        function __() {\n          this.constructor = d;\n        }\n\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n      };\n    }();\n\n    var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n      return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) {\n          try {\n            step(generator.next(value));\n          } catch (e) {\n            reject(e);\n          }\n        }\n\n        function rejected(value) {\n          try {\n            step(generator[\"throw\"](value));\n          } catch (e) {\n            reject(e);\n          }\n        }\n\n        function step(result) {\n          result.done ? resolve(result.value) : new P(function (resolve) {\n            resolve(result.value);\n          }).then(fulfilled, rejected);\n        }\n\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n      });\n    };\n\n    var __generator = this && this.__generator || function (thisArg, body) {\n      var _ = {\n        label: 0,\n        sent: function () {\n          if (t[0] & 1) throw t[1];\n          return t[1];\n        },\n        trys: [],\n        ops: []\n      },\n          f,\n          y,\n          t,\n          g;\n      return g = {\n        next: verb(0),\n        \"throw\": verb(1),\n        \"return\": verb(2)\n      }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n        return this;\n      }), g;\n\n      function verb(n) {\n        return function (v) {\n          return step([n, v]);\n        };\n      }\n\n      function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n\n        while (_) try {\n          if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n          if (y = 0, t) op = [op[0] & 2, t.value];\n\n          switch (op[0]) {\n            case 0:\n            case 1:\n              t = op;\n              break;\n\n            case 4:\n              _.label++;\n              return {\n                value: op[1],\n                done: false\n              };\n\n            case 5:\n              _.label++;\n              y = op[1];\n              op = [0];\n              continue;\n\n            case 7:\n              op = _.ops.pop();\n\n              _.trys.pop();\n\n              continue;\n\n            default:\n              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n                _ = 0;\n                continue;\n              }\n\n              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n                _.label = op[1];\n                break;\n              }\n\n              if (op[0] === 6 && _.label < t[1]) {\n                _.label = t[1];\n                t = op;\n                break;\n              }\n\n              if (t && _.label < t[2]) {\n                _.label = t[2];\n\n                _.ops.push(op);\n\n                break;\n              }\n\n              if (t[2]) _.ops.pop();\n\n              _.trys.pop();\n\n              continue;\n          }\n\n          op = body.call(thisArg, _);\n        } catch (e) {\n          op = [6, e];\n          y = 0;\n        } finally {\n          f = t = 0;\n        }\n\n        if (op[0] & 5) throw op[1];\n        return {\n          value: op[0] ? op[1] : void 0,\n          done: true\n        };\n      }\n    };\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n\n    var reduceBones_1 = __webpack_require__(\n    /*! ../reduceBones */\n    \"./src/vrm/reduceBones.ts\");\n\n    var VRMImporter_1 = __webpack_require__(\n    /*! ../VRMImporter */\n    \"./src/vrm/VRMImporter.ts\");\n\n    var VRMDebug_1 = __webpack_require__(\n    /*! ./VRMDebug */\n    \"./src/vrm/debug/VRMDebug.ts\");\n\n    var VRMLookAtImporterDebug_1 = __webpack_require__(\n    /*! ./VRMLookAtImporterDebug */\n    \"./src/vrm/debug/VRMLookAtImporterDebug.ts\");\n\n    var VRMSpringBoneImporterDebug_1 = __webpack_require__(\n    /*! ./VRMSpringBoneImporterDebug */\n    \"./src/vrm/debug/VRMSpringBoneImporterDebug.ts\");\n\n    var VRMImporterDebug = function (_super) {\n      __extends(VRMImporterDebug, _super);\n\n      function VRMImporterDebug(options) {\n        if (options === void 0) {\n          options = {};\n        }\n\n        var _this = this;\n\n        options.lookAtImporter = options.lookAtImporter || new VRMLookAtImporterDebug_1.VRMLookAtImporterDebug();\n        options.springBoneImporter = options.springBoneImporter || new VRMSpringBoneImporterDebug_1.VRMSpringBoneImporterDebug();\n        _this = _super.call(this, options) || this;\n        return _this;\n      }\n\n      VRMImporterDebug.prototype.import = function (gltf, debugOptions) {\n        if (debugOptions === void 0) {\n          debugOptions = {};\n        }\n\n        return __awaiter(this, void 0, Promise, function () {\n          var vrmExt, scene, materials, humanoid, firstPerson, _a, blendShapeProxy, lookAt, _b, springBoneManager;\n\n          return __generator(this, function (_c) {\n            switch (_c.label) {\n              case 0:\n                if (gltf.parser.json.extensions === undefined || gltf.parser.json.extensions.VRM === undefined) {\n                  throw new Error('Could not find VRM extension on the GLTF');\n                }\n\n                vrmExt = gltf.parser.json.extensions.VRM;\n                scene = gltf.scene;\n                scene.updateMatrixWorld(false);\n                scene.traverse(function (object3d) {\n                  if (object3d.isMesh) {\n                    object3d.frustumCulled = false;\n                  }\n                });\n                reduceBones_1.reduceBones(scene);\n                return [4, this._materialImporter.convertGLTFMaterials(gltf)];\n\n              case 1:\n                materials = _c.sent() || undefined;\n                return [4, this._humanoidImporter.import(gltf)];\n\n              case 2:\n                humanoid = _c.sent() || undefined;\n                if (!humanoid) return [3, 4];\n                return [4, this._firstPersonImporter.import(gltf, humanoid)];\n\n              case 3:\n                _a = _c.sent() || undefined;\n                return [3, 5];\n\n              case 4:\n                _a = undefined;\n                _c.label = 5;\n\n              case 5:\n                firstPerson = _a;\n                return [4, this._blendShapeImporter.import(gltf)];\n\n              case 6:\n                blendShapeProxy = _c.sent() || undefined;\n                if (!(firstPerson && blendShapeProxy && humanoid)) return [3, 8];\n                return [4, this._lookAtImporter.import(gltf, firstPerson, blendShapeProxy, humanoid)];\n\n              case 7:\n                _b = _c.sent() || undefined;\n                return [3, 9];\n\n              case 8:\n                _b = undefined;\n                _c.label = 9;\n\n              case 9:\n                lookAt = _b;\n\n                if (lookAt.setupHelper) {\n                  lookAt.setupHelper(scene, debugOptions);\n                }\n\n                return [4, this._springBoneImporter.import(gltf)];\n\n              case 10:\n                springBoneManager = _c.sent() || undefined;\n                return [2, new VRMDebug_1.VRMDebug({\n                  scene: gltf.scene,\n                  meta: vrmExt.meta,\n                  materials: materials,\n                  humanoid: humanoid,\n                  firstPerson: firstPerson,\n                  blendShapeProxy: blendShapeProxy,\n                  lookAt: lookAt,\n                  springBoneManager: springBoneManager\n                }, debugOptions)];\n            }\n          });\n        });\n      };\n\n      return VRMImporterDebug;\n    }(VRMImporter_1.VRMImporter);\n\n    exports.VRMImporterDebug = VRMImporterDebug;\n    /***/\n  },\n\n  /***/\n  \"./src/vrm/debug/VRMLookAtHeadDebug.ts\":\n  /*!*********************************************!*\\\r\n    !*** ./src/vrm/debug/VRMLookAtHeadDebug.ts ***!\r\n    \\*********************************************/\n\n  /*! no static exports found */\n\n  /***/\n  function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    var __extends = this && this.__extends || function () {\n      var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (d, b) {\n          d.__proto__ = b;\n        } || function (d, b) {\n          for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n        };\n\n        return extendStatics(d, b);\n      };\n\n      return function (d, b) {\n        extendStatics(d, b);\n\n        function __() {\n          this.constructor = d;\n        }\n\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n      };\n    }();\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n\n    var THREE = __webpack_require__(\n    /*! three */\n    \"three\");\n\n    var VRMLookAtHead_1 = __webpack_require__(\n    /*! ../lookat/VRMLookAtHead */\n    \"./src/vrm/lookat/VRMLookAtHead.ts\");\n\n    var _v3 = new THREE.Vector3();\n\n    var VRMLookAtHeadDebug = function (_super) {\n      __extends(VRMLookAtHeadDebug, _super);\n\n      function VRMLookAtHeadDebug() {\n        return _super !== null && _super.apply(this, arguments) || this;\n      }\n\n      VRMLookAtHeadDebug.prototype.setupHelper = function (scene, debugOption) {\n        if (!debugOption.disableFaceDirectionHelper) {\n          this._faceDirectionHelper = new THREE.ArrowHelper(new THREE.Vector3(0, 0, -1), new THREE.Vector3(0, 0, 0), 0.5, 0xff00ff);\n          scene.add(this._faceDirectionHelper);\n        }\n      };\n\n      VRMLookAtHeadDebug.prototype.update = function (delta) {\n        _super.prototype.update.call(this, delta);\n\n        if (this._faceDirectionHelper) {\n          this.firstPerson.getFirstPersonWorldPosition(this._faceDirectionHelper.position);\n\n          this._faceDirectionHelper.setDirection(this.getLookAtWorldDirection(_v3));\n        }\n      };\n\n      return VRMLookAtHeadDebug;\n    }(VRMLookAtHead_1.VRMLookAtHead);\n\n    exports.VRMLookAtHeadDebug = VRMLookAtHeadDebug;\n    /***/\n  },\n\n  /***/\n  \"./src/vrm/debug/VRMLookAtImporterDebug.ts\":\n  /*!*************************************************!*\\\r\n    !*** ./src/vrm/debug/VRMLookAtImporterDebug.ts ***!\r\n    \\*************************************************/\n\n  /*! no static exports found */\n\n  /***/\n  function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    var __extends = this && this.__extends || function () {\n      var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (d, b) {\n          d.__proto__ = b;\n        } || function (d, b) {\n          for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n        };\n\n        return extendStatics(d, b);\n      };\n\n      return function (d, b) {\n        extendStatics(d, b);\n\n        function __() {\n          this.constructor = d;\n        }\n\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n      };\n    }();\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n\n    var VRMLookAtImporter_1 = __webpack_require__(\n    /*! ../lookat/VRMLookAtImporter */\n    \"./src/vrm/lookat/VRMLookAtImporter.ts\");\n\n    var VRMLookAtHeadDebug_1 = __webpack_require__(\n    /*! ./VRMLookAtHeadDebug */\n    \"./src/vrm/debug/VRMLookAtHeadDebug.ts\");\n\n    var VRMLookAtImporterDebug = function (_super) {\n      __extends(VRMLookAtImporterDebug, _super);\n\n      function VRMLookAtImporterDebug() {\n        return _super !== null && _super.apply(this, arguments) || this;\n      }\n\n      VRMLookAtImporterDebug.prototype.import = function (gltf, firstPerson, blendShapeProxy, humanoid) {\n        var vrmExt = gltf.parser.json.extensions && gltf.parser.json.extensions.VRM;\n\n        if (!vrmExt) {\n          return null;\n        }\n\n        var schemaFirstPerson = vrmExt.firstPerson;\n\n        if (!schemaFirstPerson) {\n          return null;\n        }\n\n        var applyer = this._importApplyer(schemaFirstPerson, blendShapeProxy, humanoid);\n\n        return new VRMLookAtHeadDebug_1.VRMLookAtHeadDebug(firstPerson, applyer || undefined);\n      };\n\n      return VRMLookAtImporterDebug;\n    }(VRMLookAtImporter_1.VRMLookAtImporter);\n\n    exports.VRMLookAtImporterDebug = VRMLookAtImporterDebug;\n    /***/\n  },\n\n  /***/\n  \"./src/vrm/debug/VRMSpringBoneDebug.ts\":\n  /*!*********************************************!*\\\r\n    !*** ./src/vrm/debug/VRMSpringBoneDebug.ts ***!\r\n    \\*********************************************/\n\n  /*! no static exports found */\n\n  /***/\n  function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    var __extends = this && this.__extends || function () {\n      var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (d, b) {\n          d.__proto__ = b;\n        } || function (d, b) {\n          for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n        };\n\n        return extendStatics(d, b);\n      };\n\n      return function (d, b) {\n        extendStatics(d, b);\n\n        function __() {\n          this.constructor = d;\n        }\n\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n      };\n    }();\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n\n    var THREE = __webpack_require__(\n    /*! three */\n    \"three\");\n\n    var springbone_1 = __webpack_require__(\n    /*! ../springbone */\n    \"./src/vrm/springbone/index.ts\");\n\n    var _v3A = new THREE.Vector3();\n\n    var VRMSpringBoneDebug = function (_super) {\n      __extends(VRMSpringBoneDebug, _super);\n\n      function VRMSpringBoneDebug(bone, radius, stiffiness, gravityDir, gravityPower, dragForce, colliders) {\n        if (colliders === void 0) {\n          colliders = [];\n        }\n\n        return _super.call(this, bone, radius, stiffiness, gravityDir, gravityPower, dragForce, colliders) || this;\n      }\n\n      VRMSpringBoneDebug.prototype.getGizmo = function () {\n        if (this._gizmo) {\n          return this._gizmo;\n        }\n\n        var nextTailRelative = _v3A.copy(this._nextTail).sub(this._worldPosition);\n\n        var nextTailRelativeLength = nextTailRelative.length();\n        this._gizmo = new THREE.ArrowHelper(nextTailRelative.normalize(), this._worldPosition, nextTailRelativeLength, 0xffff00, this.radius, this.radius);\n        this._gizmo.line.renderOrder = springbone_1.GIZMO_RENDER_ORDER;\n        this._gizmo.cone.renderOrder = springbone_1.GIZMO_RENDER_ORDER;\n        this._gizmo.line.material.depthTest = false;\n        this._gizmo.line.material.transparent = true;\n        this._gizmo.cone.material.depthTest = false;\n        this._gizmo.cone.material.transparent = true;\n        return this._gizmo;\n      };\n\n      VRMSpringBoneDebug.prototype.update = function (delta) {\n        _super.prototype.update.call(this, delta);\n\n        this._updateGizmo();\n      };\n\n      VRMSpringBoneDebug.prototype._updateGizmo = function () {\n        if (!this._gizmo) {\n          return;\n        }\n\n        var nextTailRelative = _v3A.copy(this._currentTail).sub(this._worldPosition);\n\n        var nextTailRelativeLength = nextTailRelative.length();\n\n        this._gizmo.setDirection(nextTailRelative.normalize());\n\n        this._gizmo.setLength(nextTailRelativeLength, this.radius, this.radius);\n\n        this._gizmo.position.copy(this._worldPosition);\n      };\n\n      return VRMSpringBoneDebug;\n    }(springbone_1.VRMSpringBone);\n\n    exports.VRMSpringBoneDebug = VRMSpringBoneDebug;\n    /***/\n  },\n\n  /***/\n  \"./src/vrm/debug/VRMSpringBoneImporterDebug.ts\":\n  /*!*****************************************************!*\\\r\n    !*** ./src/vrm/debug/VRMSpringBoneImporterDebug.ts ***!\r\n    \\*****************************************************/\n\n  /*! no static exports found */\n\n  /***/\n  function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    var __extends = this && this.__extends || function () {\n      var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (d, b) {\n          d.__proto__ = b;\n        } || function (d, b) {\n          for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n        };\n\n        return extendStatics(d, b);\n      };\n\n      return function (d, b) {\n        extendStatics(d, b);\n\n        function __() {\n          this.constructor = d;\n        }\n\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n      };\n    }();\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n\n    var VRMSpringBoneImporter_1 = __webpack_require__(\n    /*! ../springbone/VRMSpringBoneImporter */\n    \"./src/vrm/springbone/VRMSpringBoneImporter.ts\");\n\n    var VRMSpringBoneDebug_1 = __webpack_require__(\n    /*! ./VRMSpringBoneDebug */\n    \"./src/vrm/debug/VRMSpringBoneDebug.ts\");\n\n    var VRMSpringBoneImporterDebug = function (_super) {\n      __extends(VRMSpringBoneImporterDebug, _super);\n\n      function VRMSpringBoneImporterDebug() {\n        return _super !== null && _super.apply(this, arguments) || this;\n      }\n\n      Object.defineProperty(VRMSpringBoneImporterDebug.prototype, \"_isColiderMeshVisible\", {\n        get: function () {\n          return true;\n        },\n        enumerable: true,\n        configurable: true\n      });\n\n      VRMSpringBoneImporterDebug.prototype._createSpringBone = function (gltf, bone, hitRadius, stiffiness, gravityDir, gravityPower, dragForce, colliders) {\n        if (colliders === void 0) {\n          colliders = [];\n        }\n\n        var springBone = new VRMSpringBoneDebug_1.VRMSpringBoneDebug(bone, hitRadius, stiffiness, gravityDir, gravityPower, dragForce, colliders);\n        gltf.scene.add(springBone.getGizmo());\n        return springBone;\n      };\n\n      return VRMSpringBoneImporterDebug;\n    }(VRMSpringBoneImporter_1.VRMSpringBoneImporter);\n\n    exports.VRMSpringBoneImporterDebug = VRMSpringBoneImporterDebug;\n    /***/\n  },\n\n  /***/\n  \"./src/vrm/debug/index.ts\":\n  /*!********************************!*\\\r\n    !*** ./src/vrm/debug/index.ts ***!\r\n    \\********************************/\n\n  /*! no static exports found */\n\n  /***/\n  function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    function __export(m) {\n      for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n    }\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n\n    __export(__webpack_require__(\n    /*! ./VRMDebugOptions */\n    \"./src/vrm/debug/VRMDebugOptions.ts\"));\n\n    __export(__webpack_require__(\n    /*! ./VRMDebug */\n    \"./src/vrm/debug/VRMDebug.ts\"));\n\n    __export(__webpack_require__(\n    /*! ./VRMSpringBoneDebug */\n    \"./src/vrm/debug/VRMSpringBoneDebug.ts\"));\n\n    __export(__webpack_require__(\n    /*! ./VRMSpringBoneImporterDebug */\n    \"./src/vrm/debug/VRMSpringBoneImporterDebug.ts\"));\n    /***/\n\n  },\n\n  /***/\n  \"./src/vrm/firstperson/VRMFirstPerson.ts\":\n  /*!***********************************************!*\\\r\n    !*** ./src/vrm/firstperson/VRMFirstPerson.ts ***!\r\n    \\***********************************************/\n\n  /*! no static exports found */\n\n  /***/\n  function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n\n    var THREE = __webpack_require__(\n    /*! three */\n    \"three\");\n\n    var math_1 = __webpack_require__(\n    /*! ../utils/math */\n    \"./src/vrm/utils/math.ts\");\n\n    var VECTOR3_FRONT = Object.freeze(new THREE.Vector3(0.0, 0.0, -1.0));\n\n    var _quat = new THREE.Quaternion();\n\n    var FirstPersonFlag;\n\n    (function (FirstPersonFlag) {\n      FirstPersonFlag[FirstPersonFlag[\"Auto\"] = 0] = \"Auto\";\n      FirstPersonFlag[FirstPersonFlag[\"Both\"] = 1] = \"Both\";\n      FirstPersonFlag[FirstPersonFlag[\"ThirdPersonOnly\"] = 2] = \"ThirdPersonOnly\";\n      FirstPersonFlag[FirstPersonFlag[\"FirstPersonOnly\"] = 3] = \"FirstPersonOnly\";\n    })(FirstPersonFlag || (FirstPersonFlag = {}));\n\n    var VRMRendererFirstPersonFlags = function () {\n      function VRMRendererFirstPersonFlags(firstPersonFlag, mesh) {\n        this.firstPersonFlag = VRMRendererFirstPersonFlags._parseFirstPersonFlag(firstPersonFlag);\n        this.mesh = mesh;\n      }\n\n      VRMRendererFirstPersonFlags._parseFirstPersonFlag = function (firstPersonFlag) {\n        switch (firstPersonFlag) {\n          case 'Both':\n            return FirstPersonFlag.Both;\n\n          case 'ThirdPersonOnly':\n            return FirstPersonFlag.ThirdPersonOnly;\n\n          case 'FirstPersonOnly':\n            return FirstPersonFlag.FirstPersonOnly;\n\n          default:\n            return FirstPersonFlag.Auto;\n        }\n      };\n\n      return VRMRendererFirstPersonFlags;\n    }();\n\n    exports.VRMRendererFirstPersonFlags = VRMRendererFirstPersonFlags;\n\n    var VRMFirstPerson = function () {\n      function VRMFirstPerson(firstPersonBone, firstPersonBoneOffset, meshAnnotations) {\n        this._meshAnnotations = [];\n        this._firstPersonOnlyLayer = VRMFirstPerson._DEFAULT_FIRSTPERSON_ONLY_LAYER;\n        this._thirdPersonOnlyLayer = VRMFirstPerson._DEFAULT_THIRDPERSON_ONLY_LAYER;\n        this._initialized = false;\n        this._firstPersonBone = firstPersonBone;\n        this._firstPersonBoneOffset = firstPersonBoneOffset;\n        this._meshAnnotations = meshAnnotations;\n      }\n\n      Object.defineProperty(VRMFirstPerson.prototype, \"firstPersonBone\", {\n        get: function () {\n          return this._firstPersonBone;\n        },\n        enumerable: true,\n        configurable: true\n      });\n      Object.defineProperty(VRMFirstPerson.prototype, \"meshAnnotations\", {\n        get: function () {\n          return this._meshAnnotations;\n        },\n        enumerable: true,\n        configurable: true\n      });\n\n      VRMFirstPerson.prototype.getFirstPersonWorldDirection = function (target) {\n        return target.copy(VECTOR3_FRONT).applyQuaternion(math_1.getWorldQuaternionLite(this._firstPersonBone, _quat));\n      };\n\n      Object.defineProperty(VRMFirstPerson.prototype, \"firstPersonOnlyLayer\", {\n        get: function () {\n          return this._firstPersonOnlyLayer;\n        },\n        enumerable: true,\n        configurable: true\n      });\n      Object.defineProperty(VRMFirstPerson.prototype, \"thirdPersonOnlyLayer\", {\n        get: function () {\n          return this._thirdPersonOnlyLayer;\n        },\n        enumerable: true,\n        configurable: true\n      });\n\n      VRMFirstPerson.prototype.getFirstPersonBoneOffset = function (target) {\n        return target.copy(this._firstPersonBoneOffset);\n      };\n\n      VRMFirstPerson.prototype.getFirstPersonWorldPosition = function (v3) {\n        var offset = this._firstPersonBoneOffset;\n        var v4 = new THREE.Vector4(offset.x, offset.y, offset.z, 1.0);\n        v4.applyMatrix4(this._firstPersonBone.matrixWorld);\n        return v3.set(v4.x, v4.y, v4.z);\n      };\n\n      VRMFirstPerson.prototype.setup = function (_a) {\n        var _this = this;\n\n        var _b = _a === void 0 ? {} : _a,\n            _c = _b.firstPersonOnlyLayer,\n            firstPersonOnlyLayer = _c === void 0 ? VRMFirstPerson._DEFAULT_FIRSTPERSON_ONLY_LAYER : _c,\n            _d = _b.thirdPersonOnlyLayer,\n            thirdPersonOnlyLayer = _d === void 0 ? VRMFirstPerson._DEFAULT_THIRDPERSON_ONLY_LAYER : _d;\n\n        if (this._initialized) {\n          return;\n        }\n\n        this._initialized = true;\n        this._firstPersonOnlyLayer = firstPersonOnlyLayer;\n        this._thirdPersonOnlyLayer = thirdPersonOnlyLayer;\n\n        this._meshAnnotations.forEach(function (item) {\n          if (item.firstPersonFlag === FirstPersonFlag.FirstPersonOnly) {\n            item.mesh.layers.set(_this._firstPersonOnlyLayer);\n            item.mesh.traverse(function (child) {\n              return child.layers.set(_this._firstPersonOnlyLayer);\n            });\n          } else if (item.firstPersonFlag === FirstPersonFlag.ThirdPersonOnly) {\n            item.mesh.layers.set(_this._thirdPersonOnlyLayer);\n            item.mesh.traverse(function (child) {\n              return child.layers.set(_this._thirdPersonOnlyLayer);\n            });\n          } else if (item.firstPersonFlag === FirstPersonFlag.Auto) {\n            _this._createHeadlessModel(item.mesh);\n          }\n        });\n      };\n\n      VRMFirstPerson.prototype._excludeTriangles = function (triangles, bws, skinIndex, exclude) {\n        var count = 0;\n\n        if (bws != null && bws.length > 0) {\n          for (var i = 0; i < triangles.length; i += 3) {\n            var a = triangles[i];\n            var b = triangles[i + 1];\n            var c = triangles[i + 2];\n            var bw0 = bws[a];\n            var skin0 = skinIndex[a];\n            if (bw0[0] > 0 && exclude.includes(skin0[0])) continue;\n            if (bw0[1] > 0 && exclude.includes(skin0[1])) continue;\n            if (bw0[2] > 0 && exclude.includes(skin0[2])) continue;\n            if (bw0[3] > 0 && exclude.includes(skin0[3])) continue;\n            var bw1 = bws[b];\n            var skin1 = skinIndex[b];\n            if (bw1[0] > 0 && exclude.includes(skin1[0])) continue;\n            if (bw1[1] > 0 && exclude.includes(skin1[1])) continue;\n            if (bw1[2] > 0 && exclude.includes(skin1[2])) continue;\n            if (bw1[3] > 0 && exclude.includes(skin1[3])) continue;\n            var bw2 = bws[c];\n            var skin2 = skinIndex[c];\n            if (bw2[0] > 0 && exclude.includes(skin2[0])) continue;\n            if (bw2[1] > 0 && exclude.includes(skin2[1])) continue;\n            if (bw2[2] > 0 && exclude.includes(skin2[2])) continue;\n            if (bw2[3] > 0 && exclude.includes(skin2[3])) continue;\n            triangles[count++] = a;\n            triangles[count++] = b;\n            triangles[count++] = c;\n          }\n        }\n\n        return count;\n      };\n\n      VRMFirstPerson.prototype._createErasedMesh = function (src, erasingBonesIndex) {\n        var dst = new THREE.SkinnedMesh(src.geometry.clone(), src.material);\n        dst.name = src.name + \"(erase)\";\n        dst.frustumCulled = src.frustumCulled;\n        dst.layers.set(this._firstPersonOnlyLayer);\n        var geometry = dst.geometry;\n        var skinIndexAttr = geometry.getAttribute('skinIndex').array;\n        var skinIndex = [];\n\n        for (var i = 0; i < skinIndexAttr.length; i += 4) {\n          skinIndex.push([skinIndexAttr[i], skinIndexAttr[i + 1], skinIndexAttr[i + 2], skinIndexAttr[i + 3]]);\n        }\n\n        var skinWeightAttr = geometry.getAttribute('skinWeight').array;\n        var skinWeight = [];\n\n        for (var i = 0; i < skinWeightAttr.length; i += 4) {\n          skinWeight.push([skinWeightAttr[i], skinWeightAttr[i + 1], skinWeightAttr[i + 2], skinWeightAttr[i + 3]]);\n        }\n\n        var oldTriangles = Array.from(geometry.getIndex().array);\n\n        var count = this._excludeTriangles(oldTriangles, skinWeight, skinIndex, erasingBonesIndex);\n\n        var newTriangle = [];\n\n        for (var i = 0; i < count; i++) {\n          newTriangle[i] = oldTriangles[i];\n        }\n\n        geometry.setIndex(newTriangle);\n\n        if (src.onBeforeRender) {\n          dst.onBeforeRender = src.onBeforeRender;\n        }\n\n        dst.bind(new THREE.Skeleton(src.skeleton.bones, src.skeleton.boneInverses), new THREE.Matrix4());\n        return dst;\n      };\n\n      VRMFirstPerson.prototype._createHeadlessModelForSkinnedMesh = function (parent, mesh) {\n        var _this = this;\n\n        var eraseBoneIndexes = [];\n        mesh.skeleton.bones.forEach(function (bone, index) {\n          if (_this._isEraseTarget(bone)) eraseBoneIndexes.push(index);\n        });\n\n        if (!eraseBoneIndexes.length) {\n          mesh.layers.enable(this._thirdPersonOnlyLayer);\n          mesh.layers.enable(this._firstPersonOnlyLayer);\n          return;\n        }\n\n        mesh.layers.set(this._thirdPersonOnlyLayer);\n\n        var newMesh = this._createErasedMesh(mesh, eraseBoneIndexes);\n\n        parent.add(newMesh);\n      };\n\n      VRMFirstPerson.prototype._createHeadlessModel = function (node) {\n        var _this = this;\n\n        if (node.type === 'Group') {\n          node.layers.set(this._thirdPersonOnlyLayer);\n\n          if (this._isEraseTarget(node)) {\n            node.traverse(function (child) {\n              return child.layers.set(_this._thirdPersonOnlyLayer);\n            });\n          } else {\n            var parent_1 = new THREE.Group();\n            parent_1.name = \"_headless_\" + node.name;\n            parent_1.layers.set(this._firstPersonOnlyLayer);\n            node.parent.add(parent_1);\n            node.children.filter(function (child) {\n              return child.type === 'SkinnedMesh';\n            }).forEach(function (child) {\n              _this._createHeadlessModelForSkinnedMesh(parent_1, child);\n            });\n          }\n        } else if (node.type === 'SkinnedMesh') {\n          this._createHeadlessModelForSkinnedMesh(node.parent, node);\n        } else {\n          if (this._isEraseTarget(node)) {\n            node.layers.set(this._thirdPersonOnlyLayer);\n            node.traverse(function (child) {\n              return child.layers.set(_this._thirdPersonOnlyLayer);\n            });\n          }\n        }\n      };\n\n      VRMFirstPerson.prototype._isEraseTarget = function (bone) {\n        if (bone.name === this._firstPersonBone.name) {\n          return true;\n        } else if (!bone.parent) {\n          return false;\n        } else {\n          return this._isEraseTarget(bone.parent);\n        }\n      };\n\n      VRMFirstPerson._DEFAULT_FIRSTPERSON_ONLY_LAYER = 9;\n      VRMFirstPerson._DEFAULT_THIRDPERSON_ONLY_LAYER = 10;\n      return VRMFirstPerson;\n    }();\n\n    exports.VRMFirstPerson = VRMFirstPerson;\n    /***/\n  },\n\n  /***/\n  \"./src/vrm/firstperson/VRMFirstPersonImporter.ts\":\n  /*!*******************************************************!*\\\r\n    !*** ./src/vrm/firstperson/VRMFirstPersonImporter.ts ***!\r\n    \\*******************************************************/\n\n  /*! no static exports found */\n\n  /***/\n  function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n      return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) {\n          try {\n            step(generator.next(value));\n          } catch (e) {\n            reject(e);\n          }\n        }\n\n        function rejected(value) {\n          try {\n            step(generator[\"throw\"](value));\n          } catch (e) {\n            reject(e);\n          }\n        }\n\n        function step(result) {\n          result.done ? resolve(result.value) : new P(function (resolve) {\n            resolve(result.value);\n          }).then(fulfilled, rejected);\n        }\n\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n      });\n    };\n\n    var __generator = this && this.__generator || function (thisArg, body) {\n      var _ = {\n        label: 0,\n        sent: function () {\n          if (t[0] & 1) throw t[1];\n          return t[1];\n        },\n        trys: [],\n        ops: []\n      },\n          f,\n          y,\n          t,\n          g;\n      return g = {\n        next: verb(0),\n        \"throw\": verb(1),\n        \"return\": verb(2)\n      }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n        return this;\n      }), g;\n\n      function verb(n) {\n        return function (v) {\n          return step([n, v]);\n        };\n      }\n\n      function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n\n        while (_) try {\n          if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n          if (y = 0, t) op = [op[0] & 2, t.value];\n\n          switch (op[0]) {\n            case 0:\n            case 1:\n              t = op;\n              break;\n\n            case 4:\n              _.label++;\n              return {\n                value: op[1],\n                done: false\n              };\n\n            case 5:\n              _.label++;\n              y = op[1];\n              op = [0];\n              continue;\n\n            case 7:\n              op = _.ops.pop();\n\n              _.trys.pop();\n\n              continue;\n\n            default:\n              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n                _ = 0;\n                continue;\n              }\n\n              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n                _.label = op[1];\n                break;\n              }\n\n              if (op[0] === 6 && _.label < t[1]) {\n                _.label = t[1];\n                t = op;\n                break;\n              }\n\n              if (t && _.label < t[2]) {\n                _.label = t[2];\n\n                _.ops.push(op);\n\n                break;\n              }\n\n              if (t[2]) _.ops.pop();\n\n              _.trys.pop();\n\n              continue;\n          }\n\n          op = body.call(thisArg, _);\n        } catch (e) {\n          op = [6, e];\n          y = 0;\n        } finally {\n          f = t = 0;\n        }\n\n        if (op[0] & 5) throw op[1];\n        return {\n          value: op[0] ? op[1] : void 0,\n          done: true\n        };\n      }\n    };\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n\n    var THREE = __webpack_require__(\n    /*! three */\n    \"three\");\n\n    var types_1 = __webpack_require__(\n    /*! ../types */\n    \"./src/vrm/types/index.ts\");\n\n    var VRMFirstPerson_1 = __webpack_require__(\n    /*! ./VRMFirstPerson */\n    \"./src/vrm/firstperson/VRMFirstPerson.ts\");\n\n    var VRMFirstPersonImporter = function () {\n      function VRMFirstPersonImporter() {}\n\n      VRMFirstPersonImporter.prototype.import = function (gltf, humanoid) {\n        return __awaiter(this, void 0, Promise, function () {\n          var vrmExt, schemaFirstPerson, firstPersonBoneIndex, firstPersonBone, firstPersonBoneOffset, meshAnnotations, meshes;\n          return __generator(this, function (_a) {\n            switch (_a.label) {\n              case 0:\n                vrmExt = gltf.parser.json.extensions && gltf.parser.json.extensions.VRM;\n\n                if (!vrmExt) {\n                  return [2, null];\n                }\n\n                schemaFirstPerson = vrmExt.firstPerson;\n\n                if (!schemaFirstPerson) {\n                  return [2, null];\n                }\n\n                firstPersonBoneIndex = schemaFirstPerson.firstPersonBone;\n                if (!(firstPersonBoneIndex === undefined || firstPersonBoneIndex === -1)) return [3, 1];\n                firstPersonBone = humanoid.getBoneNode(types_1.VRMSchema.HumanoidBoneName.Head);\n                return [3, 3];\n\n              case 1:\n                return [4, gltf.parser.getDependency('node', firstPersonBoneIndex)];\n\n              case 2:\n                firstPersonBone = _a.sent();\n                _a.label = 3;\n\n              case 3:\n                if (!firstPersonBone) {\n                  console.warn('VRMFirstPersonImporter: Could not find firstPersonBone of the VRM');\n                  return [2, null];\n                }\n\n                firstPersonBoneOffset = schemaFirstPerson.firstPersonBoneOffset ? new THREE.Vector3(schemaFirstPerson.firstPersonBoneOffset.x, schemaFirstPerson.firstPersonBoneOffset.y, schemaFirstPerson.firstPersonBoneOffset.z) : new THREE.Vector3(0.0, 0.06, 0.0);\n                meshAnnotations = [];\n                return [4, gltf.parser.getDependencies('mesh')];\n\n              case 4:\n                meshes = _a.sent();\n                meshes.forEach(function (mesh, meshIndex) {\n                  var flag = schemaFirstPerson.meshAnnotations ? schemaFirstPerson.meshAnnotations.find(function (a) {\n                    return a.mesh === meshIndex;\n                  }) : undefined;\n                  meshAnnotations.push(new VRMFirstPerson_1.VRMRendererFirstPersonFlags(flag && flag.firstPersonFlag, mesh));\n                });\n                return [2, new VRMFirstPerson_1.VRMFirstPerson(firstPersonBone, firstPersonBoneOffset, meshAnnotations)];\n            }\n          });\n        });\n      };\n\n      return VRMFirstPersonImporter;\n    }();\n\n    exports.VRMFirstPersonImporter = VRMFirstPersonImporter;\n    /***/\n  },\n\n  /***/\n  \"./src/vrm/firstperson/index.ts\":\n  /*!**************************************!*\\\r\n    !*** ./src/vrm/firstperson/index.ts ***!\r\n    \\**************************************/\n\n  /*! no static exports found */\n\n  /***/\n  function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    function __export(m) {\n      for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n    }\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n\n    __export(__webpack_require__(\n    /*! ./VRMFirstPerson */\n    \"./src/vrm/firstperson/VRMFirstPerson.ts\"));\n\n    __export(__webpack_require__(\n    /*! ./VRMFirstPersonImporter */\n    \"./src/vrm/firstperson/VRMFirstPersonImporter.ts\"));\n    /***/\n\n  },\n\n  /***/\n  \"./src/vrm/humanoid/VRMHumanBone.ts\":\n  /*!******************************************!*\\\r\n    !*** ./src/vrm/humanoid/VRMHumanBone.ts ***!\r\n    \\******************************************/\n\n  /*! no static exports found */\n\n  /***/\n  function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n\n    var VRMHumanBone = function () {\n      function VRMHumanBone(node, humanLimit) {\n        this.node = node;\n        this.humanLimit = humanLimit;\n      }\n\n      return VRMHumanBone;\n    }();\n\n    exports.VRMHumanBone = VRMHumanBone;\n    /***/\n  },\n\n  /***/\n  \"./src/vrm/humanoid/VRMHumanBones.ts\":\n  /*!*******************************************!*\\\r\n    !*** ./src/vrm/humanoid/VRMHumanBones.ts ***!\r\n    \\*******************************************/\n\n  /*! no static exports found */\n\n  /***/\n  function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n    /***/\n  },\n\n  /***/\n  \"./src/vrm/humanoid/VRMHumanDescription.ts\":\n  /*!*************************************************!*\\\r\n    !*** ./src/vrm/humanoid/VRMHumanDescription.ts ***!\r\n    \\*************************************************/\n\n  /*! no static exports found */\n\n  /***/\n  function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n    /***/\n  },\n\n  /***/\n  \"./src/vrm/humanoid/VRMHumanLimit.ts\":\n  /*!*******************************************!*\\\r\n    !*** ./src/vrm/humanoid/VRMHumanLimit.ts ***!\r\n    \\*******************************************/\n\n  /*! no static exports found */\n\n  /***/\n  function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n    /***/\n  },\n\n  /***/\n  \"./src/vrm/humanoid/VRMHumanoid.ts\":\n  /*!*****************************************!*\\\r\n    !*** ./src/vrm/humanoid/VRMHumanoid.ts ***!\r\n    \\*****************************************/\n\n  /*! no static exports found */\n\n  /***/\n  function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n\n    var types_1 = __webpack_require__(\n    /*! ../types */\n    \"./src/vrm/types/index.ts\");\n\n    var VRMHumanoid = function () {\n      function VRMHumanoid(boneArray, humanDescription) {\n        this.humanBones = this._createHumanBones(boneArray);\n        this.humanDescription = humanDescription;\n        this.restPose = this.getPose();\n      }\n\n      VRMHumanoid.prototype.getPose = function () {\n        var _this = this;\n\n        var pose = {};\n        Object.keys(this.humanBones).forEach(function (vrmBoneName) {\n          var node = _this.getBoneNode(vrmBoneName);\n\n          if (!node) {\n            return;\n          }\n\n          if (pose[vrmBoneName]) {\n            return;\n          }\n\n          pose[vrmBoneName] = {\n            position: node.position.toArray(),\n            rotation: node.quaternion.toArray()\n          };\n        }, {});\n        return pose;\n      };\n\n      VRMHumanoid.prototype.setPose = function (poseObject) {\n        var _this = this;\n\n        Object.keys(poseObject).forEach(function (boneName) {\n          var state = poseObject[boneName];\n\n          var node = _this.getBoneNode(boneName);\n\n          if (!node) {\n            return;\n          }\n\n          var restState = _this.restPose[boneName];\n\n          if (!restState) {\n            return;\n          }\n\n          if (state.position) {\n            node.position.set(restState.position[0] + state.position[0], restState.position[1] + state.position[1], restState.position[2] + state.position[2]);\n          }\n\n          if (state.rotation) {\n            node.quaternion.fromArray(state.rotation);\n          }\n        });\n      };\n\n      VRMHumanoid.prototype.getBone = function (name) {\n        return this.humanBones[name][0] || undefined;\n      };\n\n      VRMHumanoid.prototype.getBones = function (name) {\n        return this.humanBones[name];\n      };\n\n      VRMHumanoid.prototype.getBoneNode = function (name) {\n        return this.humanBones[name][0] && this.humanBones[name][0].node || null;\n      };\n\n      VRMHumanoid.prototype.getBoneNodes = function (name) {\n        return this.humanBones[name].map(function (bone) {\n          return bone.node;\n        });\n      };\n\n      VRMHumanoid.prototype._createHumanBones = function (boneArray) {\n        var bones = Object.values(types_1.VRMSchema.HumanoidBoneName).reduce(function (accum, name) {\n          accum[name] = [];\n          return accum;\n        }, {});\n        boneArray.forEach(function (bone) {\n          bones[bone.name].push(bone.bone);\n        });\n        return bones;\n      };\n\n      return VRMHumanoid;\n    }();\n\n    exports.VRMHumanoid = VRMHumanoid;\n    /***/\n  },\n\n  /***/\n  \"./src/vrm/humanoid/VRMHumanoidImporter.ts\":\n  /*!*************************************************!*\\\r\n    !*** ./src/vrm/humanoid/VRMHumanoidImporter.ts ***!\r\n    \\*************************************************/\n\n  /*! no static exports found */\n\n  /***/\n  function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n      return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) {\n          try {\n            step(generator.next(value));\n          } catch (e) {\n            reject(e);\n          }\n        }\n\n        function rejected(value) {\n          try {\n            step(generator[\"throw\"](value));\n          } catch (e) {\n            reject(e);\n          }\n        }\n\n        function step(result) {\n          result.done ? resolve(result.value) : new P(function (resolve) {\n            resolve(result.value);\n          }).then(fulfilled, rejected);\n        }\n\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n      });\n    };\n\n    var __generator = this && this.__generator || function (thisArg, body) {\n      var _ = {\n        label: 0,\n        sent: function () {\n          if (t[0] & 1) throw t[1];\n          return t[1];\n        },\n        trys: [],\n        ops: []\n      },\n          f,\n          y,\n          t,\n          g;\n      return g = {\n        next: verb(0),\n        \"throw\": verb(1),\n        \"return\": verb(2)\n      }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n        return this;\n      }), g;\n\n      function verb(n) {\n        return function (v) {\n          return step([n, v]);\n        };\n      }\n\n      function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n\n        while (_) try {\n          if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n          if (y = 0, t) op = [op[0] & 2, t.value];\n\n          switch (op[0]) {\n            case 0:\n            case 1:\n              t = op;\n              break;\n\n            case 4:\n              _.label++;\n              return {\n                value: op[1],\n                done: false\n              };\n\n            case 5:\n              _.label++;\n              y = op[1];\n              op = [0];\n              continue;\n\n            case 7:\n              op = _.ops.pop();\n\n              _.trys.pop();\n\n              continue;\n\n            default:\n              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n                _ = 0;\n                continue;\n              }\n\n              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n                _.label = op[1];\n                break;\n              }\n\n              if (op[0] === 6 && _.label < t[1]) {\n                _.label = t[1];\n                t = op;\n                break;\n              }\n\n              if (t && _.label < t[2]) {\n                _.label = t[2];\n\n                _.ops.push(op);\n\n                break;\n              }\n\n              if (t[2]) _.ops.pop();\n\n              _.trys.pop();\n\n              continue;\n          }\n\n          op = body.call(thisArg, _);\n        } catch (e) {\n          op = [6, e];\n          y = 0;\n        } finally {\n          f = t = 0;\n        }\n\n        if (op[0] & 5) throw op[1];\n        return {\n          value: op[0] ? op[1] : void 0,\n          done: true\n        };\n      }\n    };\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n\n    var THREE = __webpack_require__(\n    /*! three */\n    \"three\");\n\n    var VRMHumanBone_1 = __webpack_require__(\n    /*! ./VRMHumanBone */\n    \"./src/vrm/humanoid/VRMHumanBone.ts\");\n\n    var VRMHumanoid_1 = __webpack_require__(\n    /*! ./VRMHumanoid */\n    \"./src/vrm/humanoid/VRMHumanoid.ts\");\n\n    var VRMHumanoidImporter = function () {\n      function VRMHumanoidImporter() {}\n\n      VRMHumanoidImporter.prototype.import = function (gltf) {\n        return __awaiter(this, void 0, Promise, function () {\n          var vrmExt, schemaHumanoid, humanBoneArray, humanDescription;\n\n          var _this = this;\n\n          return __generator(this, function (_a) {\n            switch (_a.label) {\n              case 0:\n                vrmExt = gltf.parser.json.extensions && gltf.parser.json.extensions.VRM;\n\n                if (!vrmExt) {\n                  return [2, null];\n                }\n\n                schemaHumanoid = vrmExt.humanoid;\n\n                if (!schemaHumanoid) {\n                  return [2, null];\n                }\n\n                humanBoneArray = [];\n                if (!schemaHumanoid.humanBones) return [3, 2];\n                return [4, Promise.all(schemaHumanoid.humanBones.map(function (bone) {\n                  return __awaiter(_this, void 0, void 0, function () {\n                    var node;\n                    return __generator(this, function (_a) {\n                      switch (_a.label) {\n                        case 0:\n                          if (!bone.bone || !bone.node) {\n                            return [2];\n                          }\n\n                          return [4, gltf.parser.getDependency('node', bone.node)];\n\n                        case 1:\n                          node = _a.sent();\n                          humanBoneArray.push({\n                            name: bone.bone,\n                            bone: new VRMHumanBone_1.VRMHumanBone(node, {\n                              axisLength: bone.axisLength,\n                              center: bone.center && new THREE.Vector3(bone.center.x, bone.center.y, bone.center.z),\n                              max: bone.max && new THREE.Vector3(bone.max.x, bone.max.y, bone.max.z),\n                              min: bone.min && new THREE.Vector3(bone.min.x, bone.min.y, bone.min.z),\n                              useDefaultValues: bone.useDefaultValues\n                            })\n                          });\n                          return [2];\n                      }\n                    });\n                  });\n                }))];\n\n              case 1:\n                _a.sent();\n\n                _a.label = 2;\n\n              case 2:\n                humanDescription = {\n                  armStretch: schemaHumanoid.armStretch,\n                  legStretch: schemaHumanoid.legStretch,\n                  upperArmTwist: schemaHumanoid.upperArmTwist,\n                  lowerArmTwist: schemaHumanoid.lowerArmTwist,\n                  upperLegTwist: schemaHumanoid.upperLegTwist,\n                  lowerLegTwist: schemaHumanoid.lowerLegTwist,\n                  feetSpacing: schemaHumanoid.feetSpacing,\n                  hasTranslationDoF: schemaHumanoid.hasTranslationDoF\n                };\n                return [2, new VRMHumanoid_1.VRMHumanoid(humanBoneArray, humanDescription)];\n            }\n          });\n        });\n      };\n\n      return VRMHumanoidImporter;\n    }();\n\n    exports.VRMHumanoidImporter = VRMHumanoidImporter;\n    /***/\n  },\n\n  /***/\n  \"./src/vrm/humanoid/index.ts\":\n  /*!***********************************!*\\\r\n    !*** ./src/vrm/humanoid/index.ts ***!\r\n    \\***********************************/\n\n  /*! no static exports found */\n\n  /***/\n  function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    function __export(m) {\n      for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n    }\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n\n    __export(__webpack_require__(\n    /*! ./VRMHumanBone */\n    \"./src/vrm/humanoid/VRMHumanBone.ts\"));\n\n    __export(__webpack_require__(\n    /*! ./VRMHumanBones */\n    \"./src/vrm/humanoid/VRMHumanBones.ts\"));\n\n    __export(__webpack_require__(\n    /*! ./VRMHumanDescription */\n    \"./src/vrm/humanoid/VRMHumanDescription.ts\"));\n\n    __export(__webpack_require__(\n    /*! ./VRMHumanLimit */\n    \"./src/vrm/humanoid/VRMHumanLimit.ts\"));\n\n    __export(__webpack_require__(\n    /*! ./VRMHumanoid */\n    \"./src/vrm/humanoid/VRMHumanoid.ts\"));\n\n    __export(__webpack_require__(\n    /*! ./VRMHumanoidImporter */\n    \"./src/vrm/humanoid/VRMHumanoidImporter.ts\"));\n    /***/\n\n  },\n\n  /***/\n  \"./src/vrm/index.ts\":\n  /*!**************************!*\\\r\n    !*** ./src/vrm/index.ts ***!\r\n    \\**************************/\n\n  /*! no static exports found */\n\n  /***/\n  function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    function __export(m) {\n      for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n    }\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n\n    __export(__webpack_require__(\n    /*! ./VRM */\n    \"./src/vrm/VRM.ts\"));\n\n    __export(__webpack_require__(\n    /*! ./VRMImporter */\n    \"./src/vrm/VRMImporter.ts\"));\n\n    __export(__webpack_require__(\n    /*! ./reduceBones */\n    \"./src/vrm/reduceBones.ts\"));\n\n    __export(__webpack_require__(\n    /*! ./blendshape */\n    \"./src/vrm/blendshape/index.ts\"));\n\n    __export(__webpack_require__(\n    /*! ./debug */\n    \"./src/vrm/debug/index.ts\"));\n\n    __export(__webpack_require__(\n    /*! ./firstperson */\n    \"./src/vrm/firstperson/index.ts\"));\n\n    __export(__webpack_require__(\n    /*! ./humanoid */\n    \"./src/vrm/humanoid/index.ts\"));\n\n    __export(__webpack_require__(\n    /*! ./lookat */\n    \"./src/vrm/lookat/index.ts\"));\n\n    __export(__webpack_require__(\n    /*! ./springbone */\n    \"./src/vrm/springbone/index.ts\"));\n\n    __export(__webpack_require__(\n    /*! ./types */\n    \"./src/vrm/types/index.ts\"));\n\n    __export(__webpack_require__(\n    /*! ./material */\n    \"./src/vrm/material/index.ts\"));\n    /***/\n\n  },\n\n  /***/\n  \"./src/vrm/lookat/CurveMapper.ts\":\n  /*!***************************************!*\\\r\n    !*** ./src/vrm/lookat/CurveMapper.ts ***!\r\n    \\***************************************/\n\n  /*! no static exports found */\n\n  /***/\n  function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n\n    var hermiteSpline = function (y0, y1, t0, t1, x) {\n      var xc = x * x * x;\n      var xs = x * x;\n      var dy = y1 - y0;\n      var h01 = -2.0 * xc + 3.0 * xs;\n      var h10 = xc - 2.0 * xs + x;\n      var h11 = xc - xs;\n      return y0 + dy * h01 + t0 * h10 + t1 * h11;\n    };\n\n    var evaluateCurve = function (arr, x) {\n      if (arr.length < 8) {\n        throw new Error('evaluateCurve: Invalid curve detected! (Array length must be 8 at least)');\n      }\n\n      if (arr.length % 4 !== 0) {\n        throw new Error('evaluateCurve: Invalid curve detected! (Array length must be multiples of 4');\n      }\n\n      var outNode;\n\n      for (outNode = 0;; outNode++) {\n        if (arr.length <= 4 * outNode) {\n          return arr[4 * outNode - 3];\n        } else if (x <= arr[4 * outNode]) {\n          break;\n        }\n      }\n\n      var inNode = outNode - 1;\n\n      if (inNode < 0) {\n        return arr[4 * inNode + 5];\n      }\n\n      var x0 = arr[4 * inNode];\n      var x1 = arr[4 * outNode];\n      var xHermite = (x - x0) / (x1 - x0);\n      var y0 = arr[4 * inNode + 1];\n      var y1 = arr[4 * outNode + 1];\n      var t0 = arr[4 * inNode + 3];\n      var t1 = arr[4 * outNode + 2];\n      return hermiteSpline(y0, y1, t0, t1, xHermite);\n    };\n\n    var CurveMapper = function () {\n      function CurveMapper(xRange, yRange, curve) {\n        this.curve = [0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 1.0, 0.0];\n        this.curveXRangeDegree = 90.0;\n        this.curveYRangeDegree = 10.0;\n\n        if (xRange !== undefined) {\n          this.curveXRangeDegree = xRange;\n        }\n\n        if (yRange !== undefined) {\n          this.curveYRangeDegree = yRange;\n        }\n\n        if (curve !== undefined) {\n          this.curve = curve;\n        }\n      }\n\n      CurveMapper.prototype.map = function (src) {\n        var clampedSrc = Math.min(Math.max(src, 0.0), this.curveXRangeDegree);\n        var x = clampedSrc / this.curveXRangeDegree;\n        return this.curveYRangeDegree * evaluateCurve(this.curve, x);\n      };\n\n      return CurveMapper;\n    }();\n\n    exports.CurveMapper = CurveMapper;\n    /***/\n  },\n\n  /***/\n  \"./src/vrm/lookat/VRMLookAtApplyer.ts\":\n  /*!********************************************!*\\\r\n    !*** ./src/vrm/lookat/VRMLookAtApplyer.ts ***!\r\n    \\********************************************/\n\n  /*! no static exports found */\n\n  /***/\n  function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n\n    var VRMLookAtApplyer = function () {\n      function VRMLookAtApplyer() {}\n\n      return VRMLookAtApplyer;\n    }();\n\n    exports.VRMLookAtApplyer = VRMLookAtApplyer;\n    /***/\n  },\n\n  /***/\n  \"./src/vrm/lookat/VRMLookAtBlendShapeApplyer.ts\":\n  /*!******************************************************!*\\\r\n    !*** ./src/vrm/lookat/VRMLookAtBlendShapeApplyer.ts ***!\r\n    \\******************************************************/\n\n  /*! no static exports found */\n\n  /***/\n  function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    var __extends = this && this.__extends || function () {\n      var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (d, b) {\n          d.__proto__ = b;\n        } || function (d, b) {\n          for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n        };\n\n        return extendStatics(d, b);\n      };\n\n      return function (d, b) {\n        extendStatics(d, b);\n\n        function __() {\n          this.constructor = d;\n        }\n\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n      };\n    }();\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n\n    var types_1 = __webpack_require__(\n    /*! ../types */\n    \"./src/vrm/types/index.ts\");\n\n    var VRMLookAtApplyer_1 = __webpack_require__(\n    /*! ./VRMLookAtApplyer */\n    \"./src/vrm/lookat/VRMLookAtApplyer.ts\");\n\n    var VRMLookAtBlendShapeApplyer = function (_super) {\n      __extends(VRMLookAtBlendShapeApplyer, _super);\n\n      function VRMLookAtBlendShapeApplyer(blendShapeProxy, curveHorizontal, curveVerticalDown, curveVerticalUp) {\n        var _this = _super.call(this) || this;\n\n        _this.type = types_1.VRMSchema.FirstPersonLookAtTypeName.BlendShape;\n        _this._curveHorizontal = curveHorizontal;\n        _this._curveVerticalDown = curveVerticalDown;\n        _this._curveVerticalUp = curveVerticalUp;\n        _this._blendShapeProxy = blendShapeProxy;\n        return _this;\n      }\n\n      VRMLookAtBlendShapeApplyer.prototype.name = function () {\n        return types_1.VRMSchema.FirstPersonLookAtTypeName.BlendShape;\n      };\n\n      VRMLookAtBlendShapeApplyer.prototype.lookAt = function (euler) {\n        var srcX = euler.x;\n        var srcY = euler.y;\n\n        if (srcX < 0.0) {\n          this._blendShapeProxy.setValue(types_1.VRMSchema.BlendShapePresetName.Lookup, 0.0);\n\n          this._blendShapeProxy.setValue(types_1.VRMSchema.BlendShapePresetName.Lookdown, this._curveVerticalDown.map(-srcX));\n        } else {\n          this._blendShapeProxy.setValue(types_1.VRMSchema.BlendShapePresetName.Lookdown, 0.0);\n\n          this._blendShapeProxy.setValue(types_1.VRMSchema.BlendShapePresetName.Lookup, this._curveVerticalUp.map(srcX));\n        }\n\n        if (srcY < 0.0) {\n          this._blendShapeProxy.setValue(types_1.VRMSchema.BlendShapePresetName.Lookleft, 0.0);\n\n          this._blendShapeProxy.setValue(types_1.VRMSchema.BlendShapePresetName.Lookright, this._curveHorizontal.map(-srcY));\n        } else {\n          this._blendShapeProxy.setValue(types_1.VRMSchema.BlendShapePresetName.Lookright, 0.0);\n\n          this._blendShapeProxy.setValue(types_1.VRMSchema.BlendShapePresetName.Lookleft, this._curveHorizontal.map(srcY));\n        }\n      };\n\n      return VRMLookAtBlendShapeApplyer;\n    }(VRMLookAtApplyer_1.VRMLookAtApplyer);\n\n    exports.VRMLookAtBlendShapeApplyer = VRMLookAtBlendShapeApplyer;\n    /***/\n  },\n\n  /***/\n  \"./src/vrm/lookat/VRMLookAtBoneApplyer.ts\":\n  /*!************************************************!*\\\r\n    !*** ./src/vrm/lookat/VRMLookAtBoneApplyer.ts ***!\r\n    \\************************************************/\n\n  /*! no static exports found */\n\n  /***/\n  function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    var __extends = this && this.__extends || function () {\n      var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (d, b) {\n          d.__proto__ = b;\n        } || function (d, b) {\n          for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n        };\n\n        return extendStatics(d, b);\n      };\n\n      return function (d, b) {\n        extendStatics(d, b);\n\n        function __() {\n          this.constructor = d;\n        }\n\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n      };\n    }();\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n\n    var THREE = __webpack_require__(\n    /*! three */\n    \"three\");\n\n    var types_1 = __webpack_require__(\n    /*! ../types */\n    \"./src/vrm/types/index.ts\");\n\n    var VRMLookAtApplyer_1 = __webpack_require__(\n    /*! ./VRMLookAtApplyer */\n    \"./src/vrm/lookat/VRMLookAtApplyer.ts\");\n\n    var VRMLookAtHead_1 = __webpack_require__(\n    /*! ./VRMLookAtHead */\n    \"./src/vrm/lookat/VRMLookAtHead.ts\");\n\n    var _euler = new THREE.Euler(0.0, 0.0, 0.0, VRMLookAtHead_1.VRMLookAtHead.EULER_ORDER);\n\n    var VRMLookAtBoneApplyer = function (_super) {\n      __extends(VRMLookAtBoneApplyer, _super);\n\n      function VRMLookAtBoneApplyer(humanoid, curveHorizontalInner, curveHorizontalOuter, curveVerticalDown, curveVerticalUp) {\n        var _this = _super.call(this) || this;\n\n        _this.type = types_1.VRMSchema.FirstPersonLookAtTypeName.Bone;\n        _this._curveHorizontalInner = curveHorizontalInner;\n        _this._curveHorizontalOuter = curveHorizontalOuter;\n        _this._curveVerticalDown = curveVerticalDown;\n        _this._curveVerticalUp = curveVerticalUp;\n        _this._leftEye = humanoid.getBoneNode(types_1.VRMSchema.HumanoidBoneName.LeftEye);\n        _this._rightEye = humanoid.getBoneNode(types_1.VRMSchema.HumanoidBoneName.RightEye);\n        return _this;\n      }\n\n      VRMLookAtBoneApplyer.prototype.lookAt = function (euler) {\n        var srcX = euler.x;\n        var srcY = euler.y;\n\n        if (this._leftEye) {\n          if (srcX < 0.0) {\n            _euler.x = -this._curveVerticalDown.map(-srcX);\n          } else {\n            _euler.x = this._curveVerticalUp.map(srcX);\n          }\n\n          if (srcY < 0.0) {\n            _euler.y = -this._curveHorizontalInner.map(-srcY);\n          } else {\n            _euler.y = this._curveHorizontalOuter.map(srcY);\n          }\n\n          this._leftEye.quaternion.setFromEuler(_euler);\n        }\n\n        if (this._rightEye) {\n          if (srcX < 0.0) {\n            _euler.x = -this._curveVerticalDown.map(-srcX);\n          } else {\n            _euler.x = this._curveVerticalUp.map(srcX);\n          }\n\n          if (srcY < 0.0) {\n            _euler.y = -this._curveHorizontalOuter.map(-srcY);\n          } else {\n            _euler.y = this._curveHorizontalInner.map(srcY);\n          }\n\n          this._rightEye.quaternion.setFromEuler(_euler);\n        }\n      };\n\n      return VRMLookAtBoneApplyer;\n    }(VRMLookAtApplyer_1.VRMLookAtApplyer);\n\n    exports.VRMLookAtBoneApplyer = VRMLookAtBoneApplyer;\n    /***/\n  },\n\n  /***/\n  \"./src/vrm/lookat/VRMLookAtHead.ts\":\n  /*!*****************************************!*\\\r\n    !*** ./src/vrm/lookat/VRMLookAtHead.ts ***!\r\n    \\*****************************************/\n\n  /*! no static exports found */\n\n  /***/\n  function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n\n    var THREE = __webpack_require__(\n    /*! three */\n    \"three\");\n\n    var math_1 = __webpack_require__(\n    /*! ../utils/math */\n    \"./src/vrm/utils/math.ts\");\n\n    var VECTOR3_FRONT = Object.freeze(new THREE.Vector3(0.0, 0.0, -1.0));\n\n    var _v3A = new THREE.Vector3();\n\n    var _v3B = new THREE.Vector3();\n\n    var _v3C = new THREE.Vector3();\n\n    var _quat = new THREE.Quaternion();\n\n    var VRMLookAtHead = function () {\n      function VRMLookAtHead(firstPerson, applyer) {\n        this.autoUpdate = true;\n        this._euler = new THREE.Euler(0.0, 0.0, 0.0, VRMLookAtHead.EULER_ORDER);\n        this.firstPerson = firstPerson;\n        this.applyer = applyer;\n      }\n\n      VRMLookAtHead.prototype.getLookAtWorldDirection = function (target) {\n        var rot = math_1.getWorldQuaternionLite(this.firstPerson.firstPersonBone, _quat);\n        return target.copy(VECTOR3_FRONT).applyEuler(this._euler).applyQuaternion(rot);\n      };\n\n      VRMLookAtHead.prototype.lookAt = function (position) {\n        this._calcEuler(this._euler, position);\n\n        if (this.applyer) {\n          this.applyer.lookAt(this._euler);\n        }\n      };\n\n      VRMLookAtHead.prototype.update = function (delta) {\n        if (this.target && this.autoUpdate) {\n          this.lookAt(this.target.getWorldPosition(_v3A));\n\n          if (this.applyer) {\n            this.applyer.lookAt(this._euler);\n          }\n        }\n      };\n\n      VRMLookAtHead.prototype._calcEuler = function (target, position) {\n        var headPosition = this.firstPerson.getFirstPersonWorldPosition(_v3B);\n\n        var lookAtDir = _v3C.copy(position).sub(headPosition).normalize();\n\n        lookAtDir.applyQuaternion(math_1.getWorldQuaternionLite(this.firstPerson.firstPersonBone, _quat).inverse());\n        target.x = Math.atan2(lookAtDir.y, Math.sqrt(lookAtDir.x * lookAtDir.x + lookAtDir.z * lookAtDir.z));\n        target.y = Math.atan2(-lookAtDir.x, -lookAtDir.z);\n        return target;\n      };\n\n      VRMLookAtHead.EULER_ORDER = 'YXZ';\n      return VRMLookAtHead;\n    }();\n\n    exports.VRMLookAtHead = VRMLookAtHead;\n    /***/\n  },\n\n  /***/\n  \"./src/vrm/lookat/VRMLookAtImporter.ts\":\n  /*!*********************************************!*\\\r\n    !*** ./src/vrm/lookat/VRMLookAtImporter.ts ***!\r\n    \\*********************************************/\n\n  /*! no static exports found */\n\n  /***/\n  function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n\n    var THREE = __webpack_require__(\n    /*! three */\n    \"three\");\n\n    var types_1 = __webpack_require__(\n    /*! ../types */\n    \"./src/vrm/types/index.ts\");\n\n    var CurveMapper_1 = __webpack_require__(\n    /*! ./CurveMapper */\n    \"./src/vrm/lookat/CurveMapper.ts\");\n\n    var VRMLookAtBlendShapeApplyer_1 = __webpack_require__(\n    /*! ./VRMLookAtBlendShapeApplyer */\n    \"./src/vrm/lookat/VRMLookAtBlendShapeApplyer.ts\");\n\n    var VRMLookAtBoneApplyer_1 = __webpack_require__(\n    /*! ./VRMLookAtBoneApplyer */\n    \"./src/vrm/lookat/VRMLookAtBoneApplyer.ts\");\n\n    var VRMLookAtHead_1 = __webpack_require__(\n    /*! ./VRMLookAtHead */\n    \"./src/vrm/lookat/VRMLookAtHead.ts\");\n\n    var VRMLookAtImporter = function () {\n      function VRMLookAtImporter() {}\n\n      VRMLookAtImporter.prototype.import = function (gltf, firstPerson, blendShapeProxy, humanoid) {\n        var vrmExt = gltf.parser.json.extensions && gltf.parser.json.extensions.VRM;\n\n        if (!vrmExt) {\n          return null;\n        }\n\n        var schemaFirstPerson = vrmExt.firstPerson;\n\n        if (!schemaFirstPerson) {\n          return null;\n        }\n\n        var applyer = this._importApplyer(schemaFirstPerson, blendShapeProxy, humanoid);\n\n        return new VRMLookAtHead_1.VRMLookAtHead(firstPerson, applyer || undefined);\n      };\n\n      VRMLookAtImporter.prototype._importApplyer = function (schemaFirstPerson, blendShapeProxy, humanoid) {\n        var lookAtHorizontalInner = schemaFirstPerson.lookAtHorizontalInner;\n        var lookAtHorizontalOuter = schemaFirstPerson.lookAtHorizontalOuter;\n        var lookAtVerticalDown = schemaFirstPerson.lookAtVerticalDown;\n        var lookAtVerticalUp = schemaFirstPerson.lookAtVerticalUp;\n\n        switch (schemaFirstPerson.lookAtTypeName) {\n          case types_1.VRMSchema.FirstPersonLookAtTypeName.Bone:\n            {\n              if (lookAtHorizontalInner === undefined || lookAtHorizontalOuter === undefined || lookAtVerticalDown === undefined || lookAtVerticalUp === undefined) {\n                return null;\n              } else {\n                return new VRMLookAtBoneApplyer_1.VRMLookAtBoneApplyer(humanoid, this._importCurveMapperBone(lookAtHorizontalInner), this._importCurveMapperBone(lookAtHorizontalOuter), this._importCurveMapperBone(lookAtVerticalDown), this._importCurveMapperBone(lookAtVerticalUp));\n              }\n            }\n\n          case types_1.VRMSchema.FirstPersonLookAtTypeName.BlendShape:\n            {\n              if (lookAtHorizontalOuter === undefined || lookAtVerticalDown === undefined || lookAtVerticalUp === undefined) {\n                return null;\n              } else {\n                return new VRMLookAtBlendShapeApplyer_1.VRMLookAtBlendShapeApplyer(blendShapeProxy, this._importCurveMapperBlendShape(lookAtHorizontalOuter), this._importCurveMapperBlendShape(lookAtVerticalDown), this._importCurveMapperBlendShape(lookAtVerticalUp));\n              }\n            }\n\n          default:\n            {\n              return null;\n            }\n        }\n      };\n\n      VRMLookAtImporter.prototype._importCurveMapperBone = function (map) {\n        return new CurveMapper_1.CurveMapper(typeof map.xRange === 'number' ? THREE.Math.DEG2RAD * map.xRange : undefined, typeof map.yRange === 'number' ? THREE.Math.DEG2RAD * map.yRange : undefined, map.curve);\n      };\n\n      VRMLookAtImporter.prototype._importCurveMapperBlendShape = function (map) {\n        return new CurveMapper_1.CurveMapper(typeof map.xRange === 'number' ? THREE.Math.DEG2RAD * map.xRange : undefined, map.yRange, map.curve);\n      };\n\n      return VRMLookAtImporter;\n    }();\n\n    exports.VRMLookAtImporter = VRMLookAtImporter;\n    /***/\n  },\n\n  /***/\n  \"./src/vrm/lookat/index.ts\":\n  /*!*********************************!*\\\r\n    !*** ./src/vrm/lookat/index.ts ***!\r\n    \\*********************************/\n\n  /*! no static exports found */\n\n  /***/\n  function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    function __export(m) {\n      for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n    }\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n\n    __export(__webpack_require__(\n    /*! ./CurveMapper */\n    \"./src/vrm/lookat/CurveMapper.ts\"));\n\n    __export(__webpack_require__(\n    /*! ./VRMLookAtApplyer */\n    \"./src/vrm/lookat/VRMLookAtApplyer.ts\"));\n\n    __export(__webpack_require__(\n    /*! ./VRMLookAtBlendShapeApplyer */\n    \"./src/vrm/lookat/VRMLookAtBlendShapeApplyer.ts\"));\n\n    __export(__webpack_require__(\n    /*! ./VRMLookAtBoneApplyer */\n    \"./src/vrm/lookat/VRMLookAtBoneApplyer.ts\"));\n\n    __export(__webpack_require__(\n    /*! ./VRMLookAtHead */\n    \"./src/vrm/lookat/VRMLookAtHead.ts\"));\n\n    __export(__webpack_require__(\n    /*! ./VRMLookAtImporter */\n    \"./src/vrm/lookat/VRMLookAtImporter.ts\"));\n    /***/\n\n  },\n\n  /***/\n  \"./src/vrm/material/MToonMaterial.ts\":\n  /*!*******************************************!*\\\r\n    !*** ./src/vrm/material/MToonMaterial.ts ***!\r\n    \\*******************************************/\n\n  /*! no static exports found */\n\n  /***/\n  function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    var __extends = this && this.__extends || function () {\n      var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (d, b) {\n          d.__proto__ = b;\n        } || function (d, b) {\n          for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n        };\n\n        return extendStatics(d, b);\n      };\n\n      return function (d, b) {\n        extendStatics(d, b);\n\n        function __() {\n          this.constructor = d;\n        }\n\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n      };\n    }();\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n\n    var THREE = __webpack_require__(\n    /*! three */\n    \"three\");\n\n    var getTexelDecodingFunction_1 = __webpack_require__(\n    /*! ./getTexelDecodingFunction */\n    \"./src/vrm/material/getTexelDecodingFunction.ts\");\n\n    var mtoon_vert_1 = __webpack_require__(\n    /*! ./shaders/mtoon.vert */\n    \"./src/vrm/material/shaders/mtoon.vert\");\n\n    var mtoon_frag_1 = __webpack_require__(\n    /*! ./shaders/mtoon.frag */\n    \"./src/vrm/material/shaders/mtoon.frag\");\n\n    var TAU = 2.0 * Math.PI;\n    var MToonMaterialCullMode;\n\n    (function (MToonMaterialCullMode) {\n      MToonMaterialCullMode[MToonMaterialCullMode[\"Off\"] = 0] = \"Off\";\n      MToonMaterialCullMode[MToonMaterialCullMode[\"Front\"] = 1] = \"Front\";\n      MToonMaterialCullMode[MToonMaterialCullMode[\"Back\"] = 2] = \"Back\";\n    })(MToonMaterialCullMode = exports.MToonMaterialCullMode || (exports.MToonMaterialCullMode = {}));\n\n    var MToonMaterialDebugMode;\n\n    (function (MToonMaterialDebugMode) {\n      MToonMaterialDebugMode[MToonMaterialDebugMode[\"None\"] = 0] = \"None\";\n      MToonMaterialDebugMode[MToonMaterialDebugMode[\"Normal\"] = 1] = \"Normal\";\n      MToonMaterialDebugMode[MToonMaterialDebugMode[\"LitShadeRate\"] = 2] = \"LitShadeRate\";\n      MToonMaterialDebugMode[MToonMaterialDebugMode[\"UV\"] = 3] = \"UV\";\n    })(MToonMaterialDebugMode = exports.MToonMaterialDebugMode || (exports.MToonMaterialDebugMode = {}));\n\n    var MToonMaterialOutlineColorMode;\n\n    (function (MToonMaterialOutlineColorMode) {\n      MToonMaterialOutlineColorMode[MToonMaterialOutlineColorMode[\"FixedColor\"] = 0] = \"FixedColor\";\n      MToonMaterialOutlineColorMode[MToonMaterialOutlineColorMode[\"MixedLighting\"] = 1] = \"MixedLighting\";\n    })(MToonMaterialOutlineColorMode = exports.MToonMaterialOutlineColorMode || (exports.MToonMaterialOutlineColorMode = {}));\n\n    var MToonMaterialOutlineWidthMode;\n\n    (function (MToonMaterialOutlineWidthMode) {\n      MToonMaterialOutlineWidthMode[MToonMaterialOutlineWidthMode[\"None\"] = 0] = \"None\";\n      MToonMaterialOutlineWidthMode[MToonMaterialOutlineWidthMode[\"WorldCoordinates\"] = 1] = \"WorldCoordinates\";\n      MToonMaterialOutlineWidthMode[MToonMaterialOutlineWidthMode[\"ScreenCoordinates\"] = 2] = \"ScreenCoordinates\";\n    })(MToonMaterialOutlineWidthMode = exports.MToonMaterialOutlineWidthMode || (exports.MToonMaterialOutlineWidthMode = {}));\n\n    var MToonMaterialRenderMode;\n\n    (function (MToonMaterialRenderMode) {\n      MToonMaterialRenderMode[MToonMaterialRenderMode[\"Opaque\"] = 0] = \"Opaque\";\n      MToonMaterialRenderMode[MToonMaterialRenderMode[\"Cutout\"] = 1] = \"Cutout\";\n      MToonMaterialRenderMode[MToonMaterialRenderMode[\"Transparent\"] = 2] = \"Transparent\";\n      MToonMaterialRenderMode[MToonMaterialRenderMode[\"TransparentWithZWrite\"] = 3] = \"TransparentWithZWrite\";\n    })(MToonMaterialRenderMode = exports.MToonMaterialRenderMode || (exports.MToonMaterialRenderMode = {}));\n\n    var MToonMaterial = function (_super) {\n      __extends(MToonMaterial, _super);\n\n      function MToonMaterial(colorSpaceGamma, parameters) {\n        var _this = _super.call(this) || this;\n\n        _this.isMToonMaterial = true;\n        _this.cutoff = 0.5;\n        _this.color = new THREE.Vector4(1.0, 1.0, 1.0, 1.0);\n        _this.shadeColor = new THREE.Vector4(0.97, 0.81, 0.86, 1.0);\n        _this.map = null;\n        _this.mainTex_ST = new THREE.Vector4(0.0, 0.0, 1.0, 1.0);\n        _this.shadeTexture = null;\n        _this.bumpScale = 1.0;\n        _this.normalMap = null;\n        _this.receiveShadowRate = 1.0;\n        _this.receiveShadowTexture = null;\n        _this.shadingGradeRate = 1.0;\n        _this.shadingGradeTexture = null;\n        _this.shadeShift = 0.0;\n        _this.shadeToony = 0.9;\n        _this.lightColorAttenuation = 0.0;\n        _this.indirectLightIntensity = 0.1;\n        _this.rimTexture = null;\n        _this.rimColor = new THREE.Vector4(0.0, 0.0, 0.0, 1.0);\n        _this.rimLightingMix = 0.0;\n        _this.rimFresnelPower = 1.0;\n        _this.rimLift = 0.0;\n        _this.sphereAdd = null;\n        _this.emissionColor = new THREE.Vector4(0.0, 0.0, 0.0, 1.0);\n        _this.emissiveMap = null;\n        _this.outlineWidthTexture = null;\n        _this.outlineWidth = 0.5;\n        _this.outlineScaledMaxDistance = 1.0;\n        _this.outlineColor = new THREE.Vector4(0.0, 0.0, 0.0, 1.0);\n        _this.outlineLightingMix = 1.0;\n        _this.uvAnimMaskTexture = null;\n        _this.uvAnimScrollX = 0.0;\n        _this.uvAnimScrollY = 0.0;\n        _this.uvAnimRotation = 0.0;\n        _this.shouldApplyUniforms = true;\n        _this._debugMode = MToonMaterialDebugMode.None;\n        _this._blendMode = MToonMaterialRenderMode.Opaque;\n        _this._outlineWidthMode = MToonMaterialOutlineWidthMode.None;\n        _this._outlineColorMode = MToonMaterialOutlineColorMode.FixedColor;\n        _this._cullMode = MToonMaterialCullMode.Back;\n        _this._outlineCullMode = MToonMaterialCullMode.Front;\n        _this._isOutline = false;\n        _this._uvAnimOffsetX = 0.0;\n        _this._uvAnimOffsetY = 0.0;\n        _this._uvAnimPhase = 0.0;\n        _this._colorSpaceGamma = colorSpaceGamma;\n\n        if (parameters === undefined) {\n          parameters = {};\n        }\n\n        ['mToonVersion', 'shadeTexture_ST', 'bumpMap_ST', 'receiveShadowTexture_ST', 'shadingGradeTexture_ST', 'sphereAdd_ST', 'emissionMap_ST', 'outlineWidthTexture_ST', 'srcBlend', 'dstBlend'].forEach(function (key) {\n          if (parameters[key] !== undefined) {\n            delete parameters[key];\n          }\n        });\n        parameters.fog = true;\n        parameters.lights = true;\n        parameters.clipping = true;\n        parameters.skinning = parameters.skinning || false;\n        parameters.morphTargets = parameters.morphTargets || false;\n        parameters.morphNormals = parameters.morphNormals || false;\n        parameters.uniforms = THREE.UniformsUtils.merge([THREE.UniformsLib.common, THREE.UniformsLib.normalmap, THREE.UniformsLib.emissivemap, THREE.UniformsLib.fog, THREE.UniformsLib.lights, {\n          cutoff: {\n            value: 0.5\n          },\n          color: {\n            value: new THREE.Color(1.0, 1.0, 1.0)\n          },\n          colorAlpha: {\n            value: 1.0\n          },\n          shadeColor: {\n            value: new THREE.Color(0.97, 0.81, 0.86)\n          },\n          mainTex_ST: {\n            value: new THREE.Vector4(0.0, 0.0, 1.0, 1.0)\n          },\n          shadeTexture: {\n            value: null\n          },\n          bumpScale: {\n            value: 1.0\n          },\n          receiveShadowRate: {\n            value: 1.0\n          },\n          receiveShadowTexture: {\n            value: null\n          },\n          shadingGradeRate: {\n            value: 1.0\n          },\n          shadingGradeTexture: {\n            value: null\n          },\n          shadeShift: {\n            value: 0.0\n          },\n          shadeToony: {\n            value: 0.9\n          },\n          lightColorAttenuation: {\n            value: 0.0\n          },\n          indirectLightIntensity: {\n            value: 0.1\n          },\n          rimTexture: {\n            value: null\n          },\n          rimColor: {\n            value: new THREE.Color(0.0, 0.0, 0.0)\n          },\n          rimLightingMix: {\n            value: 0.0\n          },\n          rimFresnelPower: {\n            value: 1.0\n          },\n          rimLift: {\n            value: 0.0\n          },\n          sphereAdd: {\n            value: null\n          },\n          emissionColor: {\n            value: new THREE.Color(0.0, 0.0, 0.0)\n          },\n          outlineWidthTexture: {\n            value: null\n          },\n          outlineWidth: {\n            value: 0.5\n          },\n          outlineScaledMaxDistance: {\n            value: 1.0\n          },\n          outlineColor: {\n            value: new THREE.Color(0.0, 0.0, 0.0)\n          },\n          outlineLightingMix: {\n            value: 1.0\n          },\n          uvAnimMaskTexture: {\n            value: null\n          },\n          uvAnimOffsetX: {\n            value: 0.0\n          },\n          uvAnimOffsetY: {\n            value: 0.0\n          },\n          uvAnimTheta: {\n            value: 0.0\n          }\n        }]);\n\n        _this.setValues(parameters);\n\n        _this._updateShaderCode();\n\n        _this._applyUniforms();\n\n        return _this;\n      }\n\n      Object.defineProperty(MToonMaterial.prototype, \"mainTex\", {\n        get: function () {\n          return this.map;\n        },\n        set: function (t) {\n          this.map = t;\n        },\n        enumerable: true,\n        configurable: true\n      });\n      Object.defineProperty(MToonMaterial.prototype, \"bumpMap\", {\n        get: function () {\n          return this.normalMap;\n        },\n        set: function (t) {\n          this.normalMap = t;\n        },\n        enumerable: true,\n        configurable: true\n      });\n      Object.defineProperty(MToonMaterial.prototype, \"emissionMap\", {\n        get: function () {\n          return this.emissiveMap;\n        },\n        set: function (t) {\n          this.emissiveMap = t;\n        },\n        enumerable: true,\n        configurable: true\n      });\n      Object.defineProperty(MToonMaterial.prototype, \"blendMode\", {\n        get: function () {\n          return this._blendMode;\n        },\n        set: function (m) {\n          this._blendMode = m;\n          this.depthWrite = this._blendMode !== MToonMaterialRenderMode.Transparent;\n          this.transparent = this._blendMode === MToonMaterialRenderMode.Transparent || this._blendMode === MToonMaterialRenderMode.TransparentWithZWrite;\n\n          this._updateShaderCode();\n        },\n        enumerable: true,\n        configurable: true\n      });\n      Object.defineProperty(MToonMaterial.prototype, \"debugMode\", {\n        get: function () {\n          return this._debugMode;\n        },\n        set: function (m) {\n          this._debugMode = m;\n\n          this._updateShaderCode();\n        },\n        enumerable: true,\n        configurable: true\n      });\n      Object.defineProperty(MToonMaterial.prototype, \"outlineWidthMode\", {\n        get: function () {\n          return this._outlineWidthMode;\n        },\n        set: function (m) {\n          this._outlineWidthMode = m;\n\n          this._updateShaderCode();\n        },\n        enumerable: true,\n        configurable: true\n      });\n      Object.defineProperty(MToonMaterial.prototype, \"outlineColorMode\", {\n        get: function () {\n          return this._outlineColorMode;\n        },\n        set: function (m) {\n          this._outlineColorMode = m;\n\n          this._updateShaderCode();\n        },\n        enumerable: true,\n        configurable: true\n      });\n      Object.defineProperty(MToonMaterial.prototype, \"cullMode\", {\n        get: function () {\n          return this._cullMode;\n        },\n        set: function (m) {\n          this._cullMode = m;\n\n          this._updateCullFace();\n        },\n        enumerable: true,\n        configurable: true\n      });\n      Object.defineProperty(MToonMaterial.prototype, \"outlineCullMode\", {\n        get: function () {\n          return this._outlineCullMode;\n        },\n        set: function (m) {\n          this._outlineCullMode = m;\n\n          this._updateCullFace();\n        },\n        enumerable: true,\n        configurable: true\n      });\n      Object.defineProperty(MToonMaterial.prototype, \"zWrite\", {\n        get: function () {\n          return this.depthWrite ? 1 : 0;\n        },\n        set: function (i) {\n          this.depthWrite = 0.5 <= i;\n        },\n        enumerable: true,\n        configurable: true\n      });\n      Object.defineProperty(MToonMaterial.prototype, \"isOutline\", {\n        get: function () {\n          return this._isOutline;\n        },\n        set: function (b) {\n          this._isOutline = b;\n\n          this._updateShaderCode();\n\n          this._updateCullFace();\n        },\n        enumerable: true,\n        configurable: true\n      });\n\n      MToonMaterial.prototype.updateVRMMaterials = function (delta) {\n        this._uvAnimOffsetX = this._uvAnimOffsetX + delta * this.uvAnimScrollX;\n        this._uvAnimOffsetY = this._uvAnimOffsetY + delta * this.uvAnimScrollY;\n        this._uvAnimPhase = this._uvAnimPhase + delta * this.uvAnimRotation;\n\n        this._applyUniforms();\n      };\n\n      MToonMaterial.prototype.copy = function (source) {\n        _super.prototype.copy.call(this, source);\n\n        this.cutoff = source.cutoff;\n        this.color.copy(source.color);\n        this.shadeColor.copy(source.shadeColor);\n        this.map = source.map;\n        this.mainTex_ST.copy(source.mainTex_ST);\n        this.shadeTexture = source.shadeTexture;\n        this.bumpScale = source.bumpScale;\n        this.normalMap = source.normalMap;\n        this.receiveShadowRate = source.receiveShadowRate;\n        this.receiveShadowTexture = source.receiveShadowTexture;\n        this.shadingGradeRate = source.shadingGradeRate;\n        this.shadingGradeTexture = source.shadingGradeTexture;\n        this.shadeShift = source.shadeShift;\n        this.shadeToony = source.shadeToony;\n        this.lightColorAttenuation = source.lightColorAttenuation;\n        this.indirectLightIntensity = source.indirectLightIntensity;\n        this.rimTexture = source.rimTexture;\n        this.rimColor.copy(source.rimColor);\n        this.rimLightingMix = source.rimLightingMix;\n        this.rimFresnelPower = source.rimFresnelPower;\n        this.rimLift = source.rimLift;\n        this.sphereAdd = source.sphereAdd;\n        this.emissionColor.copy(source.emissionColor);\n        this.emissiveMap = source.emissiveMap;\n        this.outlineWidthTexture = source.outlineWidthTexture;\n        this.outlineWidth = source.outlineWidth;\n        this.outlineScaledMaxDistance = source.outlineScaledMaxDistance;\n        this.outlineColor.copy(source.outlineColor);\n        this.outlineLightingMix = source.outlineLightingMix;\n        this.uvAnimMaskTexture = source.uvAnimMaskTexture;\n        this.uvAnimScrollX = source.uvAnimScrollX;\n        this.uvAnimScrollY = source.uvAnimScrollY;\n        this.uvAnimRotation = source.uvAnimRotation;\n        this.debugMode = source.debugMode;\n        this.blendMode = source.blendMode;\n        this.outlineWidthMode = source.outlineWidthMode;\n        this.outlineColorMode = source.outlineColorMode;\n        this.cullMode = source.cullMode;\n        this.outlineCullMode = source.outlineCullMode;\n        this.isOutline = source.isOutline;\n        return this;\n      };\n\n      MToonMaterial.prototype._applyUniforms = function () {\n        this.uniforms.uvAnimOffsetX.value = this._uvAnimOffsetX;\n        this.uniforms.uvAnimOffsetY.value = this._uvAnimOffsetY;\n        this.uniforms.uvAnimTheta.value = TAU * this._uvAnimPhase;\n\n        if (!this.shouldApplyUniforms) {\n          return;\n        }\n\n        this.shouldApplyUniforms = false;\n        this.uniforms.cutoff.value = this.cutoff;\n        this.uniforms.color.value.setRGB(this.color.x, this.color.y, this.color.z);\n\n        if (!this._colorSpaceGamma) {\n          this.uniforms.color.value.convertSRGBToLinear();\n        }\n\n        this.uniforms.colorAlpha.value = this.color.w;\n        this.uniforms.shadeColor.value.setRGB(this.shadeColor.x, this.shadeColor.y, this.shadeColor.z);\n\n        if (!this._colorSpaceGamma) {\n          this.uniforms.shadeColor.value.convertSRGBToLinear();\n        }\n\n        this.uniforms.map.value = this.map;\n        this.uniforms.mainTex_ST.value.copy(this.mainTex_ST);\n        this.uniforms.shadeTexture.value = this.shadeTexture;\n        this.uniforms.bumpScale.value = this.bumpScale;\n        this.uniforms.normalMap.value = this.normalMap;\n        this.uniforms.receiveShadowRate.value = this.receiveShadowRate;\n        this.uniforms.receiveShadowTexture.value = this.receiveShadowTexture;\n        this.uniforms.shadingGradeRate.value = this.shadingGradeRate;\n        this.uniforms.shadingGradeTexture.value = this.shadingGradeTexture;\n        this.uniforms.shadeShift.value = this.shadeShift;\n        this.uniforms.shadeToony.value = this.shadeToony;\n        this.uniforms.lightColorAttenuation.value = this.lightColorAttenuation;\n        this.uniforms.indirectLightIntensity.value = this.indirectLightIntensity;\n        this.uniforms.rimTexture.value = this.rimTexture;\n        this.uniforms.rimColor.value.setRGB(this.rimColor.x, this.rimColor.y, this.rimColor.z);\n\n        if (!this._colorSpaceGamma) {\n          this.uniforms.rimColor.value.convertSRGBToLinear();\n        }\n\n        this.uniforms.rimLightingMix.value = this.rimLightingMix;\n        this.uniforms.rimFresnelPower.value = this.rimFresnelPower;\n        this.uniforms.rimLift.value = this.rimLift;\n        this.uniforms.sphereAdd.value = this.sphereAdd;\n        this.uniforms.emissionColor.value.setRGB(this.emissionColor.x, this.emissionColor.y, this.emissionColor.z);\n\n        if (!this._colorSpaceGamma) {\n          this.uniforms.emissionColor.value.convertSRGBToLinear();\n        }\n\n        this.uniforms.emissiveMap.value = this.emissiveMap;\n        this.uniforms.outlineWidthTexture.value = this.outlineWidthTexture;\n        this.uniforms.outlineWidth.value = this.outlineWidth;\n        this.uniforms.outlineScaledMaxDistance.value = this.outlineScaledMaxDistance;\n        this.uniforms.outlineColor.value.setRGB(this.outlineColor.x, this.outlineColor.y, this.outlineColor.z);\n\n        if (!this._colorSpaceGamma) {\n          this.uniforms.outlineColor.value.convertSRGBToLinear();\n        }\n\n        this.uniforms.outlineLightingMix.value = this.outlineLightingMix;\n        this.uniforms.uvAnimMaskTexture.value = this.uvAnimMaskTexture;\n\n        this._updateCullFace();\n      };\n\n      MToonMaterial.prototype._updateShaderCode = function () {\n        this.defines = {\n          OUTLINE: this._isOutline,\n          BLENDMODE_OPAQUE: this._blendMode === MToonMaterialRenderMode.Opaque,\n          BLENDMODE_CUTOUT: this._blendMode === MToonMaterialRenderMode.Cutout,\n          BLENDMODE_TRANSPARENT: this._blendMode === MToonMaterialRenderMode.Transparent || this._blendMode === MToonMaterialRenderMode.TransparentWithZWrite,\n          USE_SHADETEXTURE: this.shadeTexture !== null,\n          USE_RECEIVESHADOWTEXTURE: this.receiveShadowTexture !== null,\n          USE_SHADINGGRADETEXTURE: this.shadingGradeTexture !== null,\n          USE_RIMTEXTURE: this.rimTexture !== null,\n          USE_SPHEREADD: this.sphereAdd !== null,\n          USE_OUTLINEWIDTHTEXTURE: this.outlineWidthTexture !== null,\n          USE_UVANIMMASKTEXTURE: this.uvAnimMaskTexture !== null,\n          DEBUG_NORMAL: this._debugMode === MToonMaterialDebugMode.Normal,\n          DEBUG_LITSHADERATE: this._debugMode === MToonMaterialDebugMode.LitShadeRate,\n          DEBUG_UV: this._debugMode === MToonMaterialDebugMode.UV,\n          OUTLINE_WIDTH_WORLD: this._outlineWidthMode === MToonMaterialOutlineWidthMode.WorldCoordinates,\n          OUTLINE_WIDTH_SCREEN: this._outlineWidthMode === MToonMaterialOutlineWidthMode.ScreenCoordinates,\n          OUTLINE_COLOR_FIXED: this._outlineColorMode === MToonMaterialOutlineColorMode.FixedColor,\n          OUTLINE_COLOR_MIXED: this._outlineColorMode === MToonMaterialOutlineColorMode.MixedLighting\n        };\n        var encodings = (this.shadeTexture !== null ? getTexelDecodingFunction_1.getTexelDecodingFunction('shadeTextureTexelToLinear', this.shadeTexture.encoding) + '\\n' : '') + (this.sphereAdd !== null ? getTexelDecodingFunction_1.getTexelDecodingFunction('sphereAddTexelToLinear', this.sphereAdd.encoding) + '\\n' : '');\n        this.vertexShader = mtoon_vert_1.default;\n        this.fragmentShader = encodings + mtoon_frag_1.default;\n        this.needsUpdate = true;\n      };\n\n      MToonMaterial.prototype._updateCullFace = function () {\n        if (!this.isOutline) {\n          if (this.cullMode === MToonMaterialCullMode.Off) {\n            this.side = THREE.DoubleSide;\n          } else if (this.cullMode === MToonMaterialCullMode.Front) {\n            this.side = THREE.BackSide;\n          } else if (this.cullMode === MToonMaterialCullMode.Back) {\n            this.side = THREE.FrontSide;\n          }\n        } else {\n          if (this.outlineCullMode === MToonMaterialCullMode.Off) {\n            this.side = THREE.DoubleSide;\n          } else if (this.outlineCullMode === MToonMaterialCullMode.Front) {\n            this.side = THREE.BackSide;\n          } else if (this.outlineCullMode === MToonMaterialCullMode.Back) {\n            this.side = THREE.FrontSide;\n          }\n        }\n      };\n\n      return MToonMaterial;\n    }(THREE.ShaderMaterial);\n\n    exports.MToonMaterial = MToonMaterial;\n    /***/\n  },\n\n  /***/\n  \"./src/vrm/material/VRMMaterialImporter.ts\":\n  /*!*************************************************!*\\\r\n    !*** ./src/vrm/material/VRMMaterialImporter.ts ***!\r\n    \\*************************************************/\n\n  /*! no static exports found */\n\n  /***/\n  function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n      return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) {\n          try {\n            step(generator.next(value));\n          } catch (e) {\n            reject(e);\n          }\n        }\n\n        function rejected(value) {\n          try {\n            step(generator[\"throw\"](value));\n          } catch (e) {\n            reject(e);\n          }\n        }\n\n        function step(result) {\n          result.done ? resolve(result.value) : new P(function (resolve) {\n            resolve(result.value);\n          }).then(fulfilled, rejected);\n        }\n\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n      });\n    };\n\n    var __generator = this && this.__generator || function (thisArg, body) {\n      var _ = {\n        label: 0,\n        sent: function () {\n          if (t[0] & 1) throw t[1];\n          return t[1];\n        },\n        trys: [],\n        ops: []\n      },\n          f,\n          y,\n          t,\n          g;\n      return g = {\n        next: verb(0),\n        \"throw\": verb(1),\n        \"return\": verb(2)\n      }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n        return this;\n      }), g;\n\n      function verb(n) {\n        return function (v) {\n          return step([n, v]);\n        };\n      }\n\n      function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n\n        while (_) try {\n          if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n          if (y = 0, t) op = [op[0] & 2, t.value];\n\n          switch (op[0]) {\n            case 0:\n            case 1:\n              t = op;\n              break;\n\n            case 4:\n              _.label++;\n              return {\n                value: op[1],\n                done: false\n              };\n\n            case 5:\n              _.label++;\n              y = op[1];\n              op = [0];\n              continue;\n\n            case 7:\n              op = _.ops.pop();\n\n              _.trys.pop();\n\n              continue;\n\n            default:\n              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n                _ = 0;\n                continue;\n              }\n\n              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n                _.label = op[1];\n                break;\n              }\n\n              if (op[0] === 6 && _.label < t[1]) {\n                _.label = t[1];\n                t = op;\n                break;\n              }\n\n              if (t && _.label < t[2]) {\n                _.label = t[2];\n\n                _.ops.push(op);\n\n                break;\n              }\n\n              if (t[2]) _.ops.pop();\n\n              _.trys.pop();\n\n              continue;\n          }\n\n          op = body.call(thisArg, _);\n        } catch (e) {\n          op = [6, e];\n          y = 0;\n        } finally {\n          f = t = 0;\n        }\n\n        if (op[0] & 5) throw op[1];\n        return {\n          value: op[0] ? op[1] : void 0,\n          done: true\n        };\n      }\n    };\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n\n    var THREE = __webpack_require__(\n    /*! three */\n    \"three\");\n\n    var MToonMaterial_1 = __webpack_require__(\n    /*! ./MToonMaterial */\n    \"./src/vrm/material/MToonMaterial.ts\");\n\n    var VRMUnlitMaterial_1 = __webpack_require__(\n    /*! ./VRMUnlitMaterial */\n    \"./src/vrm/material/VRMUnlitMaterial.ts\");\n\n    var VRMMaterialImporter = function () {\n      function VRMMaterialImporter(options) {\n        if (options === void 0) {\n          options = {};\n        }\n\n        this._colorSpaceGamma = options.colorSpaceGamma || true;\n        this._requestEnvMap = options.requestEnvMap;\n      }\n\n      VRMMaterialImporter.prototype.convertGLTFMaterials = function (gltf) {\n        return __awaiter(this, void 0, Promise, function () {\n          var vrmExt, materialProperties, meshesMap, materialList, materials;\n\n          var _this = this;\n\n          return __generator(this, function (_a) {\n            switch (_a.label) {\n              case 0:\n                vrmExt = gltf.parser.json.extensions && gltf.parser.json.extensions.VRM;\n\n                if (!vrmExt) {\n                  return [2, null];\n                }\n\n                materialProperties = vrmExt.materialProperties;\n\n                if (!materialProperties) {\n                  return [2, null];\n                }\n\n                return [4, gltf.parser.getDependencies('mesh')];\n\n              case 1:\n                meshesMap = _a.sent();\n                materialList = {};\n                materials = [];\n                return [4, Promise.all(meshesMap.map(function (mesh, meshIndex) {\n                  return __awaiter(_this, void 0, void 0, function () {\n                    var primitives;\n\n                    var _this = this;\n\n                    return __generator(this, function (_a) {\n                      switch (_a.label) {\n                        case 0:\n                          primitives = mesh.type === 'Group' ? mesh.children : [mesh];\n                          return [4, Promise.all(primitives.map(function (primitive, primitiveIndex) {\n                            return __awaiter(_this, void 0, void 0, function () {\n                              var vrmMaterialIndex, props, vrmMaterials;\n                              return __generator(this, function (_a) {\n                                switch (_a.label) {\n                                  case 0:\n                                    if (!Array.isArray(primitive.material)) {\n                                      primitive.material = [primitive.material];\n                                      primitive.geometry.addGroup(0, primitive.geometry.index.count, 0);\n                                    }\n\n                                    vrmMaterialIndex = gltf.parser.json.meshes[meshIndex].primitives[primitiveIndex].material;\n                                    props = materialProperties[vrmMaterialIndex];\n\n                                    if (!props) {\n                                      console.warn(\"VRMMaterialImporter: There are no material definition for material #\" + vrmMaterialIndex + \" on VRM extension.\");\n                                      props = {\n                                        shader: 'VRM_USE_GLTFSHADER'\n                                      };\n                                    }\n\n                                    if (!materialList[vrmMaterialIndex]) return [3, 1];\n                                    vrmMaterials = materialList[vrmMaterialIndex];\n                                    return [3, 3];\n\n                                  case 1:\n                                    return [4, this.createVRMMaterials(primitive.material[0], props, gltf)];\n\n                                  case 2:\n                                    vrmMaterials = _a.sent();\n                                    materialList[vrmMaterialIndex] = vrmMaterials;\n                                    materials.push(vrmMaterials.surface);\n\n                                    if (vrmMaterials.outline) {\n                                      materials.push(vrmMaterials.outline);\n                                    }\n\n                                    _a.label = 3;\n\n                                  case 3:\n                                    primitive.material[0] = vrmMaterials.surface;\n\n                                    if (this._requestEnvMap) {\n                                      this._requestEnvMap().then(function (envMap) {\n                                        vrmMaterials.surface.envMap = envMap;\n                                        vrmMaterials.surface.needsUpdate = true;\n                                      });\n                                    }\n\n                                    primitive.renderOrder = props.renderQueue || 2000;\n\n                                    if (vrmMaterials.outline) {\n                                      primitive.material[1] = vrmMaterials.outline;\n                                      primitive.geometry.addGroup(0, primitive.geometry.index.count, 1);\n                                    }\n\n                                    return [2];\n                                }\n                              });\n                            });\n                          }))];\n\n                        case 1:\n                          _a.sent();\n\n                          return [2];\n                      }\n                    });\n                  });\n                }))];\n\n              case 2:\n                _a.sent();\n\n                return [2, materials];\n            }\n          });\n        });\n      };\n\n      VRMMaterialImporter.prototype.createVRMMaterials = function (originalMaterial, vrmProps, gltf) {\n        return __awaiter(this, void 0, Promise, function () {\n          var newSurface, newOutline, params_1, params, params, params, params;\n\n          var _this = this;\n\n          return __generator(this, function (_a) {\n            switch (_a.label) {\n              case 0:\n                if (!(vrmProps.shader === 'VRM/MToon')) return [3, 2];\n                return [4, this._extractMaterialProperties(originalMaterial, vrmProps, gltf)];\n\n              case 1:\n                params_1 = _a.sent();\n                ['srcBlend', 'dstBlend', 'isFirstSetup'].forEach(function (name) {\n                  if (params_1[name] !== undefined) {\n                    delete params_1[name];\n                  }\n                });\n                ['mainTex', 'shadeTexture', 'emission', 'sphereAdd'].forEach(function (name) {\n                  if (params_1[name] !== undefined) {\n                    params_1[name].encoding = _this._colorSpaceGamma ? THREE.LinearEncoding : THREE.sRGBEncoding;\n                  }\n                });\n                newSurface = new MToonMaterial_1.MToonMaterial(this._colorSpaceGamma, params_1);\n\n                if (params_1.outlineWidthMode !== MToonMaterial_1.MToonMaterialOutlineWidthMode.None) {\n                  params_1.isOutline = true;\n                  newOutline = new MToonMaterial_1.MToonMaterial(this._colorSpaceGamma, params_1);\n                }\n\n                return [3, 11];\n\n              case 2:\n                if (!(vrmProps.shader === 'VRM/UnlitTexture')) return [3, 4];\n                return [4, this._extractMaterialProperties(originalMaterial, vrmProps, gltf)];\n\n              case 3:\n                params = _a.sent();\n                params.renderType = VRMUnlitMaterial_1.VRMUnlitMaterialRenderType.Opaque;\n                newSurface = new VRMUnlitMaterial_1.VRMUnlitMaterial(params);\n                return [3, 11];\n\n              case 4:\n                if (!(vrmProps.shader === 'VRM/UnlitCutout')) return [3, 6];\n                return [4, this._extractMaterialProperties(originalMaterial, vrmProps, gltf)];\n\n              case 5:\n                params = _a.sent();\n                params.renderType = VRMUnlitMaterial_1.VRMUnlitMaterialRenderType.Cutout;\n                newSurface = new VRMUnlitMaterial_1.VRMUnlitMaterial(params);\n                return [3, 11];\n\n              case 6:\n                if (!(vrmProps.shader === 'VRM/UnlitTransparent')) return [3, 8];\n                return [4, this._extractMaterialProperties(originalMaterial, vrmProps, gltf)];\n\n              case 7:\n                params = _a.sent();\n                params.renderType = VRMUnlitMaterial_1.VRMUnlitMaterialRenderType.Transparent;\n                newSurface = new VRMUnlitMaterial_1.VRMUnlitMaterial(params);\n                return [3, 11];\n\n              case 8:\n                if (!(vrmProps.shader === 'VRM/UnlitTransparentZWrite')) return [3, 10];\n                return [4, this._extractMaterialProperties(originalMaterial, vrmProps, gltf)];\n\n              case 9:\n                params = _a.sent();\n                params.renderType = VRMUnlitMaterial_1.VRMUnlitMaterialRenderType.TransparentWithZWrite;\n                newSurface = new VRMUnlitMaterial_1.VRMUnlitMaterial(params);\n                return [3, 11];\n\n              case 10:\n                if (vrmProps.shader !== 'VRM_USE_GLTFSHADER') {\n                  console.warn(\"Unknown shader detected: \\\"\" + vrmProps.shader + \"\\\"\");\n                }\n\n                newSurface = this._convertGLTFMaterial(originalMaterial.clone());\n                _a.label = 11;\n\n              case 11:\n                newSurface.name = originalMaterial.name;\n                newSurface.userData = JSON.parse(JSON.stringify(originalMaterial.userData));\n                newSurface.userData.vrmMaterialProperties = vrmProps;\n\n                if (newOutline) {\n                  newOutline.name = originalMaterial.name + ' (Outline)';\n                  newOutline.userData = JSON.parse(JSON.stringify(originalMaterial.userData));\n                  newOutline.userData.vrmMaterialProperties = vrmProps;\n                }\n\n                return [2, {\n                  surface: newSurface,\n                  outline: newOutline\n                }];\n            }\n          });\n        });\n      };\n\n      VRMMaterialImporter.prototype._renameMaterialProperty = function (name) {\n        if (name[0] !== '_') {\n          console.warn(\"VRMMaterials: Given property name \\\"\" + name + \"\\\" might be invalid\");\n          return name;\n        }\n\n        name = name.substring(1);\n\n        if (!/[A-Z]/.test(name[0])) {\n          console.warn(\"VRMMaterials: Given property name \\\"\" + name + \"\\\" might be invalid\");\n          return name;\n        }\n\n        return name[0].toLowerCase() + name.substring(1);\n      };\n\n      VRMMaterialImporter.prototype._convertGLTFMaterial = function (material) {\n        if (material.isMeshStandardMaterial) {\n          var mtl = material;\n\n          if (this._colorSpaceGamma) {\n            if (mtl.map) {\n              mtl.map.encoding = THREE.LinearEncoding;\n            }\n\n            if (mtl.emissiveMap) {\n              mtl.emissiveMap.encoding = THREE.LinearEncoding;\n            }\n          } else {\n            mtl.color.convertSRGBToLinear();\n            mtl.emissive.convertSRGBToLinear();\n          }\n        }\n\n        if (material.isMeshBasicMaterial) {\n          var mtl = material;\n\n          if (this._colorSpaceGamma) {\n            if (mtl.map) {\n              mtl.map.encoding = THREE.LinearEncoding;\n            }\n          } else {\n            mtl.color.convertSRGBToLinear();\n          }\n        }\n\n        return material;\n      };\n\n      VRMMaterialImporter.prototype._extractMaterialProperties = function (originalMaterial, vrmProps, gltf) {\n        var taskList = [];\n        var params = {};\n\n        if (vrmProps.textureProperties) {\n          var _loop_1 = function (name) {\n            var newName = this_1._renameMaterialProperty(name);\n\n            var textureIndex = vrmProps.textureProperties[name];\n            taskList.push(gltf.parser.getDependency('texture', textureIndex).then(function (texture) {\n              params[newName] = texture;\n            }));\n          };\n\n          var this_1 = this;\n\n          for (var _i = 0, _a = Object.keys(vrmProps.textureProperties); _i < _a.length; _i++) {\n            var name = _a[_i];\n\n            _loop_1(name);\n          }\n        }\n\n        if (vrmProps.floatProperties) {\n          for (var _b = 0, _c = Object.keys(vrmProps.floatProperties); _b < _c.length; _b++) {\n            var name = _c[_b];\n\n            var newName = this._renameMaterialProperty(name);\n\n            params[newName] = vrmProps.floatProperties[name];\n          }\n        }\n\n        if (vrmProps.vectorProperties) {\n          var _loop_2 = function (name) {\n            var _a;\n\n            var newName = this_2._renameMaterialProperty(name);\n\n            var isTextureST = ['_MainTex', '_ShadeTexture', '_BumpMap', '_ReceiveShadowTexture', '_ShadingGradeTexture', '_SphereAdd', '_EmissionMap', '_OutlineWidthTexture'].some(function (textureName) {\n              return name === textureName;\n            });\n\n            if (isTextureST) {\n              newName += '_ST';\n            }\n\n            params[newName] = new ((_a = THREE.Vector4).bind.apply(_a, [void 0].concat(vrmProps.vectorProperties[name])))();\n          };\n\n          var this_2 = this;\n\n          for (var _d = 0, _e = Object.keys(vrmProps.vectorProperties); _d < _e.length; _d++) {\n            var name = _e[_d];\n\n            _loop_2(name);\n          }\n        }\n\n        if (vrmProps.keywordMap._ALPHATEST_ON && params.blendMode === MToonMaterial_1.MToonMaterialRenderMode.Opaque) {\n          params.blendMode = MToonMaterial_1.MToonMaterialRenderMode.Cutout;\n        }\n\n        params.skinning = originalMaterial.skinning || false;\n        params.morphTargets = originalMaterial.morphTargets || false;\n        params.morphNormals = originalMaterial.morphNormals || false;\n        return Promise.all(taskList).then(function () {\n          return params;\n        });\n      };\n\n      return VRMMaterialImporter;\n    }();\n\n    exports.VRMMaterialImporter = VRMMaterialImporter;\n    /***/\n  },\n\n  /***/\n  \"./src/vrm/material/VRMUnlitMaterial.ts\":\n  /*!**********************************************!*\\\r\n    !*** ./src/vrm/material/VRMUnlitMaterial.ts ***!\r\n    \\**********************************************/\n\n  /*! no static exports found */\n\n  /***/\n  function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    var __extends = this && this.__extends || function () {\n      var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (d, b) {\n          d.__proto__ = b;\n        } || function (d, b) {\n          for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n        };\n\n        return extendStatics(d, b);\n      };\n\n      return function (d, b) {\n        extendStatics(d, b);\n\n        function __() {\n          this.constructor = d;\n        }\n\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n      };\n    }();\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n\n    var THREE = __webpack_require__(\n    /*! three */\n    \"three\");\n\n    var unlit_vert_1 = __webpack_require__(\n    /*! ./shaders/unlit.vert */\n    \"./src/vrm/material/shaders/unlit.vert\");\n\n    var unlit_frag_1 = __webpack_require__(\n    /*! ./shaders/unlit.frag */\n    \"./src/vrm/material/shaders/unlit.frag\");\n\n    var VRMUnlitMaterialRenderType;\n\n    (function (VRMUnlitMaterialRenderType) {\n      VRMUnlitMaterialRenderType[VRMUnlitMaterialRenderType[\"Opaque\"] = 0] = \"Opaque\";\n      VRMUnlitMaterialRenderType[VRMUnlitMaterialRenderType[\"Cutout\"] = 1] = \"Cutout\";\n      VRMUnlitMaterialRenderType[VRMUnlitMaterialRenderType[\"Transparent\"] = 2] = \"Transparent\";\n      VRMUnlitMaterialRenderType[VRMUnlitMaterialRenderType[\"TransparentWithZWrite\"] = 3] = \"TransparentWithZWrite\";\n    })(VRMUnlitMaterialRenderType = exports.VRMUnlitMaterialRenderType || (exports.VRMUnlitMaterialRenderType = {}));\n\n    var VRMUnlitMaterial = function (_super) {\n      __extends(VRMUnlitMaterial, _super);\n\n      function VRMUnlitMaterial(parameters) {\n        var _this = _super.call(this) || this;\n\n        _this.isVRMUnlitMaterial = true;\n        _this.cutoff = 0.5;\n        _this.map = null;\n        _this.mainTex_ST = new THREE.Vector4(0.0, 0.0, 1.0, 1.0);\n        _this._renderType = VRMUnlitMaterialRenderType.Opaque;\n        _this.shouldApplyUniforms = true;\n\n        if (parameters === undefined) {\n          parameters = {};\n        }\n\n        parameters.fog = true;\n        parameters.clipping = true;\n        parameters.skinning = parameters.skinning || false;\n        parameters.morphTargets = parameters.morphTargets || false;\n        parameters.morphNormals = parameters.morphNormals || false;\n        parameters.uniforms = THREE.UniformsUtils.merge([THREE.UniformsLib.common, THREE.UniformsLib.fog, {\n          cutoff: {\n            value: 0.5\n          },\n          mainTex_ST: {\n            value: new THREE.Vector4(0.0, 0.0, 1.0, 1.0)\n          }\n        }]);\n\n        _this.setValues(parameters);\n\n        _this._updateShaderCode();\n\n        _this._applyUniforms();\n\n        return _this;\n      }\n\n      Object.defineProperty(VRMUnlitMaterial.prototype, \"mainTex\", {\n        get: function () {\n          return this.map;\n        },\n        set: function (t) {\n          this.map = t;\n        },\n        enumerable: true,\n        configurable: true\n      });\n      Object.defineProperty(VRMUnlitMaterial.prototype, \"renderType\", {\n        get: function () {\n          return this._renderType;\n        },\n        set: function (t) {\n          this._renderType = t;\n          this.depthWrite = this._renderType !== VRMUnlitMaterialRenderType.Transparent;\n          this.transparent = this._renderType === VRMUnlitMaterialRenderType.Transparent || this._renderType === VRMUnlitMaterialRenderType.TransparentWithZWrite;\n\n          this._updateShaderCode();\n        },\n        enumerable: true,\n        configurable: true\n      });\n\n      VRMUnlitMaterial.prototype.updateVRMMaterials = function (delta) {\n        this._applyUniforms();\n      };\n\n      VRMUnlitMaterial.prototype.copy = function (source) {\n        _super.prototype.copy.call(this, source);\n\n        this.cutoff = source.cutoff;\n        this.map = source.map;\n        this.mainTex_ST.copy(source.mainTex_ST);\n        this.renderType = source.renderType;\n        return this;\n      };\n\n      VRMUnlitMaterial.prototype._applyUniforms = function () {\n        if (!this.shouldApplyUniforms) {\n          return;\n        }\n\n        this.shouldApplyUniforms = false;\n        this.uniforms.cutoff.value = this.cutoff;\n        this.uniforms.map.value = this.map;\n        this.uniforms.mainTex_ST.value.copy(this.mainTex_ST);\n      };\n\n      VRMUnlitMaterial.prototype._updateShaderCode = function () {\n        this.defines = {\n          RENDERTYPE_OPAQUE: this._renderType === VRMUnlitMaterialRenderType.Opaque,\n          RENDERTYPE_CUTOUT: this._renderType === VRMUnlitMaterialRenderType.Cutout,\n          RENDERTYPE_TRANSPARENT: this._renderType === VRMUnlitMaterialRenderType.Transparent || this._renderType === VRMUnlitMaterialRenderType.TransparentWithZWrite\n        };\n        this.vertexShader = unlit_vert_1.default;\n        this.fragmentShader = unlit_frag_1.default;\n        this.needsUpdate = true;\n      };\n\n      return VRMUnlitMaterial;\n    }(THREE.ShaderMaterial);\n\n    exports.VRMUnlitMaterial = VRMUnlitMaterial;\n    /***/\n  },\n\n  /***/\n  \"./src/vrm/material/getTexelDecodingFunction.ts\":\n  /*!******************************************************!*\\\r\n    !*** ./src/vrm/material/getTexelDecodingFunction.ts ***!\r\n    \\******************************************************/\n\n  /*! no static exports found */\n\n  /***/\n  function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n\n    var THREE = __webpack_require__(\n    /*! three */\n    \"three\");\n\n    exports.getEncodingComponents = function (encoding) {\n      switch (encoding) {\n        case THREE.LinearEncoding:\n          return ['Linear', '( value )'];\n\n        case THREE.sRGBEncoding:\n          return ['sRGB', '( value )'];\n\n        case THREE.RGBEEncoding:\n          return ['RGBE', '( value )'];\n\n        case THREE.RGBM7Encoding:\n          return ['RGBM', '( value, 7.0 )'];\n\n        case THREE.RGBM16Encoding:\n          return ['RGBM', '( value, 16.0 )'];\n\n        case THREE.RGBDEncoding:\n          return ['RGBD', '( value, 256.0 )'];\n\n        case THREE.GammaEncoding:\n          return ['Gamma', '( value, float( GAMMA_FACTOR ) )'];\n\n        default:\n          throw new Error('unsupported encoding: ' + encoding);\n      }\n    };\n\n    exports.getTexelDecodingFunction = function (functionName, encoding) {\n      var components = exports.getEncodingComponents(encoding);\n      return 'vec4 ' + functionName + '( vec4 value ) { return ' + components[0] + 'ToLinear' + components[1] + '; }';\n    };\n    /***/\n\n  },\n\n  /***/\n  \"./src/vrm/material/index.ts\":\n  /*!***********************************!*\\\r\n    !*** ./src/vrm/material/index.ts ***!\r\n    \\***********************************/\n\n  /*! no static exports found */\n\n  /***/\n  function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    function __export(m) {\n      for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n    }\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n\n    __export(__webpack_require__(\n    /*! ./MToonMaterial */\n    \"./src/vrm/material/MToonMaterial.ts\"));\n\n    __export(__webpack_require__(\n    /*! ./VRMMaterialImporter */\n    \"./src/vrm/material/VRMMaterialImporter.ts\"));\n\n    __export(__webpack_require__(\n    /*! ./VRMUnlitMaterial */\n    \"./src/vrm/material/VRMUnlitMaterial.ts\"));\n    /***/\n\n  },\n\n  /***/\n  \"./src/vrm/material/shaders/mtoon.frag\":\n  /*!*********************************************!*\\\r\n    !*** ./src/vrm/material/shaders/mtoon.frag ***!\r\n    \\*********************************************/\n\n  /*! exports provided: default */\n\n  /***/\n  function (module, __webpack_exports__, __webpack_require__) {\n    \"use strict\";\n\n    __webpack_require__.r(__webpack_exports__);\n    /* harmony default export */\n\n\n    __webpack_exports__[\"default\"] = \"// #define PHONG\\n\\n#ifdef BLENDMODE_CUTOUT\\n  uniform float cutoff;\\n#endif\\n\\nuniform vec3 color;\\nuniform float colorAlpha;\\nuniform vec3 shadeColor;\\n#ifdef USE_SHADETEXTURE\\n  uniform sampler2D shadeTexture;\\n#endif\\n\\nuniform float receiveShadowRate;\\n#ifdef USE_RECEIVESHADOWTEXTURE\\n  uniform sampler2D receiveShadowTexture;\\n#endif\\n\\nuniform float shadingGradeRate;\\n#ifdef USE_SHADINGGRADETEXTURE\\n  uniform sampler2D shadingGradeTexture;\\n#endif\\n\\nuniform float shadeShift;\\nuniform float shadeToony;\\nuniform float lightColorAttenuation;\\nuniform float indirectLightIntensity;\\n\\n#ifdef USE_RIMTEXTURE\\n  uniform sampler2D rimTexture;\\n#endif\\nuniform vec3 rimColor;\\nuniform float rimLightingMix;\\nuniform float rimFresnelPower;\\nuniform float rimLift;\\n\\n#ifdef USE_SPHEREADD\\n  uniform sampler2D sphereAdd;\\n#endif\\n\\nuniform vec3 emissionColor;\\n\\nuniform vec3 outlineColor;\\nuniform float outlineLightingMix;\\n\\n#ifdef USE_UVANIMMASKTEXTURE\\n  uniform sampler2D uvAnimMaskTexture;\\n#endif\\n\\nuniform float uvAnimOffsetX;\\nuniform float uvAnimOffsetY;\\nuniform float uvAnimTheta;\\n\\n#include <common>\\n#include <packing>\\n#include <dithering_pars_fragment>\\n#include <color_pars_fragment>\\n\\n// #include <uv_pars_fragment>\\n#if defined( USE_MAP ) || defined( USE_SHADETEXTURE ) || defined( USE_NORMALMAP ) || defined( USE_RECEIVESHADOWTEXTURE ) || defined( USE_SHADINGGRADETEXTURE ) || defined( USE_RIMTEXTURE ) || defined( USE_EMISSIVEMAP ) || defined( USE_OUTLINEWIDTHTEXTURE ) || defined( USE_UVANIMMASKTEXTURE )\\n  varying vec2 vUv;\\n#endif\\n\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n// #include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n// #include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n// #include <envmap_pars_fragment>\\n// #include <gradientmap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <bsdfs>\\n#include <lights_pars_begin>\\n\\n// #include <lights_phong_pars_fragment>\\nvarying vec3 vViewPosition;\\n\\n#ifndef FLAT_SHADED\\n  varying vec3 vNormal;\\n#endif\\n\\n#define Material_LightProbeLOD( material ) (0)\\n\\n#include <shadowmap_pars_fragment>\\n// #include <bumpmap_pars_fragment>\\n\\n// #include <normalmap_pars_fragment>\\n#ifdef USE_NORMALMAP\\n  uniform sampler2D normalMap;\\n  uniform float bumpScale;\\n\\n  // this number is very random, this is still a \\n  #define UV_DERIVATIVE_EPSILON 1E-6\\n\\n  // Per-Pixel Tangent Space Normal Mapping\\n  // http://hacksoflife.blogspot.ch/2009/11/per-pixel-tangent-space-normal-mapping.html\\n  vec3 perturbNormal2Arb( vec2 uv, vec3 eye_pos, vec3 surf_norm ) {\\n    // Workaround for Adreno 3XX dFd*( vec3 ) bug. See #9988\\n    vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\\n    vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\\n    vec2 st0 = dFdx( uv.st );\\n    vec2 st1 = dFdy( uv.st );\\n\\n    float scale = sign( st1.t * st0.s - st0.t * st1.s ); // we do not care about the magnitude\\n    vec3 S = ( q0 * st1.t - q1 * st0.t ) * scale;\\n    vec3 T = ( - q0 * st1.s + q1 * st0.s ) * scale;\\n\\n    // Workaround for the issue that happens when delta of uv = 0.0\\n    if ( length( S ) == 0.0 || length( T ) == 0.0 ) {\\n      return surf_norm;\\n    }\\n\\n    S = normalize( S );\\n    T = normalize( T );\\n    vec3 N = normalize( surf_norm );\\n\\n    vec3 mapN = texture2D( normalMap, uv ).xyz * 2.0 - 1.0;\\n\\n    mapN.xy *= bumpScale;\\n\\n    #ifdef DOUBLE_SIDED\\n      // Workaround for Adreno GPUs gl_FrontFacing bug. See #15850 and #10331\\n      // http://hacksoflife.blogspot.com/2009/11/per-pixel-tangent-space-normal-mapping.html?showComment=1522254677437#c5087545147696715943\\n      vec3 NfromST = cross( S, T );\\n      if( dot( NfromST, N ) > 0.0 ) {\\n        S *= -1.0;\\n        T *= -1.0;\\n      }\\n    #else\\n      mapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\\n    #endif\\n\\n    mat3 tsn = mat3( S, T, N );\\n\\n    return normalize( tsn * mapN );\\n  }\\n#endif\\n\\n// #include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\n\\n// == lighting stuff ===========================================================\\nfloat getLightIntensity(\\n  const in IncidentLight directLight,\\n  const in GeometricContext geometry,\\n  const in float shadow,\\n  const in float shadingGrade\\n) {\\n  float lightIntensity = dot( geometry.normal, directLight.direction );\\n  lightIntensity = 0.5 + 0.5 * lightIntensity;\\n  lightIntensity = lightIntensity * shadow;\\n  lightIntensity = lightIntensity * shadingGrade;\\n  lightIntensity = lightIntensity * 2.0 - 1.0;\\n  return smoothstep( shadeShift, shadeShift + ( 1.0 - shadeToony ), lightIntensity );\\n}\\n\\nvec3 getLighting( const in vec3 lightColor ) {\\n  vec3 lighting = lightColor;\\n  lighting = mix(\\n    lighting,\\n    vec3( max( 0.001, max( lighting.x, max( lighting.y, lighting.z ) ) ) ),\\n    lightColorAttenuation\\n  );\\n\\n  #ifndef PHYSICALLY_CORRECT_LIGHTS\\n    lighting *= PI;\\n  #endif\\n\\n  return lighting;\\n}\\n\\nvec3 getDiffuse(\\n  const in vec3 lit,\\n  const in vec3 shade,\\n  const in float lightIntensity,\\n  const in vec3 lighting\\n) {\\n  #ifdef DEBUG_LITSHADERATE\\n    return vec3( BRDF_Diffuse_Lambert( lightIntensity * lighting ) );\\n  #endif\\n\\n  return lighting * BRDF_Diffuse_Lambert( mix( shade, lit, lightIntensity ) );\\n}\\n\\nvec3 calcDirectDiffuse(\\n  const in vec2 uv,\\n  const in vec3 lit,\\n  const in vec3 shade,\\n  in GeometricContext geometry,\\n  inout ReflectedLight reflectedLight\\n) {\\n  IncidentLight directLight;\\n  vec3 lightingSum = vec3( 0.0 );\\n\\n  float shadingGrade = 1.0;\\n  #ifdef USE_SHADINGGRADETEXTURE\\n    shadingGrade = 1.0 - shadingGradeRate * ( 1.0 - texture2D( shadingGradeTexture, uv ).r );\\n  #endif\\n\\n  float receiveShadow = receiveShadowRate;\\n  #ifdef USE_RECEIVESHADOWTEXTURE\\n    receiveShadow *= texture2D( receiveShadowTexture, uv ).a;\\n  #endif\\n\\n  #if ( NUM_POINT_LIGHTS > 0 )\\n    PointLight pointLight;\\n\\n    #pragma unroll_loop\\n    for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n      pointLight = pointLights[ i ];\\n      getPointDirectLightIrradiance( pointLight, geometry, directLight );\\n\\n      float atten = 1.0;\\n      #ifdef USE_SHADOWMAP\\n        atten = all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\\n      #endif\\n\\n      float shadow = 1.0 - receiveShadow * ( 1.0 - ( 0.5 + 0.5 * atten ) );\\n      float lightIntensity = getLightIntensity( directLight, geometry, shadow, shadingGrade );\\n      vec3 lighting = getLighting( directLight.color );\\n      reflectedLight.directDiffuse += getDiffuse( lit, shade, lightIntensity, lighting );\\n      lightingSum += lighting;\\n    }\\n  #endif\\n\\n  #if ( NUM_SPOT_LIGHTS > 0 )\\n    SpotLight spotLight;\\n\\n    #pragma unroll_loop\\n    for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n      spotLight = spotLights[ i ];\\n      getSpotDirectLightIrradiance( spotLight, geometry, directLight );\\n\\n      float atten = 1.0;\\n      #ifdef USE_SHADOWMAP\\n        atten = all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\\n      #endif\\n\\n      float shadow = 1.0 - receiveShadow * ( 1.0 - ( 0.5 + 0.5 * atten ) );\\n      float lightIntensity = getLightIntensity( directLight, geometry, shadow, shadingGrade );\\n      vec3 lighting = getLighting( directLight.color );\\n      reflectedLight.directDiffuse += getDiffuse( lit, shade, lightIntensity, lighting );\\n      lightingSum += lighting;\\n    }\\n  #endif\\n\\n  #if ( NUM_DIR_LIGHTS > 0 )\\n    DirectionalLight directionalLight;\\n\\n    #pragma unroll_loop\\n    for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n      directionalLight = directionalLights[ i ];\\n      getDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\\n\\n      float atten = 1.0;\\n      #ifdef USE_SHADOWMAP\\n        atten = all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\\n      #endif\\n\\n      float shadow = 1.0 - receiveShadow * ( 1.0 - ( 0.5 + 0.5 * atten ) );\\n      float lightIntensity = getLightIntensity( directLight, geometry, shadow, shadingGrade );\\n      vec3 lighting = getLighting( directLight.color );\\n      reflectedLight.directDiffuse += getDiffuse( lit, shade, lightIntensity, lighting );\\n      lightingSum += lighting;\\n    }\\n  #endif\\n\\n  return lightingSum;\\n}\\n\\n// == post correction ==========================================================\\nvoid postCorrection() {\\n  #include <tonemapping_fragment>\\n  #include <encodings_fragment>\\n  #include <fog_fragment>\\n  #include <premultiplied_alpha_fragment>\\n  #include <dithering_fragment>\\n}\\n\\n// == main procedure ===========================================================\\nvoid main() {\\n  #include <clipping_planes_fragment>\\n\\n  vec2 uv = vec2(0.5, 0.5);\\n\\n  #if defined( USE_MAP ) || defined( USE_SHADETEXTURE ) || defined( USE_NORMALMAP ) || defined( USE_RECEIVESHADOWTEXTURE ) || defined( USE_SHADINGGRADETEXTURE ) || defined( USE_RIMTEXTURE ) || defined( USE_EMISSIVEMAP ) || defined( USE_OUTLINEWIDTHTEXTURE ) || defined( USE_UVANIMMASKTEXTURE )\\n    uv = vUv;\\n\\n    float uvAnimMask = 1.0;\\n    #ifdef USE_UVANIMMASKTEXTURE\\n      uvAnimMask = texture2D( uvAnimMaskTexture, uv ).x;\\n    #endif\\n\\n    uv = uv + vec2( uvAnimOffsetX, uvAnimOffsetY ) * uvAnimMask;\\n    float uvRotCos = cos( uvAnimTheta * uvAnimMask );\\n    float uvRotSin = sin( uvAnimTheta * uvAnimMask );\\n    uv = mat2( uvRotCos, uvRotSin, -uvRotSin, uvRotCos ) * ( uv - 0.5 ) + 0.5;\\n  #endif\\n\\n  #ifdef DEBUG_UV\\n    gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\\n    #if defined( USE_MAP ) || defined( USE_SHADETEXTURE ) || defined( USE_NORMALMAP ) || defined( USE_RECEIVESHADOWTEXTURE ) || defined( USE_SHADINGGRADETEXTURE ) || defined( USE_RIMTEXTURE ) || defined( USE_EMISSIVEMAP ) || defined( USE_OUTLINEWIDTHTEXTURE ) || defined( USE_UVANIMMASKTEXTURE )\\n      gl_FragColor = vec4( uv, 0.0, 1.0 );\\n    #endif\\n    return;\\n  #endif\\n\\n  vec4 diffuseColor = vec4( color, colorAlpha );\\n  ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n  vec3 totalEmissiveRadiance = emissionColor;\\n\\n  #include <logdepthbuf_fragment>\\n\\n  // #include <map_fragment>\\n  #ifdef USE_MAP\\n    diffuseColor *= mapTexelToLinear( texture2D( map, uv ) );\\n  #endif\\n\\n  #include <color_fragment>\\n  // #include <alphamap_fragment>\\n\\n  // -- MToon: alpha -----------------------------------------------------------\\n  // #include <alphatest_fragment>\\n  #ifdef BLENDMODE_CUTOUT\\n    if ( diffuseColor.a <= cutoff ) { discard; }\\n    diffuseColor.a = 1.0;\\n  #endif\\n\\n  #ifdef BLENDMODE_OPAQUE\\n    diffuseColor.a = 1.0;\\n  #endif\\n\\n  #if defined( OUTLINE ) && defined( OUTLINE_COLOR_FIXED ) // omitting DebugMode\\n    gl_FragColor = vec4( outlineColor, diffuseColor.a );\\n    postCorrection();\\n    return;\\n  #endif\\n\\n  // #include <specularmap_fragment>\\n  #include <normal_fragment_begin>\\n\\n  #ifdef OUTLINE\\n    normal *= -1.0;\\n  #endif\\n\\n  // #include <normal_fragment_maps>\\n  #ifdef USE_NORMALMAP\\n    normal = perturbNormal2Arb( uv, -vViewPosition, normal );\\n  #endif\\n\\n  // #include <emissivemap_fragment>\\n  #ifdef USE_EMISSIVEMAP\\n    totalEmissiveRadiance *= emissiveMapTexelToLinear( texture2D( emissiveMap, uv ) ).rgb;\\n  #endif\\n\\n  #ifdef DEBUG_NORMAL\\n    gl_FragColor = vec4( 0.5 + 0.5 * normal, 1.0 );\\n    return;\\n  #endif\\n\\n  // -- MToon: lighting --------------------------------------------------------\\n  // accumulation\\n  // #include <lights_phong_fragment>\\n  // #include <lights_fragment_begin>\\n  vec3 lit = diffuseColor.rgb;\\n  vec3 shade = shadeColor;\\n  #ifdef USE_SHADETEXTURE\\n    shade *= shadeTextureTexelToLinear( texture2D( shadeTexture, uv ) ).rgb;\\n  #endif\\n\\n  GeometricContext geometry;\\n\\n  geometry.position = - vViewPosition;\\n  geometry.normal = normal;\\n  geometry.viewDir = normalize( vViewPosition );\\n\\n  vec3 lighting = calcDirectDiffuse( uv, diffuseColor.rgb, shade, geometry, reflectedLight );\\n\\n  vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\\n  #if ( NUM_HEMI_LIGHTS > 0 )\\n    #pragma unroll_loop\\n    for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\\n      irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\\n    }\\n  #endif\\n\\n  // #include <lights_fragment_maps>\\n  #ifdef USE_LIGHTMAP\\n    vec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).rgb * lightMapIntensity;\\n    #ifndef PHYSICALLY_CORRECT_LIGHTS\\n      lightMapIrradiance *= PI; // factor of PI should not be present; included here to prevent breakage\\n    #endif\\n    irradiance += lightMapIrradiance;\\n  #endif\\n\\n  // #include <lights_fragment_end>\\n  reflectedLight.indirectDiffuse += indirectLightIntensity * irradiance * BRDF_Diffuse_Lambert( lit );\\n\\n  // modulation\\n  #include <aomap_fragment>\\n\\n  vec3 col = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\\n\\n  #if defined( OUTLINE ) && defined( OUTLINE_COLOR_MIXED ) // omitting DebugMode\\n    gl_FragColor = vec4(\\n      outlineColor.rgb * mix( vec3( 1.0 ), col, outlineLightingMix ),\\n      diffuseColor.a\\n    );\\n    postCorrection();\\n    return;\\n  #endif\\n\\n  // -- MToon: parametric rim lighting -----------------------------------------\\n  vec3 viewDir = normalize( vViewPosition );\\n  vec3 rimMix = mix(vec3(1.0), lighting + indirectLightIntensity * irradiance, rimLightingMix);\\n  vec3 rim = rimColor * pow( saturate( 1.0 - dot( viewDir, normal ) + rimLift ), rimFresnelPower );\\n  #ifdef USE_RIMTEXTURE\\n    rim *= texture2D( rimTexture, uv ).rgb;\\n  #endif\\n  col += rim;\\n\\n  // -- MToon: additive matcap -------------------------------------------------\\n  #ifdef USE_SPHEREADD\\n    {\\n      vec3 x = normalize( vec3( viewDir.z, 0.0, -viewDir.x ) );\\n      vec3 y = cross( viewDir, x ); // guaranteed to be normalized\\n      vec2 sphereUv = 0.5 + 0.5 * vec2( dot( x, normal ), -dot( y, normal ) );\\n      vec3 matcap = sphereAddTexelToLinear( texture2D( sphereAdd, sphereUv ) ).xyz;\\n      col += matcap;\\n    }\\n  #endif\\n\\n  // -- MToon: Emission --------------------------------------------------------\\n  col += totalEmissiveRadiance;\\n\\n  // #include <envmap_fragment>\\n\\n  // -- Almost done! -----------------------------------------------------------\\n  gl_FragColor = vec4( col, diffuseColor.a );\\n  postCorrection();\\n}\";\n    /***/\n  },\n\n  /***/\n  \"./src/vrm/material/shaders/mtoon.vert\":\n  /*!*********************************************!*\\\r\n    !*** ./src/vrm/material/shaders/mtoon.vert ***!\r\n    \\*********************************************/\n\n  /*! exports provided: default */\n\n  /***/\n  function (module, __webpack_exports__, __webpack_require__) {\n    \"use strict\";\n\n    __webpack_require__.r(__webpack_exports__);\n    /* harmony default export */\n\n\n    __webpack_exports__[\"default\"] = \"// #define PHONG\\n\\nvarying vec3 vViewPosition;\\n\\n#ifndef FLAT_SHADED\\n  varying vec3 vNormal;\\n#endif\\n\\n#include <common>\\n\\n// #include <uv_pars_vertex>\\n#if defined( USE_MAP ) || defined( USE_SHADETEXTURE ) || defined( USE_NORMALMAP ) || defined( USE_RECEIVESHADOWTEXTURE ) || defined( USE_SHADINGGRADETEXTURE ) || defined( USE_RIMTEXTURE ) || defined( USE_EMISSIVEMAP ) || defined( USE_OUTLINEWIDTHTEXTURE ) || defined( USE_UVANIMMASKTEXTURE )\\n  varying vec2 vUv;\\n  uniform vec4 mainTex_ST;\\n#endif\\n\\n#include <uv2_pars_vertex>\\n// #include <displacementmap_pars_vertex>\\n// #include <envmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\n\\n#ifdef USE_OUTLINEWIDTHTEXTURE\\n  uniform sampler2D outlineWidthTexture;\\n#endif\\n\\nuniform float outlineWidth;\\nuniform float outlineScaledMaxDistance;\\n\\nvoid main() {\\n\\n  // #include <uv_vertex>\\n  #if defined( USE_MAP ) || defined( USE_SHADETEXTURE ) || defined( USE_NORMALMAP ) || defined( USE_RECEIVESHADOWTEXTURE ) || defined( USE_SHADINGGRADETEXTURE ) || defined( USE_RIMTEXTURE ) || defined( USE_EMISSIVEMAP ) || defined( USE_OUTLINEWIDTHTEXTURE ) || defined( USE_UVANIMMASKTEXTURE )\\n    vUv = vec2( mainTex_ST.p * uv.x + mainTex_ST.s, mainTex_ST.q * uv.y + mainTex_ST.t );\\n  #endif\\n\\n  #include <uv2_vertex>\\n  #include <color_vertex>\\n\\n  #include <beginnormal_vertex>\\n  #include <morphnormal_vertex>\\n  #include <skinbase_vertex>\\n  #include <skinnormal_vertex>\\n  #include <defaultnormal_vertex>\\n\\n  #ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED\\n    vNormal = normalize( transformedNormal );\\n  #endif\\n\\n  #include <begin_vertex>\\n\\n  #include <morphtarget_vertex>\\n  #include <skinning_vertex>\\n  // #include <displacementmap_vertex>\\n  #include <project_vertex>\\n  #include <logdepthbuf_vertex>\\n  #include <clipping_planes_vertex>\\n\\n  vViewPosition = - mvPosition.xyz;\\n\\n  float outlineTex = 1.0;\\n\\n  #ifdef OUTLINE\\n    #ifdef USE_OUTLINEWIDTHTEXTURE\\n      outlineTex = texture2D( outlineWidthTexture, vUv ).r;\\n    #endif\\n\\n    #ifdef OUTLINE_WIDTH_WORLD\\n      vec3 outlineOffset = 0.01 * outlineWidth * outlineTex * normalize( objectNormal );\\n      gl_Position += projectionMatrix * modelViewMatrix * vec4( outlineOffset, 0.0 );\\n    #endif\\n\\n    #ifdef OUTLINE_WIDTH_SCREEN\\n      vec3 clipNormal = ( projectionMatrix * modelViewMatrix * vec4( normalize( objectNormal ), 0.0 ) ).xyz;\\n      vec2 projectedNormal = normalize( clipNormal.xy );\\n      projectedNormal *= min( gl_Position.w, outlineScaledMaxDistance );\\n      projectedNormal.x *= projectionMatrix[ 0 ].x / projectionMatrix[ 1 ].y;\\n      gl_Position.xy += 0.01 * outlineWidth * outlineTex * projectedNormal.xy;\\n    #endif\\n\\n    gl_Position.z += 1E-6 * gl_Position.w; // anti-artifact magic\\n  #endif\\n\\n  #include <worldpos_vertex>\\n  // #include <envmap_vertex>\\n  #include <shadowmap_vertex>\\n  #include <fog_vertex>\\n\\n}\";\n    /***/\n  },\n\n  /***/\n  \"./src/vrm/material/shaders/unlit.frag\":\n  /*!*********************************************!*\\\r\n    !*** ./src/vrm/material/shaders/unlit.frag ***!\r\n    \\*********************************************/\n\n  /*! exports provided: default */\n\n  /***/\n  function (module, __webpack_exports__, __webpack_require__) {\n    \"use strict\";\n\n    __webpack_require__.r(__webpack_exports__);\n    /* harmony default export */\n\n\n    __webpack_exports__[\"default\"] = \"#ifdef RENDERTYPE_CUTOUT\\n  uniform float cutoff;\\n#endif\\n\\n#include <common>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n// #include <alphamap_pars_fragment>\\n// #include <aomap_pars_fragment>\\n// #include <lightmap_pars_fragment>\\n// #include <envmap_pars_fragment>\\n#include <fog_pars_fragment>\\n// #include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\n\\n// == main procedure ===========================================================\\nvoid main() {\\n  #include <clipping_planes_fragment>\\n\\n  vec4 diffuseColor = vec4( 1.0 );\\n\\n  #include <logdepthbuf_fragment>\\n\\n  // #include <map_fragment>\\n  #ifdef USE_MAP\\n    diffuseColor *= mapTexelToLinear( texture2D( map, vUv ) );\\n  #endif\\n\\n  #include <color_fragment>\\n  // #include <alphamap_fragment>\\n\\n  // MToon: alpha\\n  // #include <alphatest_fragment>\\n  #ifdef RENDERTYPE_CUTOUT\\n    if ( diffuseColor.a <= cutoff ) { discard; }\\n    diffuseColor.a = 1.0;\\n  #endif\\n\\n  #ifdef RENDERTYPE_OPAQUE\\n    diffuseColor.a = 1.0;\\n  #endif\\n\\n  // #include <specularmap_fragment>\\n\\n  ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\n  // accumulation (baked indirect lighting only)\\n  #ifdef USE_LIGHTMAP\\n    reflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\\n  #else\\n    reflectedLight.indirectDiffuse += vec3( 1.0 );\\n  #endif\\n\\n  // modulation\\n  // #include <aomap_fragment>\\n\\n  reflectedLight.indirectDiffuse *= diffuseColor.rgb;\\n  vec3 outgoingLight = reflectedLight.indirectDiffuse;\\n\\n  // #include <envmap_fragment>\\n\\n  gl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\n  #include <premultiplied_alpha_fragment>\\n  #include <tonemapping_fragment>\\n  #include <encodings_fragment>\\n  #include <fog_fragment>\\n}\";\n    /***/\n  },\n\n  /***/\n  \"./src/vrm/material/shaders/unlit.vert\":\n  /*!*********************************************!*\\\r\n    !*** ./src/vrm/material/shaders/unlit.vert ***!\r\n    \\*********************************************/\n\n  /*! exports provided: default */\n\n  /***/\n  function (module, __webpack_exports__, __webpack_require__) {\n    \"use strict\";\n\n    __webpack_require__.r(__webpack_exports__);\n    /* harmony default export */\n\n\n    __webpack_exports__[\"default\"] = \"#include <common>\\n\\n// #include <uv_pars_vertex>\\n#ifdef USE_MAP\\n  varying vec2 vUv;\\n  uniform vec4 mainTex_ST;\\n#endif\\n\\n#include <uv2_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\n\\nvoid main() {\\n\\n  // #include <uv_vertex>\\n  #ifdef USE_MAP\\n    vUv = vec2( mainTex_ST.p * uv.x + mainTex_ST.s, mainTex_ST.q * uv.y + mainTex_ST.t );\\n  #endif\\n\\n  #include <uv2_vertex>\\n  #include <color_vertex>\\n  #include <skinbase_vertex>\\n\\n  #ifdef USE_ENVMAP\\n\\n  #include <beginnormal_vertex>\\n  #include <morphnormal_vertex>\\n  #include <skinnormal_vertex>\\n  #include <defaultnormal_vertex>\\n\\n  #endif\\n\\n  #include <begin_vertex>\\n  #include <morphtarget_vertex>\\n  #include <skinning_vertex>\\n  #include <project_vertex>\\n  #include <logdepthbuf_vertex>\\n\\n  #include <worldpos_vertex>\\n  #include <clipping_planes_vertex>\\n  #include <envmap_vertex>\\n  #include <fog_vertex>\\n\\n}\";\n    /***/\n  },\n\n  /***/\n  \"./src/vrm/reduceBones.ts\":\n  /*!********************************!*\\\r\n    !*** ./src/vrm/reduceBones.ts ***!\r\n    \\********************************/\n\n  /*! no static exports found */\n\n  /***/\n  function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n\n    var THREE = __webpack_require__(\n    /*! three */\n    \"three\");\n\n    function reduceBones(root) {\n      root.traverse(function (obj) {\n        if (obj.type !== 'SkinnedMesh') {\n          return;\n        }\n\n        var mesh = obj;\n        var geometry = mesh.geometry.clone();\n        mesh.geometry = geometry;\n        var attribute = geometry.getAttribute('skinIndex');\n        var bones = [];\n        var boneInverses = [];\n        var boneIndexMap = {};\n        var array = attribute.array.map(function (index) {\n          if (boneIndexMap[index] === undefined) {\n            boneIndexMap[index] = bones.length;\n            bones.push(mesh.skeleton.bones[index]);\n            boneInverses.push(mesh.skeleton.boneInverses[index]);\n          }\n\n          return boneIndexMap[index];\n        });\n        geometry.removeAttribute('skinIndex');\n        geometry.addAttribute('skinIndex', new THREE.BufferAttribute(array, 4, false));\n        mesh.bind(new THREE.Skeleton(bones, boneInverses), new THREE.Matrix4());\n      });\n    }\n\n    exports.reduceBones = reduceBones;\n    /***/\n  },\n\n  /***/\n  \"./src/vrm/springbone/VRMSpringBone.ts\":\n  /*!*********************************************!*\\\r\n    !*** ./src/vrm/springbone/VRMSpringBone.ts ***!\r\n    \\*********************************************/\n\n  /*! no static exports found */\n\n  /***/\n  function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n\n    var THREE = __webpack_require__(\n    /*! three */\n    \"three\");\n\n    var math_1 = __webpack_require__(\n    /*! ../utils/math */\n    \"./src/vrm/utils/math.ts\");\n\n    exports.GIZMO_RENDER_ORDER = 10000;\n    var IDENTITY_MATRIX4 = Object.freeze(new THREE.Matrix4());\n    var IDENTITY_QUATERNION = Object.freeze(new THREE.Quaternion());\n\n    var _v3A = new THREE.Vector3();\n\n    var _v3B = new THREE.Vector3();\n\n    var _v3C = new THREE.Vector3();\n\n    var _quatA = new THREE.Quaternion();\n\n    var _matA = new THREE.Matrix4();\n\n    var _matB = new THREE.Matrix4();\n\n    var VRMSpringBone = function () {\n      function VRMSpringBone(bone, radius, stiffiness, gravityDir, gravityPower, dragForce, colliders) {\n        var _this = this;\n\n        if (colliders === void 0) {\n          colliders = [];\n        }\n\n        this.bone = bone;\n        this.bone.matrixAutoUpdate = false;\n        this.radius = radius;\n        this.stiffnessForce = stiffiness;\n        this.gravityDir = gravityDir;\n        this.gravityPower = gravityPower;\n        this.dragForce = dragForce;\n        this.colliders = colliders;\n        this._worldPosition = new THREE.Vector3().setFromMatrixPosition(this.bone.matrixWorld);\n        this._parentWorldRotation = new THREE.Quaternion();\n        this._initialLocalMatrix = this.bone.matrix.clone();\n        this._initialLocalRotation = this.bone.quaternion.clone();\n\n        this._initialLocalChildPosition = function () {\n          if (_this.bone.children.length === 0) {\n            return _this.bone.position.clone().normalize().multiplyScalar(0.07);\n          } else {\n            var firstChild = _this.bone.children[0];\n            return firstChild.position.clone();\n          }\n        }();\n\n        this._currentTail = this.bone.localToWorld(this._initialLocalChildPosition.clone());\n        this._prevTail = this._currentTail.clone();\n        this._nextTail = this._currentTail.clone();\n        this._boneAxis = this._initialLocalChildPosition.clone().normalize();\n        this._worldBoneLength = this.bone.localToWorld(_v3A.copy(this._initialLocalChildPosition)).sub(this._worldPosition).length();\n      }\n\n      VRMSpringBone.prototype.reset = function () {\n        this.bone.matrix.copy(this._initialLocalMatrix);\n        this.bone.localToWorld(this._currentTail.copy(this._initialLocalChildPosition));\n\n        this._prevTail.copy(this._currentTail);\n\n        this._nextTail.copy(this._currentTail);\n\n        this.bone.updateMatrix();\n        this.bone.matrixWorld.multiplyMatrices(this._getParentMatrixWorld(), this.bone.matrix);\n\n        this._worldPosition.setFromMatrixPosition(this.bone.matrixWorld);\n      };\n\n      VRMSpringBone.prototype.update = function (delta) {\n        if (delta <= 0) return;\n        this.bone.matrixWorld.multiplyMatrices(this._getParentMatrixWorld(), this.bone.matrix);\n\n        if (this.bone.parent) {\n          math_1.getWorldQuaternionLite(this.bone.parent, this._parentWorldRotation);\n        } else {\n          this._parentWorldRotation.copy(IDENTITY_QUATERNION);\n        }\n\n        this._worldPosition.setFromMatrixPosition(this.bone.matrixWorld);\n\n        var stiffness = this.stiffnessForce * delta;\n\n        var external = _v3B.copy(this.gravityDir).multiplyScalar(this.gravityPower * delta);\n\n        this._nextTail.copy(this._currentTail).add(_v3A.copy(this._currentTail).sub(this._prevTail).multiplyScalar(1 - this.dragForce)).add(_v3A.copy(this._boneAxis).applyMatrix4(this._initialLocalMatrix).applyMatrix4(this._getParentMatrixWorld()).sub(this._worldPosition).normalize().multiplyScalar(stiffness)).add(external);\n\n        this._nextTail.sub(this._worldPosition).normalize().multiplyScalar(this._worldBoneLength).add(this._worldPosition);\n\n        this._collision(this._nextTail);\n\n        this._prevTail.copy(this._currentTail);\n\n        this._currentTail.copy(this._nextTail);\n\n        var initialWorldMatrixInv = _matA.getInverse(_matB.copy(this._getParentMatrixWorld()).multiply(this._initialLocalMatrix));\n\n        var applyRotation = _quatA.setFromUnitVectors(this._boneAxis, _v3A.copy(this._nextTail).applyMatrix4(initialWorldMatrixInv).normalize());\n\n        this.bone.quaternion.copy(this._initialLocalRotation).multiply(applyRotation);\n        this.bone.updateMatrix();\n        this.bone.matrixWorld.multiplyMatrices(this._getParentMatrixWorld(), this.bone.matrix);\n      };\n\n      VRMSpringBone.prototype._collision = function (tail) {\n        var _this = this;\n\n        this.colliders.forEach(function (collider) {\n          var colliderWorldPosition = _v3A.setFromMatrixPosition(collider.matrixWorld);\n\n          var colliderRadius = collider.geometry.boundingSphere.radius;\n          var r = _this.radius + colliderRadius;\n\n          if (tail.distanceToSquared(colliderWorldPosition) <= r * r) {\n            var normal = _v3B.subVectors(tail, colliderWorldPosition).normalize();\n\n            var posFromCollider = _v3C.addVectors(colliderWorldPosition, normal.multiplyScalar(r));\n\n            tail.copy(posFromCollider.sub(_this._worldPosition).normalize().multiplyScalar(_this._worldBoneLength).add(_this._worldPosition));\n          }\n        });\n      };\n\n      VRMSpringBone.prototype._getParentMatrixWorld = function () {\n        return this.bone.parent ? this.bone.parent.matrixWorld : IDENTITY_MATRIX4;\n      };\n\n      return VRMSpringBone;\n    }();\n\n    exports.VRMSpringBone = VRMSpringBone;\n    /***/\n  },\n\n  /***/\n  \"./src/vrm/springbone/VRMSpringBoneColliderGroup.ts\":\n  /*!**********************************************************!*\\\r\n    !*** ./src/vrm/springbone/VRMSpringBoneColliderGroup.ts ***!\r\n    \\**********************************************************/\n\n  /*! no static exports found */\n\n  /***/\n  function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n    /***/\n  },\n\n  /***/\n  \"./src/vrm/springbone/VRMSpringBoneImporter.ts\":\n  /*!*****************************************************!*\\\r\n    !*** ./src/vrm/springbone/VRMSpringBoneImporter.ts ***!\r\n    \\*****************************************************/\n\n  /*! no static exports found */\n\n  /***/\n  function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n      return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) {\n          try {\n            step(generator.next(value));\n          } catch (e) {\n            reject(e);\n          }\n        }\n\n        function rejected(value) {\n          try {\n            step(generator[\"throw\"](value));\n          } catch (e) {\n            reject(e);\n          }\n        }\n\n        function step(result) {\n          result.done ? resolve(result.value) : new P(function (resolve) {\n            resolve(result.value);\n          }).then(fulfilled, rejected);\n        }\n\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n      });\n    };\n\n    var __generator = this && this.__generator || function (thisArg, body) {\n      var _ = {\n        label: 0,\n        sent: function () {\n          if (t[0] & 1) throw t[1];\n          return t[1];\n        },\n        trys: [],\n        ops: []\n      },\n          f,\n          y,\n          t,\n          g;\n      return g = {\n        next: verb(0),\n        \"throw\": verb(1),\n        \"return\": verb(2)\n      }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n        return this;\n      }), g;\n\n      function verb(n) {\n        return function (v) {\n          return step([n, v]);\n        };\n      }\n\n      function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n\n        while (_) try {\n          if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n          if (y = 0, t) op = [op[0] & 2, t.value];\n\n          switch (op[0]) {\n            case 0:\n            case 1:\n              t = op;\n              break;\n\n            case 4:\n              _.label++;\n              return {\n                value: op[1],\n                done: false\n              };\n\n            case 5:\n              _.label++;\n              y = op[1];\n              op = [0];\n              continue;\n\n            case 7:\n              op = _.ops.pop();\n\n              _.trys.pop();\n\n              continue;\n\n            default:\n              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n                _ = 0;\n                continue;\n              }\n\n              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n                _.label = op[1];\n                break;\n              }\n\n              if (op[0] === 6 && _.label < t[1]) {\n                _.label = t[1];\n                t = op;\n                break;\n              }\n\n              if (t && _.label < t[2]) {\n                _.label = t[2];\n\n                _.ops.push(op);\n\n                break;\n              }\n\n              if (t[2]) _.ops.pop();\n\n              _.trys.pop();\n\n              continue;\n          }\n\n          op = body.call(thisArg, _);\n        } catch (e) {\n          op = [6, e];\n          y = 0;\n        } finally {\n          f = t = 0;\n        }\n\n        if (op[0] & 5) throw op[1];\n        return {\n          value: op[0] ? op[1] : void 0,\n          done: true\n        };\n      }\n    };\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n\n    var THREE = __webpack_require__(\n    /*! three */\n    \"three\");\n\n    var VRMSpringBone_1 = __webpack_require__(\n    /*! ./VRMSpringBone */\n    \"./src/vrm/springbone/VRMSpringBone.ts\");\n\n    var VRMSpringBoneManager_1 = __webpack_require__(\n    /*! ./VRMSpringBoneManager */\n    \"./src/vrm/springbone/VRMSpringBoneManager.ts\");\n\n    var VRMSpringBoneImporter = function () {\n      function VRMSpringBoneImporter() {}\n\n      VRMSpringBoneImporter.prototype.import = function (gltf) {\n        return __awaiter(this, void 0, Promise, function () {\n          var colliderGroups, springBoneGroupList;\n          return __generator(this, function (_a) {\n            switch (_a.label) {\n              case 0:\n                if (!gltf.parser.json.extensions || !gltf.parser.json.extensions.VRM || !gltf.parser.json.extensions.VRM.secondaryAnimation) {\n                  return [2, null];\n                }\n\n                return [4, this._getColliderMeshGroups(gltf)];\n\n              case 1:\n                colliderGroups = _a.sent();\n                colliderGroups.forEach(function (group) {\n                  var _a;\n\n                  return (_a = gltf.scene).add.apply(_a, group.colliders);\n                });\n                return [4, this._getSpringBoneGroupList(gltf, colliderGroups)];\n\n              case 2:\n                springBoneGroupList = _a.sent();\n                return [2, new VRMSpringBoneManager_1.VRMSpringBoneManager(springBoneGroupList)];\n            }\n          });\n        });\n      };\n\n      Object.defineProperty(VRMSpringBoneImporter.prototype, \"_isColiderMeshVisible\", {\n        get: function () {\n          return false;\n        },\n        enumerable: true,\n        configurable: true\n      });\n\n      VRMSpringBoneImporter.prototype._createSpringBone = function (gltf, bone, hitRadius, stiffiness, gravityDir, gravityPower, dragForce, colliders) {\n        if (colliders === void 0) {\n          colliders = [];\n        }\n\n        return new VRMSpringBone_1.VRMSpringBone(bone, hitRadius, stiffiness, gravityDir, gravityPower, dragForce, colliders);\n      };\n\n      VRMSpringBoneImporter.prototype._getSpringBoneGroupList = function (gltf, colliderGroups) {\n        return __awaiter(this, void 0, Promise, function () {\n          var springBoneGroups, springBoneGroupList;\n\n          var _this = this;\n\n          return __generator(this, function (_a) {\n            springBoneGroups = gltf.parser.json.extensions.VRM.secondaryAnimation.boneGroups;\n            springBoneGroupList = [];\n            springBoneGroups.forEach(function (vrmBoneGroup) {\n              if (vrmBoneGroup.stiffiness === undefined || vrmBoneGroup.gravityDir === undefined || vrmBoneGroup.gravityDir.x === undefined || vrmBoneGroup.gravityDir.y === undefined || vrmBoneGroup.gravityDir.z === undefined || vrmBoneGroup.gravityPower === undefined || vrmBoneGroup.dragForce === undefined || vrmBoneGroup.hitRadius === undefined || vrmBoneGroup.colliderGroups === undefined || vrmBoneGroup.bones === undefined) {\n                return;\n              }\n\n              var stiffiness = vrmBoneGroup.stiffiness;\n              var gravityDir = new THREE.Vector3(vrmBoneGroup.gravityDir.x, vrmBoneGroup.gravityDir.y, vrmBoneGroup.gravityDir.z);\n              var gravityPower = vrmBoneGroup.gravityPower;\n              var dragForce = vrmBoneGroup.dragForce;\n              var hitRadius = vrmBoneGroup.hitRadius;\n              var colliders = [];\n              vrmBoneGroup.colliderGroups.forEach(function (colliderIndex) {\n                colliders.push.apply(colliders, colliderGroups[colliderIndex].colliders);\n              });\n              var springBoneGroup = [];\n              vrmBoneGroup.bones.forEach(function (nodeIndex) {\n                return __awaiter(_this, void 0, void 0, function () {\n                  var springRootBone;\n\n                  var _this = this;\n\n                  return __generator(this, function (_a) {\n                    switch (_a.label) {\n                      case 0:\n                        return [4, gltf.parser.getDependency('node', nodeIndex)];\n\n                      case 1:\n                        springRootBone = _a.sent();\n\n                        if (!springRootBone) {\n                          return [2];\n                        }\n\n                        springRootBone.traverse(function (bone) {\n                          var springBone = _this._createSpringBone(gltf, bone, hitRadius, stiffiness, gravityDir, gravityPower, dragForce, colliders);\n\n                          springBoneGroup.push(springBone);\n                        });\n                        return [2];\n                    }\n                  });\n                });\n              });\n              springBoneGroupList.push(springBoneGroup);\n            });\n            return [2, springBoneGroupList];\n          });\n        });\n      };\n\n      VRMSpringBoneImporter.prototype._getColliderMeshGroups = function (gltf) {\n        return __awaiter(this, void 0, Promise, function () {\n          var vrmExt, secondaryAnimation, vrmColliderGroups, colliderGroups;\n\n          var _this = this;\n\n          return __generator(this, function (_a) {\n            vrmExt = gltf.parser.json.extensions && gltf.parser.json.extensions.VRM;\n\n            if (vrmExt === undefined) {\n              return [2, []];\n            }\n\n            secondaryAnimation = vrmExt.secondaryAnimation;\n\n            if (secondaryAnimation === undefined) {\n              return [2, []];\n            }\n\n            vrmColliderGroups = secondaryAnimation.colliderGroups;\n\n            if (vrmColliderGroups === undefined) {\n              return [2, []];\n            }\n\n            colliderGroups = [];\n            vrmColliderGroups.forEach(function (colliderGroup) {\n              return __awaiter(_this, void 0, void 0, function () {\n                var bone, colliders, colliderMeshGroup;\n\n                var _this = this;\n\n                return __generator(this, function (_a) {\n                  switch (_a.label) {\n                    case 0:\n                      if (colliderGroup.node === undefined || colliderGroup.colliders === undefined) {\n                        return [2];\n                      }\n\n                      return [4, gltf.parser.getDependency('node', colliderGroup.node)];\n\n                    case 1:\n                      bone = _a.sent();\n                      colliders = [];\n                      colliderGroup.colliders.forEach(function (collider) {\n                        if (collider.offset === undefined || collider.offset.x === undefined || collider.offset.y === undefined || collider.offset.z === undefined || collider.radius === undefined) {\n                          return;\n                        }\n\n                        var offsetMatrix = new THREE.Matrix4().makeTranslation(collider.offset.x, collider.offset.y, -collider.offset.z);\n                        var visible = _this._isColiderMeshVisible;\n                        var colliderMesh = new THREE.Mesh(new THREE.SphereBufferGeometry(collider.radius, 8, 4), new THREE.MeshBasicMaterial({\n                          color: 0xff00ff,\n                          visible: visible,\n                          wireframe: true,\n                          transparent: true,\n                          depthTest: false\n                        }));\n                        colliderMesh.material.renderOrder = VRMSpringBone_1.GIZMO_RENDER_ORDER;\n                        colliderMesh.name = 'vrmColliderSphere';\n                        colliderMesh.geometry.computeBoundingSphere();\n\n                        colliderMesh.updateMatrixWorld = function () {\n                          colliderMesh.matrixWorld.copy(bone.matrixWorld).multiply(offsetMatrix);\n                        };\n\n                        colliders.push(colliderMesh);\n                      });\n                      colliderMeshGroup = {\n                        node: colliderGroup.node,\n                        colliders: colliders\n                      };\n                      colliderGroups.push(colliderMeshGroup);\n                      return [2];\n                  }\n                });\n              });\n            });\n            return [2, colliderGroups];\n          });\n        });\n      };\n\n      return VRMSpringBoneImporter;\n    }();\n\n    exports.VRMSpringBoneImporter = VRMSpringBoneImporter;\n    /***/\n  },\n\n  /***/\n  \"./src/vrm/springbone/VRMSpringBoneManager.ts\":\n  /*!****************************************************!*\\\r\n    !*** ./src/vrm/springbone/VRMSpringBoneManager.ts ***!\r\n    \\****************************************************/\n\n  /*! no static exports found */\n\n  /***/\n  function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n\n    var VRMSpringBoneManager = function () {\n      function VRMSpringBoneManager(springBoneGroupList) {\n        this.springBoneGroupList = [];\n        this.springBoneGroupList = springBoneGroupList;\n      }\n\n      VRMSpringBoneManager.prototype.lateUpdate = function (delta) {\n        this.springBoneGroupList.forEach(function (springBoneGroup) {\n          springBoneGroup.forEach(function (springBone) {\n            springBone.update(delta);\n          });\n        });\n      };\n\n      VRMSpringBoneManager.prototype.reset = function () {\n        this.springBoneGroupList.forEach(function (springBoneGroup) {\n          springBoneGroup.forEach(function (springBone) {\n            springBone.reset();\n          });\n        });\n      };\n\n      return VRMSpringBoneManager;\n    }();\n\n    exports.VRMSpringBoneManager = VRMSpringBoneManager;\n    /***/\n  },\n\n  /***/\n  \"./src/vrm/springbone/index.ts\":\n  /*!*************************************!*\\\r\n    !*** ./src/vrm/springbone/index.ts ***!\r\n    \\*************************************/\n\n  /*! no static exports found */\n\n  /***/\n  function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    function __export(m) {\n      for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n    }\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n\n    __export(__webpack_require__(\n    /*! ./VRMSpringBone */\n    \"./src/vrm/springbone/VRMSpringBone.ts\"));\n\n    __export(__webpack_require__(\n    /*! ./VRMSpringBoneColliderGroup */\n    \"./src/vrm/springbone/VRMSpringBoneColliderGroup.ts\"));\n\n    __export(__webpack_require__(\n    /*! ./VRMSpringBoneImporter */\n    \"./src/vrm/springbone/VRMSpringBoneImporter.ts\"));\n\n    __export(__webpack_require__(\n    /*! ./VRMSpringBoneManager */\n    \"./src/vrm/springbone/VRMSpringBoneManager.ts\"));\n    /***/\n\n  },\n\n  /***/\n  \"./src/vrm/types/GLTFSchema.ts\":\n  /*!*************************************!*\\\r\n    !*** ./src/vrm/types/GLTFSchema.ts ***!\r\n    \\*************************************/\n\n  /*! no static exports found */\n\n  /***/\n  function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n    /***/\n  },\n\n  /***/\n  \"./src/vrm/types/VRMSchema.ts\":\n  /*!************************************!*\\\r\n    !*** ./src/vrm/types/VRMSchema.ts ***!\r\n    \\************************************/\n\n  /*! no static exports found */\n\n  /***/\n  function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n    var VRMSchema;\n\n    (function (VRMSchema) {\n      var BlendShapePresetName;\n\n      (function (BlendShapePresetName) {\n        BlendShapePresetName[\"A\"] = \"a\";\n        BlendShapePresetName[\"Angry\"] = \"angry\";\n        BlendShapePresetName[\"Blink\"] = \"blink\";\n        BlendShapePresetName[\"BlinkL\"] = \"blink_l\";\n        BlendShapePresetName[\"BlinkR\"] = \"blink_r\";\n        BlendShapePresetName[\"E\"] = \"e\";\n        BlendShapePresetName[\"Fun\"] = \"fun\";\n        BlendShapePresetName[\"I\"] = \"i\";\n        BlendShapePresetName[\"Joy\"] = \"joy\";\n        BlendShapePresetName[\"Lookdown\"] = \"lookdown\";\n        BlendShapePresetName[\"Lookleft\"] = \"lookleft\";\n        BlendShapePresetName[\"Lookright\"] = \"lookright\";\n        BlendShapePresetName[\"Lookup\"] = \"lookup\";\n        BlendShapePresetName[\"Neutral\"] = \"neutral\";\n        BlendShapePresetName[\"O\"] = \"o\";\n        BlendShapePresetName[\"Sorrow\"] = \"sorrow\";\n        BlendShapePresetName[\"U\"] = \"u\";\n        BlendShapePresetName[\"Unknown\"] = \"unknown\";\n      })(BlendShapePresetName = VRMSchema.BlendShapePresetName || (VRMSchema.BlendShapePresetName = {}));\n\n      var FirstPersonLookAtTypeName;\n\n      (function (FirstPersonLookAtTypeName) {\n        FirstPersonLookAtTypeName[\"BlendShape\"] = \"BlendShape\";\n        FirstPersonLookAtTypeName[\"Bone\"] = \"Bone\";\n      })(FirstPersonLookAtTypeName = VRMSchema.FirstPersonLookAtTypeName || (VRMSchema.FirstPersonLookAtTypeName = {}));\n\n      var HumanoidBoneName;\n\n      (function (HumanoidBoneName) {\n        HumanoidBoneName[\"Chest\"] = \"chest\";\n        HumanoidBoneName[\"Head\"] = \"head\";\n        HumanoidBoneName[\"Hips\"] = \"hips\";\n        HumanoidBoneName[\"Jaw\"] = \"jaw\";\n        HumanoidBoneName[\"LeftEye\"] = \"leftEye\";\n        HumanoidBoneName[\"LeftFoot\"] = \"leftFoot\";\n        HumanoidBoneName[\"LeftHand\"] = \"leftHand\";\n        HumanoidBoneName[\"LeftIndexDistal\"] = \"leftIndexDistal\";\n        HumanoidBoneName[\"LeftIndexIntermediate\"] = \"leftIndexIntermediate\";\n        HumanoidBoneName[\"LeftIndexProximal\"] = \"leftIndexProximal\";\n        HumanoidBoneName[\"LeftLittleDistal\"] = \"leftLittleDistal\";\n        HumanoidBoneName[\"LeftLittleIntermediate\"] = \"leftLittleIntermediate\";\n        HumanoidBoneName[\"LeftLittleProximal\"] = \"leftLittleProximal\";\n        HumanoidBoneName[\"LeftLowerArm\"] = \"leftLowerArm\";\n        HumanoidBoneName[\"LeftLowerLeg\"] = \"leftLowerLeg\";\n        HumanoidBoneName[\"LeftMiddleDistal\"] = \"leftMiddleDistal\";\n        HumanoidBoneName[\"LeftMiddleIntermediate\"] = \"leftMiddleIntermediate\";\n        HumanoidBoneName[\"LeftMiddleProximal\"] = \"leftMiddleProximal\";\n        HumanoidBoneName[\"LeftRingDistal\"] = \"leftRingDistal\";\n        HumanoidBoneName[\"LeftRingIntermediate\"] = \"leftRingIntermediate\";\n        HumanoidBoneName[\"LeftRingProximal\"] = \"leftRingProximal\";\n        HumanoidBoneName[\"LeftShoulder\"] = \"leftShoulder\";\n        HumanoidBoneName[\"LeftThumbDistal\"] = \"leftThumbDistal\";\n        HumanoidBoneName[\"LeftThumbIntermediate\"] = \"leftThumbIntermediate\";\n        HumanoidBoneName[\"LeftThumbProximal\"] = \"leftThumbProximal\";\n        HumanoidBoneName[\"LeftToes\"] = \"leftToes\";\n        HumanoidBoneName[\"LeftUpperArm\"] = \"leftUpperArm\";\n        HumanoidBoneName[\"LeftUpperLeg\"] = \"leftUpperLeg\";\n        HumanoidBoneName[\"Neck\"] = \"neck\";\n        HumanoidBoneName[\"RightEye\"] = \"rightEye\";\n        HumanoidBoneName[\"RightFoot\"] = \"rightFoot\";\n        HumanoidBoneName[\"RightHand\"] = \"rightHand\";\n        HumanoidBoneName[\"RightIndexDistal\"] = \"rightIndexDistal\";\n        HumanoidBoneName[\"RightIndexIntermediate\"] = \"rightIndexIntermediate\";\n        HumanoidBoneName[\"RightIndexProximal\"] = \"rightIndexProximal\";\n        HumanoidBoneName[\"RightLittleDistal\"] = \"rightLittleDistal\";\n        HumanoidBoneName[\"RightLittleIntermediate\"] = \"rightLittleIntermediate\";\n        HumanoidBoneName[\"RightLittleProximal\"] = \"rightLittleProximal\";\n        HumanoidBoneName[\"RightLowerArm\"] = \"rightLowerArm\";\n        HumanoidBoneName[\"RightLowerLeg\"] = \"rightLowerLeg\";\n        HumanoidBoneName[\"RightMiddleDistal\"] = \"rightMiddleDistal\";\n        HumanoidBoneName[\"RightMiddleIntermediate\"] = \"rightMiddleIntermediate\";\n        HumanoidBoneName[\"RightMiddleProximal\"] = \"rightMiddleProximal\";\n        HumanoidBoneName[\"RightRingDistal\"] = \"rightRingDistal\";\n        HumanoidBoneName[\"RightRingIntermediate\"] = \"rightRingIntermediate\";\n        HumanoidBoneName[\"RightRingProximal\"] = \"rightRingProximal\";\n        HumanoidBoneName[\"RightShoulder\"] = \"rightShoulder\";\n        HumanoidBoneName[\"RightThumbDistal\"] = \"rightThumbDistal\";\n        HumanoidBoneName[\"RightThumbIntermediate\"] = \"rightThumbIntermediate\";\n        HumanoidBoneName[\"RightThumbProximal\"] = \"rightThumbProximal\";\n        HumanoidBoneName[\"RightToes\"] = \"rightToes\";\n        HumanoidBoneName[\"RightUpperArm\"] = \"rightUpperArm\";\n        HumanoidBoneName[\"RightUpperLeg\"] = \"rightUpperLeg\";\n        HumanoidBoneName[\"Spine\"] = \"spine\";\n        HumanoidBoneName[\"UpperChest\"] = \"upperChest\";\n      })(HumanoidBoneName = VRMSchema.HumanoidBoneName || (VRMSchema.HumanoidBoneName = {}));\n\n      var MetaAllowedUserName;\n\n      (function (MetaAllowedUserName) {\n        MetaAllowedUserName[\"Everyone\"] = \"Everyone\";\n        MetaAllowedUserName[\"ExplicitlyLicensedPerson\"] = \"ExplicitlyLicensedPerson\";\n        MetaAllowedUserName[\"OnlyAuthor\"] = \"OnlyAuthor\";\n      })(MetaAllowedUserName = VRMSchema.MetaAllowedUserName || (VRMSchema.MetaAllowedUserName = {}));\n\n      var MetaUssageName;\n\n      (function (MetaUssageName) {\n        MetaUssageName[\"Allow\"] = \"Allow\";\n        MetaUssageName[\"Disallow\"] = \"Disallow\";\n      })(MetaUssageName = VRMSchema.MetaUssageName || (VRMSchema.MetaUssageName = {}));\n\n      var MetaLicenseName;\n\n      (function (MetaLicenseName) {\n        MetaLicenseName[\"Cc0\"] = \"CC0\";\n        MetaLicenseName[\"CcBy\"] = \"CC_BY\";\n        MetaLicenseName[\"CcByNc\"] = \"CC_BY_NC\";\n        MetaLicenseName[\"CcByNcNd\"] = \"CC_BY_NC_ND\";\n        MetaLicenseName[\"CcByNcSa\"] = \"CC_BY_NC_SA\";\n        MetaLicenseName[\"CcByNd\"] = \"CC_BY_ND\";\n        MetaLicenseName[\"CcBySa\"] = \"CC_BY_SA\";\n        MetaLicenseName[\"Other\"] = \"Other\";\n        MetaLicenseName[\"RedistributionProhibited\"] = \"Redistribution_Prohibited\";\n      })(MetaLicenseName = VRMSchema.MetaLicenseName || (VRMSchema.MetaLicenseName = {}));\n    })(VRMSchema = exports.VRMSchema || (exports.VRMSchema = {}));\n    /***/\n\n  },\n\n  /***/\n  \"./src/vrm/types/index.ts\":\n  /*!********************************!*\\\r\n    !*** ./src/vrm/types/index.ts ***!\r\n    \\********************************/\n\n  /*! no static exports found */\n\n  /***/\n  function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    function __export(m) {\n      for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n    }\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n\n    __export(__webpack_require__(\n    /*! ./GLTFSchema */\n    \"./src/vrm/types/GLTFSchema.ts\"));\n\n    __export(__webpack_require__(\n    /*! ./VRMSchema */\n    \"./src/vrm/types/VRMSchema.ts\"));\n\n    __export(__webpack_require__(\n    /*! ./types */\n    \"./src/vrm/types/types.ts\"));\n    /***/\n\n  },\n\n  /***/\n  \"./src/vrm/types/types.ts\":\n  /*!********************************!*\\\r\n    !*** ./src/vrm/types/types.ts ***!\r\n    \\********************************/\n\n  /*! no static exports found */\n\n  /***/\n  function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n    /***/\n  },\n\n  /***/\n  \"./src/vrm/utils/disposer.ts\":\n  /*!***********************************!*\\\r\n    !*** ./src/vrm/utils/disposer.ts ***!\r\n    \\***********************************/\n\n  /*! no static exports found */\n\n  /***/\n  function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n\n    function disposeMaterial(material) {\n      Object.keys(material).forEach(function (propertyName) {\n        if (!!material[propertyName] && typeof material[propertyName].dispose === 'function') {\n          material[propertyName].dispose();\n        }\n      });\n      material.dispose();\n      material = undefined;\n    }\n\n    function dispose(object3D) {\n      if (object3D.geometry) {\n        object3D.geometry.dispose();\n        object3D.geometry = undefined;\n      }\n\n      if (!!object3D.material && Array.isArray(object3D.material)) {\n        object3D.material.forEach(function (material) {\n          return disposeMaterial(material);\n        });\n      } else if (object3D.material) {\n        disposeMaterial(object3D.material);\n      }\n    }\n\n    function deepDispose(object3D) {\n      object3D.traverse(dispose);\n    }\n\n    exports.deepDispose = deepDispose;\n    /***/\n  },\n\n  /***/\n  \"./src/vrm/utils/math.ts\":\n  /*!*******************************!*\\\r\n    !*** ./src/vrm/utils/math.ts ***!\r\n    \\*******************************/\n\n  /*! no static exports found */\n\n  /***/\n  function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n\n    var THREE = __webpack_require__(\n    /*! three */\n    \"three\");\n\n    function saturate(value) {\n      return Math.max(Math.min(value, 1.0), 0.0);\n    }\n\n    exports.saturate = saturate;\n\n    function linstep(x, min, max) {\n      if (x <= min) return 0;\n      if (x >= max) return 1;\n      return (x - min) / (max - min);\n    }\n\n    exports.linstep = linstep;\n\n    var _position = new THREE.Vector3();\n\n    var _scale = new THREE.Vector3();\n\n    var _rotation = new THREE.Quaternion();\n\n    function getWorldPositionLite(object, out) {\n      object.matrixWorld.decompose(out, _rotation, _scale);\n      return out;\n    }\n\n    exports.getWorldPositionLite = getWorldPositionLite;\n\n    function getWorldScaleLite(object, out) {\n      object.matrixWorld.decompose(_position, _rotation, out);\n      return out;\n    }\n\n    exports.getWorldScaleLite = getWorldScaleLite;\n\n    function getWorldQuaternionLite(object, out) {\n      object.matrixWorld.decompose(_position, out, _scale);\n      return out;\n    }\n\n    exports.getWorldQuaternionLite = getWorldQuaternionLite;\n    /***/\n  },\n\n  /***/\n  \"./src/vrm/utils/renameMaterialProperty.ts\":\n  /*!*************************************************!*\\\r\n    !*** ./src/vrm/utils/renameMaterialProperty.ts ***!\r\n    \\*************************************************/\n\n  /*! no static exports found */\n\n  /***/\n  function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n\n    function renameMaterialProperty(name) {\n      if (name[0] !== '_') {\n        console.warn(\"renameMaterialProperty: Given property name \\\"\" + name + \"\\\" might be invalid\");\n        return name;\n      }\n\n      name = name.substring(1);\n\n      if (!/[A-Z]/.test(name[0])) {\n        console.warn(\"renameMaterialProperty: Given property name \\\"\" + name + \"\\\" might be invalid\");\n        return name;\n      }\n\n      return name[0].toLowerCase() + name.substring(1);\n    }\n\n    exports.renameMaterialProperty = renameMaterialProperty;\n    /***/\n  },\n\n  /***/\n  \"three\":\n  /*!************************!*\\\r\n    !*** external \"THREE\" ***!\r\n    \\************************/\n\n  /*! no static exports found */\n\n  /***/\n  function (module, exports) {\n    module.exports = THREE;\n    /***/\n  }\n  /******/\n\n});","map":{"version":3,"sources":["webpack://__three_vrm__/webpack/bootstrap","webpack://__three_vrm__/src/assign.ts","webpack://__three_vrm__/src/index.ts","webpack://__three_vrm__/src/vrm/VRM.ts","webpack://__three_vrm__/src/vrm/VRMImporter.ts","webpack://__three_vrm__/src/vrm/blendshape/VRMBlendShapeGroup.ts","webpack://__three_vrm__/src/vrm/blendshape/VRMBlendShapeImporter.ts","webpack://__three_vrm__/src/vrm/blendshape/VRMBlendShapeProxy.ts","webpack://__three_vrm__/src/vrm/blendshape/index.ts","webpack://__three_vrm__/src/vrm/debug/VRMDebug.ts","webpack://__three_vrm__/src/vrm/debug/VRMImporterDebug.ts","webpack://__three_vrm__/src/vrm/debug/VRMLookAtHeadDebug.ts","webpack://__three_vrm__/src/vrm/debug/VRMLookAtImporterDebug.ts","webpack://__three_vrm__/src/vrm/debug/VRMSpringBoneDebug.ts","webpack://__three_vrm__/src/vrm/debug/VRMSpringBoneImporterDebug.ts","webpack://__three_vrm__/src/vrm/debug/index.ts","webpack://__three_vrm__/src/vrm/firstperson/VRMFirstPerson.ts","webpack://__three_vrm__/src/vrm/firstperson/VRMFirstPersonImporter.ts","webpack://__three_vrm__/src/vrm/firstperson/index.ts","webpack://__three_vrm__/src/vrm/humanoid/VRMHumanBone.ts","webpack://__three_vrm__/src/vrm/humanoid/VRMHumanoid.ts","webpack://__three_vrm__/src/vrm/humanoid/VRMHumanoidImporter.ts","webpack://__three_vrm__/src/vrm/humanoid/index.ts","webpack://__three_vrm__/src/vrm/index.ts","webpack://__three_vrm__/src/vrm/lookat/CurveMapper.ts","webpack://__three_vrm__/src/vrm/lookat/VRMLookAtApplyer.ts","webpack://__three_vrm__/src/vrm/lookat/VRMLookAtBlendShapeApplyer.ts","webpack://__three_vrm__/src/vrm/lookat/VRMLookAtBoneApplyer.ts","webpack://__three_vrm__/src/vrm/lookat/VRMLookAtHead.ts","webpack://__three_vrm__/src/vrm/lookat/VRMLookAtImporter.ts","webpack://__three_vrm__/src/vrm/lookat/index.ts","webpack://__three_vrm__/src/vrm/material/MToonMaterial.ts","webpack://__three_vrm__/src/vrm/material/VRMMaterialImporter.ts","webpack://__three_vrm__/src/vrm/material/VRMUnlitMaterial.ts","webpack://__three_vrm__/src/vrm/material/getTexelDecodingFunction.ts","webpack://__three_vrm__/src/vrm/material/index.ts","webpack://__three_vrm__/src/vrm/material/shaders/mtoon.frag","webpack://__three_vrm__/src/vrm/material/shaders/mtoon.vert","webpack://__three_vrm__/src/vrm/material/shaders/unlit.frag","webpack://__three_vrm__/src/vrm/material/shaders/unlit.vert","webpack://__three_vrm__/src/vrm/reduceBones.ts","webpack://__three_vrm__/src/vrm/springbone/VRMSpringBone.ts","webpack://__three_vrm__/src/vrm/springbone/VRMSpringBoneImporter.ts","webpack://__three_vrm__/src/vrm/springbone/VRMSpringBoneManager.ts","webpack://__three_vrm__/src/vrm/springbone/index.ts","webpack://__three_vrm__/src/vrm/types/VRMSchema.ts","webpack://__three_vrm__/src/vrm/types/index.ts","webpack://__three_vrm__/src/vrm/utils/disposer.ts","webpack://__three_vrm__/src/vrm/utils/math.ts","webpack://__three_vrm__/src/vrm/utils/renameMaterialProperty.ts","webpack:/__three_vrm__/external \"THREE\""],"names":[],"mappings":"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","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/assign.ts\");\n","/* eslint-disable */\nimport * as __three_vrm__ from '.';\n// @ts-ignore\nObject.assign(THREE, __three_vrm__);\n","export * from './vrm/';\n","import * as THREE from 'three';\nimport { VRMBlendShapeProxy } from './blendshape';\nimport { VRMFirstPerson } from './firstperson';\nimport { VRMHumanoid } from './humanoid';\nimport { VRMLookAtHead } from './lookat';\nimport { VRMSpringBoneManager } from './springbone';\nimport { VRMSchema } from './types';\nimport { deepDispose } from './utils/disposer';\nimport { VRMImporter, VRMImporterOptions } from './VRMImporter';\n\n/**\n * Parameters for a [[VRM]] class.\n */\nexport interface VRMParameters {\n  scene: THREE.Scene;\n  humanoid?: VRMHumanoid;\n  blendShapeProxy?: VRMBlendShapeProxy;\n  firstPerson?: VRMFirstPerson;\n  lookAt?: VRMLookAtHead;\n  materials?: THREE.Material[];\n  springBoneManager?: VRMSpringBoneManager;\n  meta?: VRMSchema.Meta;\n}\n\n/**\n * A class that represents a single VRM model.\n * See the documentation of [[VRM.from]] for the most basic use of VRM.\n */\nexport class VRM {\n  /**\n   * Create a new VRM from a parsed result of GLTF taken from GLTFLoader.\n   * It's probably a thing what you want to get started with VRMs.\n   *\n   * @example Most basic use of VRM\n   * ```\n   * const scene = new THREE.Scene();\n   *\n   * new THREE.GLTFLoader().load( 'models/three-vrm-girl.vrm', ( gltf ) => {\n   *\n   *   THREE.VRM.from( gltf ).then( ( vrm ) => {\n   *\n   *     scene.add( vrm.scene );\n   *\n   *   } );\n   *\n   * } );\n   * ```\n   *\n   * @param gltf A parsed GLTF object taken from GLTFLoader\n   * @param options Options that will be used in importer\n   */\n  public static async from(gltf: THREE.GLTF, options: VRMImporterOptions = {}): Promise<VRM> {\n    const importer = new VRMImporter(options);\n    return await importer.import(gltf);\n  }\n  /**\n   * `THREE.Scene` that contains the entire VRM.\n   */\n  public readonly scene: THREE.Scene;\n\n  /**\n   * Contains [[VRMHumanoid]] of the VRM.\n   * You can control each bones using [[VRMHumanoid.getBoneNode]].\n   *\n   * @TODO Add a link to VRM spec\n   */\n  public readonly humanoid?: VRMHumanoid;\n\n  /**\n   * Contains [[VRMBlendShapeProxy]] of the VRM.\n   * You might want to control these facial expressions via [[VRMBlendShapeProxy.setValue]].\n   */\n  public readonly blendShapeProxy?: VRMBlendShapeProxy;\n\n  /**\n   * Contains [[VRMFirstPerson]] of the VRM.\n   * You can use various feature of the firstPerson field.\n   */\n  public readonly firstPerson?: VRMFirstPerson;\n\n  /**\n   * Contains [[VRMLookAtHead]] of the VRM.\n   * You might want to use [[VRMLookAtHead.target]] to control the eye direction of your VRMs.\n   */\n  public readonly lookAt?: VRMLookAtHead;\n\n  /**\n   * Contains materials of the VRM.\n   * `updateVRMMaterials` method of these materials will be called via its [[VRM.update]] method.\n   */\n  public readonly materials?: THREE.Material[];\n\n  /**\n   * Contains meta fields of the VRM.\n   * You might want to refer these license fields before use your VRMs.\n   */\n  public readonly meta?: VRMSchema.Meta;\n\n  /**\n   * A [[VRMSpringBoneManager]] manipulates all spring bones attached on the VRM.\n   * Usually you don't have to care about this property.\n   */\n  public readonly springBoneManager?: VRMSpringBoneManager;\n\n  /**\n   * Create a new VRM instance.\n   *\n   * @param params [[VRMParameters]] that represents components of the VRM\n   */\n  public constructor(params: VRMParameters) {\n    this.scene = params.scene;\n    this.humanoid = params.humanoid;\n    this.blendShapeProxy = params.blendShapeProxy;\n    this.firstPerson = params.firstPerson;\n    this.lookAt = params.lookAt;\n    this.materials = params.materials;\n    this.springBoneManager = params.springBoneManager;\n    this.meta = params.meta;\n  }\n\n  /**\n   * **You need to call this on your update loop.**\n   *\n   * This function updates every VRM components.\n   *\n   * @param delta deltaTime\n   */\n  public update(delta: number): void {\n    if (this.lookAt) {\n      this.lookAt.update(delta);\n    }\n\n    if (this.blendShapeProxy) {\n      this.blendShapeProxy.update();\n    }\n\n    if (this.springBoneManager) {\n      this.springBoneManager.lateUpdate(delta);\n    }\n\n    if (this.materials) {\n      this.materials.forEach((material: any) => {\n        if (material.updateVRMMaterials) {\n          material.updateVRMMaterials(delta);\n        }\n      });\n    }\n  }\n\n  /**\n   * Dispose everything about the VRM instance.\n   */\n  public dispose(): void {\n    const scene = this.scene;\n    if (scene) {\n      while (scene.children.length > 0) {\n        const object = scene.children[scene.children.length - 1];\n        deepDispose(object);\n        scene.remove(object);\n      }\n    }\n  }\n}\n","import * as THREE from 'three';\nimport { VRMBlendShapeImporter } from './blendshape';\nimport { VRMFirstPersonImporter } from './firstperson';\nimport { VRMHumanoidImporter } from './humanoid/VRMHumanoidImporter';\nimport { VRMLookAtImporter } from './lookat/VRMLookAtImporter';\nimport { VRMMaterialImporter } from './material';\nimport { reduceBones } from './reduceBones';\nimport { VRMSpringBoneImporter } from './springbone/VRMSpringBoneImporter';\nimport { VRMSchema } from './types';\nimport { VRM } from './VRM';\n\nexport interface VRMImporterOptions {\n  lookAtImporter?: VRMLookAtImporter;\n  humanoidImporter?: VRMHumanoidImporter;\n  blendShapeImporter?: VRMBlendShapeImporter;\n  firstPersonImporter?: VRMFirstPersonImporter;\n  materialImporter?: VRMMaterialImporter;\n  springBoneImporter?: VRMSpringBoneImporter;\n}\n\n/**\n * An importer that imports a [[VRM]] from a VRM extension of a GLTF.\n */\nexport class VRMImporter {\n  protected readonly _blendShapeImporter: VRMBlendShapeImporter;\n  protected readonly _lookAtImporter: VRMLookAtImporter;\n  protected readonly _humanoidImporter: VRMHumanoidImporter;\n  protected readonly _firstPersonImporter: VRMFirstPersonImporter;\n  protected readonly _materialImporter: VRMMaterialImporter;\n  protected readonly _springBoneImporter: VRMSpringBoneImporter;\n\n  /**\n   * Create a new VRMImporter.\n   *\n   * @param options [[VRMImporterOptions]], optionally contains importers for each component\n   */\n  public constructor(options: VRMImporterOptions = {}) {\n    this._blendShapeImporter = options.blendShapeImporter || new VRMBlendShapeImporter();\n    this._lookAtImporter = options.lookAtImporter || new VRMLookAtImporter();\n    this._humanoidImporter = options.humanoidImporter || new VRMHumanoidImporter();\n    this._firstPersonImporter = options.firstPersonImporter || new VRMFirstPersonImporter();\n    this._materialImporter = options.materialImporter || new VRMMaterialImporter();\n    this._springBoneImporter = options.springBoneImporter || new VRMSpringBoneImporter();\n  }\n\n  /**\n   * Receive a GLTF object retrieved from `THREE.GLTFLoader` and create a new [[VRM]] instance.\n   *\n   * @param gltf A parsed result of GLTF taken from GLTFLoader\n   */\n  public async import(gltf: THREE.GLTF): Promise<VRM> {\n    if (gltf.parser.json.extensions === undefined || gltf.parser.json.extensions.VRM === undefined) {\n      throw new Error('Could not find VRM extension on the GLTF');\n    }\n    const vrmExt: VRMSchema.VRM = gltf.parser.json.extensions.VRM;\n\n    const scene = gltf.scene;\n\n    scene.updateMatrixWorld(false);\n\n    // Skinned object should not be frustumCulled\n    // Since pre-skinned position might be outside of view\n    scene.traverse((object3d) => {\n      if ((object3d as any).isMesh) {\n        object3d.frustumCulled = false;\n      }\n    });\n\n    reduceBones(scene);\n\n    const materials = (await this._materialImporter.convertGLTFMaterials(gltf)) || undefined;\n\n    const humanoid = (await this._humanoidImporter.import(gltf)) || undefined;\n\n    const firstPerson = humanoid ? (await this._firstPersonImporter.import(gltf, humanoid)) || undefined : undefined;\n\n    const blendShapeProxy = (await this._blendShapeImporter.import(gltf)) || undefined;\n\n    const lookAt =\n      firstPerson && blendShapeProxy && humanoid\n        ? (await this._lookAtImporter.import(gltf, firstPerson, blendShapeProxy, humanoid)) || undefined\n        : undefined;\n\n    const springBoneManager = (await this._springBoneImporter.import(gltf)) || undefined;\n\n    return new VRM({\n      scene: gltf.scene,\n      meta: vrmExt.meta,\n      materials,\n      humanoid,\n      firstPerson,\n      blendShapeProxy,\n      lookAt,\n      springBoneManager,\n    });\n  }\n}\n","import * as THREE from 'three';\nimport { GLTFPrimitive } from '../types';\n\nexport interface VRMBlendShapeBind {\n  meshes: GLTFPrimitive[];\n  morphTargetIndex: number;\n  weight: number;\n}\n\nenum VRMBlendShapeMaterialValueType {\n  NUMBER,\n  VECTOR2,\n  VECTOR3,\n  VECTOR4,\n  COLOR,\n}\n\nexport interface VRMBlendShapeMaterialValue {\n  material: THREE.Material;\n  propertyName: string;\n  defaultValue: number | THREE.Vector2 | THREE.Vector3 | THREE.Vector4 | THREE.Color;\n  targetValue: number | THREE.Vector2 | THREE.Vector3 | THREE.Vector4 | THREE.Color;\n  deltaValue: number | THREE.Vector2 | THREE.Vector3 | THREE.Vector4 | THREE.Color; // targetValue - defaultValue\n  type: VRMBlendShapeMaterialValueType;\n}\n\nconst _v2 = new THREE.Vector2();\nconst _v3 = new THREE.Vector3();\nconst _v4 = new THREE.Vector4();\nconst _color = new THREE.Color();\n\n// animationMixer Scene \n// Object3D  Scene \nexport class VRMBlendShapeGroup extends THREE.Object3D {\n  public weight = 0.0;\n  public isBinary = false;\n\n  private _binds: VRMBlendShapeBind[] = [];\n  private _materialValues: VRMBlendShapeMaterialValue[] = [];\n\n  constructor(expressionName: string) {\n    super();\n    this.name = `BlendShapeController_${expressionName}`;\n\n    // traverse  Object3D \n    this.type = 'BlendShapeController';\n    //  visible  false \n    //  matrix \n    this.visible = false;\n  }\n\n  public addBind(args: { meshes: GLTFPrimitive[]; morphTargetIndex: number; weight: number }): void {\n    // original weight is 0-100 but we want to deal with this value within 0-1\n    const weight = args.weight / 100;\n\n    this._binds.push({\n      meshes: args.meshes,\n      morphTargetIndex: args.morphTargetIndex,\n      weight,\n    });\n  }\n\n  public addMaterialValue(args: {\n    material: THREE.Material;\n    propertyName: string;\n    targetValue: number[];\n    defaultValue?: number | THREE.Vector2 | THREE.Vector3 | THREE.Vector4 | THREE.Color;\n  }): void {\n    const material = args.material;\n    const propertyName = args.propertyName;\n\n    let value = (material as any)[propertyName];\n    if (!value) {\n      // property has not been found\n      return;\n    }\n    value = args.defaultValue || value;\n\n    let type: VRMBlendShapeMaterialValueType;\n    let defaultValue: number | THREE.Vector2 | THREE.Vector3 | THREE.Vector4 | THREE.Color;\n    let targetValue: number | THREE.Vector2 | THREE.Vector3 | THREE.Vector4 | THREE.Color;\n    let deltaValue: number | THREE.Vector2 | THREE.Vector3 | THREE.Vector4 | THREE.Color;\n\n    if ((value as any).isVector2) {\n      type = VRMBlendShapeMaterialValueType.VECTOR2;\n      defaultValue = (value as THREE.Vector2).clone();\n      targetValue = new THREE.Vector2().fromArray(args.targetValue);\n      deltaValue = targetValue.clone().sub(defaultValue);\n    } else if ((value as any).isVector3) {\n      type = VRMBlendShapeMaterialValueType.VECTOR3;\n      defaultValue = (value as THREE.Vector3).clone();\n      targetValue = new THREE.Vector3().fromArray(args.targetValue);\n      deltaValue = targetValue.clone().sub(defaultValue);\n    } else if ((value as any).isVector4) {\n      type = VRMBlendShapeMaterialValueType.VECTOR4;\n      defaultValue = (value as THREE.Vector4).clone();\n\n      // vectorProperty and targetValue index is different from each other\n      // exported vrm by UniVRM file is\n      //\n      // vectorProperty\n      // offset = targetValue[0], targetValue[1]\n      // tiling = targetValue[2], targetValue[3]\n      //\n      // targetValue\n      // offset = targetValue[2], targetValue[3]\n      // tiling = targetValue[0], targetValue[1]\n      targetValue = new THREE.Vector4().fromArray([\n        args.targetValue[2],\n        args.targetValue[3],\n        args.targetValue[0],\n        args.targetValue[1],\n      ]);\n      deltaValue = targetValue.clone().sub(defaultValue);\n    } else if ((value as any).isColor) {\n      type = VRMBlendShapeMaterialValueType.COLOR;\n      defaultValue = (value as THREE.Color).clone();\n      targetValue = new THREE.Color().fromArray(args.targetValue);\n      deltaValue = targetValue.clone().sub(defaultValue);\n    } else {\n      type = VRMBlendShapeMaterialValueType.NUMBER;\n      defaultValue = value as number;\n      targetValue = args.targetValue[0];\n      deltaValue = targetValue - defaultValue;\n    }\n\n    this._materialValues.push({\n      material,\n      propertyName,\n      defaultValue,\n      targetValue,\n      deltaValue,\n      type,\n    });\n  }\n\n  /**\n   * Apply weight to every assigned blend shapes.\n   * Should be called via {@link BlendShapeMaster#update}.\n   */\n  public applyWeight(): void {\n    const w = this.isBinary ? (this.weight < 0.5 ? 0.0 : 1.0) : this.weight;\n\n    this._binds.forEach((bind) => {\n      bind.meshes.forEach((mesh) => {\n        if (!mesh.morphTargetInfluences) {\n          return;\n        } // TODO: we should kick this at `addBind`\n        mesh.morphTargetInfluences[bind.morphTargetIndex] += w * bind.weight;\n      });\n    });\n\n    this._materialValues.forEach((materialValue) => {\n      const prop = (materialValue.material as any)[materialValue.propertyName];\n      if (prop === undefined) {\n        return;\n      } // TODO: we should kick this at `addMaterialValue`\n\n      if (materialValue.type === VRMBlendShapeMaterialValueType.NUMBER) {\n        const deltaValue = materialValue.deltaValue as number;\n        (materialValue.material as any)[materialValue.propertyName] += deltaValue * w;\n      } else if (materialValue.type === VRMBlendShapeMaterialValueType.VECTOR2) {\n        const deltaValue = materialValue.deltaValue as THREE.Vector2;\n        (materialValue.material as any)[materialValue.propertyName].add(_v2.copy(deltaValue).multiplyScalar(w));\n      } else if (materialValue.type === VRMBlendShapeMaterialValueType.VECTOR3) {\n        const deltaValue = materialValue.deltaValue as THREE.Vector3;\n        (materialValue.material as any)[materialValue.propertyName].add(_v3.copy(deltaValue).multiplyScalar(w));\n      } else if (materialValue.type === VRMBlendShapeMaterialValueType.VECTOR4) {\n        const deltaValue = materialValue.deltaValue as THREE.Vector4;\n        (materialValue.material as any)[materialValue.propertyName].add(_v4.copy(deltaValue).multiplyScalar(w));\n      } else if (materialValue.type === VRMBlendShapeMaterialValueType.COLOR) {\n        const deltaValue = materialValue.deltaValue as THREE.Color;\n        (materialValue.material as any)[materialValue.propertyName].add(_color.copy(deltaValue).multiplyScalar(w));\n      }\n\n      if (typeof (materialValue.material as any).shouldApplyUniforms === 'boolean') {\n        (materialValue.material as any).shouldApplyUniforms = true;\n      }\n    });\n  }\n\n  /**\n   * Clear previously assigned blend shapes.\n   */\n  public clearAppliedWeight(): void {\n    this._binds.forEach((bind) => {\n      bind.meshes.forEach((mesh) => {\n        if (!mesh.morphTargetInfluences) {\n          return;\n        } // TODO: we should kick this at `addBind`\n        mesh.morphTargetInfluences[bind.morphTargetIndex] = 0.0;\n      });\n    });\n\n    this._materialValues.forEach((materialValue) => {\n      const prop = (materialValue.material as any)[materialValue.propertyName];\n      if (prop === undefined) {\n        return;\n      } // TODO: we should kick this at `addMaterialValue`\n\n      if (materialValue.type === VRMBlendShapeMaterialValueType.NUMBER) {\n        const defaultValue = materialValue.defaultValue as number;\n        (materialValue.material as any)[materialValue.propertyName] = defaultValue;\n      } else if (materialValue.type === VRMBlendShapeMaterialValueType.VECTOR2) {\n        const defaultValue = materialValue.defaultValue as THREE.Vector2;\n        (materialValue.material as any)[materialValue.propertyName].copy(defaultValue);\n      } else if (materialValue.type === VRMBlendShapeMaterialValueType.VECTOR3) {\n        const defaultValue = materialValue.defaultValue as THREE.Vector3;\n        (materialValue.material as any)[materialValue.propertyName].copy(defaultValue);\n      } else if (materialValue.type === VRMBlendShapeMaterialValueType.VECTOR4) {\n        const defaultValue = materialValue.defaultValue as THREE.Vector4;\n        (materialValue.material as any)[materialValue.propertyName].copy(defaultValue);\n      } else if (materialValue.type === VRMBlendShapeMaterialValueType.COLOR) {\n        const defaultValue = materialValue.defaultValue as THREE.Color;\n        (materialValue.material as any)[materialValue.propertyName].copy(defaultValue);\n      }\n\n      if (typeof (materialValue.material as any).shouldApplyUniforms === 'boolean') {\n        (materialValue.material as any).shouldApplyUniforms = true;\n      }\n    });\n  }\n}\n","import * as THREE from 'three';\nimport { GLTFMesh, GLTFPrimitive, VRMSchema } from '../types';\nimport { renameMaterialProperty } from '../utils/renameMaterialProperty';\nimport { VRMBlendShapeGroup } from './VRMBlendShapeGroup';\nimport { VRMBlendShapeProxy } from './VRMBlendShapeProxy';\n\n/**\n * An importer that imports a [[VRMBlendShape]] from a VRM extension of a GLTF.\n */\nexport class VRMBlendShapeImporter {\n  /**\n   * Import a [[VRMBlendShape]] from a VRM.\n   *\n   * @param gltf A parsed result of GLTF taken from GLTFLoader\n   */\n  public async import(gltf: THREE.GLTF): Promise<VRMBlendShapeProxy | null> {\n    const vrmExt: VRMSchema.VRM | undefined = gltf.parser.json.extensions && gltf.parser.json.extensions.VRM;\n    if (!vrmExt) {\n      return null;\n    }\n\n    const schemaBlendShape: VRMSchema.BlendShape | undefined = vrmExt.blendShapeMaster;\n    if (!schemaBlendShape) {\n      return null;\n    }\n\n    const blendShape = new VRMBlendShapeProxy();\n\n    const blendShapeGroups: VRMSchema.BlendShapeGroup[] | undefined = schemaBlendShape.blendShapeGroups;\n    if (!blendShapeGroups) {\n      return blendShape;\n    }\n\n    const blendShapePresetMap: { [presetName in VRMSchema.BlendShapePresetName]?: string } = {};\n\n    await Promise.all(\n      blendShapeGroups.map(async (schemaGroup) => {\n        const name = schemaGroup.name;\n        if (name === undefined) {\n          console.warn('VRMBlendShapeImporter: One of blendShapeGroups has no name');\n          return;\n        }\n\n        let presetName: VRMSchema.BlendShapePresetName | undefined;\n        if (\n          schemaGroup.presetName &&\n          schemaGroup.presetName !== VRMSchema.BlendShapePresetName.Unknown &&\n          !blendShapePresetMap[schemaGroup.presetName]\n        ) {\n          presetName = schemaGroup.presetName;\n          blendShapePresetMap[schemaGroup.presetName] = name;\n        }\n\n        const group = new VRMBlendShapeGroup(name);\n        gltf.scene.add(group);\n\n        group.isBinary = schemaGroup.isBinary || false;\n\n        if (schemaGroup.binds) {\n          schemaGroup.binds.forEach(async (bind) => {\n            if (bind.mesh === undefined || bind.index === undefined) {\n              return;\n            }\n\n            const morphMeshes: GLTFMesh = await gltf.parser.getDependency('mesh', bind.mesh);\n            const primitives: GLTFPrimitive[] =\n              morphMeshes.type === 'Group'\n                ? (morphMeshes.children as Array<GLTFPrimitive>)\n                : [morphMeshes as GLTFPrimitive];\n            const morphTargetIndex = bind.index;\n            if (\n              !primitives.every(\n                (primitive) =>\n                  Array.isArray(primitive.morphTargetInfluences) &&\n                  morphTargetIndex < primitive.morphTargetInfluences.length,\n              )\n            ) {\n              console.warn(\n                `VRMBlendShapeImporter: ${schemaGroup.name} attempts to index ${morphTargetIndex}th morph but not found.`,\n              );\n              return;\n            }\n\n            group.addBind({\n              meshes: primitives,\n              morphTargetIndex,\n              weight: bind.weight || 100,\n            });\n          });\n        }\n\n        const materialValues = schemaGroup.materialValues;\n        if (materialValues) {\n          materialValues.forEach((materialValue) => {\n            if (\n              materialValue.materialName === undefined ||\n              materialValue.propertyName === undefined ||\n              materialValue.targetValue === undefined\n            ) {\n              return;\n            }\n\n            const materials: THREE.Material[] = [];\n            gltf.scene.traverse((object) => {\n              if ((object as any).material) {\n                const material: THREE.Material[] | THREE.Material = (object as any).material;\n                if (Array.isArray(material)) {\n                  materials.push(\n                    ...material.filter(\n                      (mtl) => mtl.name === materialValue.materialName! && materials.indexOf(mtl) === -1,\n                    ),\n                  );\n                } else if (material.name === materialValue.materialName && materials.indexOf(material) === -1) {\n                  materials.push(material);\n                }\n              }\n            });\n\n            materials.forEach((material) => {\n              group.addMaterialValue({\n                material,\n                propertyName: renameMaterialProperty(materialValue.propertyName!),\n                targetValue: materialValue.targetValue!,\n              });\n            });\n          });\n        }\n\n        blendShape.registerBlendShapeGroup(name, presetName, group);\n      }),\n    );\n\n    return blendShape;\n  }\n}\n","import { VRMSchema } from '../types';\nimport { saturate } from '../utils/math';\nimport { VRMBlendShapeGroup } from './VRMBlendShapeGroup';\n\nexport class VRMBlendShapeProxy {\n  /**\n   * List of registered blend shape.\n   */\n  public readonly _blendShapeGroups: { [name: string]: VRMBlendShapeGroup } = {};\n\n  /**\n   * A map from [[VRMSchema.BlendShapePresetName]] to its actual blend shape name.\n   */\n  private readonly _blendShapePresetMap: { [presetName in VRMSchema.BlendShapePresetName]?: string } = {};\n\n  /**\n   * Create a new VRMBlendShape.\n   */\n  public constructor() {\n    // do nothing\n  }\n\n  /**\n   * List of name of registered blend shape group.\n   */\n  public get expressions(): string[] {\n    return Object.keys(this._blendShapeGroups);\n  }\n\n  /**\n   * Return registered blend shape group.\n   *\n   * @param name Name of the blend shape group\n   */\n  public getBlendShapeGroup(name: string | VRMSchema.BlendShapePresetName): VRMBlendShapeGroup | undefined {\n    const presetName = this._blendShapePresetMap[name as VRMSchema.BlendShapePresetName];\n    const controller = presetName ? this._blendShapeGroups[presetName] : this._blendShapeGroups[name];\n    if (!controller) {\n      console.warn(`no blend shape found by ${name}`);\n      return undefined;\n    }\n    return controller;\n  }\n\n  /**\n   * Register a blend shape group.\n   *\n   * @param name Name of the blend shape gorup\n   * @param controller VRMBlendShapeController that describes the blend shape group\n   */\n  public registerBlendShapeGroup(\n    name: string,\n    presetName: VRMSchema.BlendShapePresetName | undefined,\n    controller: VRMBlendShapeGroup,\n  ): void {\n    this._blendShapeGroups[name] = controller;\n    if (presetName) {\n      this._blendShapePresetMap[presetName] = name;\n    }\n  }\n\n  /**\n   * Get current weight of specified blend shape group.\n   *\n   * @param name Name of the blend shape group\n   */\n  public getValue(name: VRMSchema.BlendShapePresetName | string): number | null {\n    const controller = this.getBlendShapeGroup(name);\n    return (controller && controller.weight) || null;\n  }\n\n  /**\n   * Set a weight to specified blend shape group.\n   *\n   * @param name Name of the blend shape group\n   * @param weight Weight\n   */\n  public setValue(name: VRMSchema.BlendShapePresetName | string, weight: number): void {\n    const controller = this.getBlendShapeGroup(name);\n    if (controller) {\n      controller.weight = saturate(weight);\n    }\n  }\n\n  /**\n   * Get a track name of specified blend shape group.\n   * This track name is needed to manipulate its blend shape group via keyframe animations.\n   *\n   * @example Manipulate a blend shape group using keyframe animation\n   * ```js\n   * const trackName = vrm.blendShapeProxy.getBlendShapeTrackName( THREE.VRMSchema.BlendShapePresetName.Blink );\n   * const track = new THREE.NumberKeyframeTrack(\n   *   name,\n   *   [ 0.0, 0.5, 1.0 ], // times\n   *   [ 0.0, 1.0, 0.0 ] // values\n   * );\n   *\n   * const clip = new THREE.AnimationClip(\n   *   'blink', // name\n   *   1.0, // duration\n   *   [ track ] // tracks\n   * );\n   *\n   * const mixer = new THREE.AnimationMixer( vrm.scene );\n   * const action = mixer.clipAction( clip );\n   * action.play();\n   * ```\n   *\n   * @param name Name of the blend shape group\n   */\n  public getBlendShapeTrackName(name: VRMSchema.BlendShapePresetName | string): string | null {\n    const controller = this.getBlendShapeGroup(name);\n    return controller ? `${controller.name}.weight` : null;\n  }\n\n  /**\n   * Update every blend shape groups.\n   */\n  public update(): void {\n    Object.keys(this._blendShapeGroups).forEach((name) => {\n      const controller = this._blendShapeGroups[name];\n      controller.clearAppliedWeight();\n    });\n\n    Object.keys(this._blendShapeGroups).forEach((name) => {\n      const controller = this._blendShapeGroups[name];\n      controller.applyWeight();\n    });\n  }\n}\n","export * from './VRMBlendShapeGroup';\nexport * from './VRMBlendShapeImporter';\nexport * from './VRMBlendShapeProxy';\n","import * as THREE from 'three';\nimport { VRM, VRMParameters } from '../VRM';\nimport { VRMImporterOptions } from '../VRMImporter';\nimport { VRMDebugOptions } from './VRMDebugOptions';\nimport { VRMImporterDebug } from './VRMImporterDebug';\n\n/**\n * [[VRM]] but it has some useful gizmos.\n */\nexport class VRMDebug extends VRM {\n  /**\n   * Create a new VRMDebug from a parsed result of GLTF taken from GLTFLoader.\n   *\n   * See [[VRM.from]] for a detailed example.\n   *\n   * @param gltf A parsed GLTF object taken from GLTFLoader\n   * @param options Options that will be used in importer\n   * @param debugOption Options for VRMDebug features\n   */\n  public static async from(\n    gltf: THREE.GLTF,\n    options: VRMImporterOptions = {},\n    debugOption: VRMDebugOptions = {},\n  ): Promise<VRM> {\n    const importer = new VRMImporterDebug(options);\n    return await importer.import(gltf, debugOption);\n  }\n\n  /**\n   * Create a new VRMDebug instance.\n   *\n   * @param params [[VRMParameters]] that represents components of the VRM\n   * @param debugOption Options for VRMDebug features\n   */\n  constructor(params: VRMParameters, debugOption: VRMDebugOptions = {}) {\n    super(params);\n\n    // Gizmo\n    if (!debugOption.disableBoxHelper) {\n      this.scene.add(new THREE.BoxHelper(this.scene));\n    }\n\n    if (!debugOption.disableSkeletonHelper) {\n      this.scene.add(new THREE.SkeletonHelper(this.scene));\n    }\n  }\n\n  public update(delta: number): void {\n    super.update(delta);\n  }\n}\n","import * as THREE from 'three';\nimport { reduceBones } from '../reduceBones';\nimport { VRMImporter, VRMImporterOptions } from '../VRMImporter';\nimport { VRMDebug } from './VRMDebug';\nimport { VRMDebugOptions } from './VRMDebugOptions';\nimport { VRMLookAtHeadDebug } from './VRMLookAtHeadDebug';\nimport { VRMLookAtImporterDebug } from './VRMLookAtImporterDebug';\nimport { VRMSpringBoneImporterDebug } from './VRMSpringBoneImporterDebug';\n\n/**\n * An importer that imports a [[VRMDebug]] from a VRM extension of a GLTF.\n */\nexport class VRMImporterDebug extends VRMImporter {\n  public constructor(options: VRMImporterOptions = {}) {\n    options.lookAtImporter = options.lookAtImporter || new VRMLookAtImporterDebug();\n    options.springBoneImporter = options.springBoneImporter || new VRMSpringBoneImporterDebug();\n    super(options);\n  }\n\n  public async import(gltf: THREE.GLTF, debugOptions: VRMDebugOptions = {}): Promise<VRMDebug> {\n    if (gltf.parser.json.extensions === undefined || gltf.parser.json.extensions.VRM === undefined) {\n      throw new Error('Could not find VRM extension on the GLTF');\n    }\n    const vrmExt = gltf.parser.json.extensions.VRM;\n\n    const scene = gltf.scene;\n\n    scene.updateMatrixWorld(false);\n\n    // Skinned object should not be frustumCulled\n    // Since pre-skinned position might be outside of view\n    scene.traverse((object3d) => {\n      if ((object3d as any).isMesh) {\n        object3d.frustumCulled = false;\n      }\n    });\n\n    reduceBones(scene);\n\n    const materials = (await this._materialImporter.convertGLTFMaterials(gltf)) || undefined;\n\n    const humanoid = (await this._humanoidImporter.import(gltf)) || undefined;\n\n    const firstPerson = humanoid ? (await this._firstPersonImporter.import(gltf, humanoid)) || undefined : undefined;\n\n    const blendShapeProxy = (await this._blendShapeImporter.import(gltf)) || undefined;\n\n    const lookAt =\n      firstPerson && blendShapeProxy && humanoid\n        ? (await this._lookAtImporter.import(gltf, firstPerson, blendShapeProxy, humanoid)) || undefined\n        : undefined;\n    if ((lookAt as any).setupHelper) {\n      (lookAt as VRMLookAtHeadDebug).setupHelper(scene, debugOptions);\n    }\n\n    const springBoneManager = (await this._springBoneImporter.import(gltf)) || undefined;\n\n    return new VRMDebug(\n      {\n        scene: gltf.scene,\n        meta: vrmExt.meta,\n        materials,\n        humanoid,\n        firstPerson,\n        blendShapeProxy,\n        lookAt,\n        springBoneManager,\n      },\n      debugOptions,\n    );\n  }\n}\n","import * as THREE from 'three';\nimport { VRMLookAtHead } from '../lookat/VRMLookAtHead';\nimport { VRMDebugOptions } from './VRMDebugOptions';\n\nconst _v3 = new THREE.Vector3();\n\nexport class VRMLookAtHeadDebug extends VRMLookAtHead {\n  private _faceDirectionHelper?: THREE.ArrowHelper;\n\n  public setupHelper(scene: THREE.Scene, debugOption: VRMDebugOptions): void {\n    if (!debugOption.disableFaceDirectionHelper) {\n      this._faceDirectionHelper = new THREE.ArrowHelper(\n        new THREE.Vector3(0, 0, -1),\n        new THREE.Vector3(0, 0, 0),\n        0.5,\n        0xff00ff,\n      );\n      scene.add(this._faceDirectionHelper);\n    }\n  }\n\n  public update(delta: number): void {\n    super.update(delta);\n\n    if (this._faceDirectionHelper) {\n      this.firstPerson.getFirstPersonWorldPosition(this._faceDirectionHelper.position);\n      this._faceDirectionHelper.setDirection(this.getLookAtWorldDirection(_v3));\n    }\n  }\n}\n","import * as THREE from 'three';\nimport { VRMBlendShapeProxy } from '../blendshape';\nimport { VRMFirstPerson } from '../firstperson';\nimport { VRMHumanoid } from '../humanoid';\nimport { VRMLookAtHead } from '../lookat/VRMLookAtHead';\nimport { VRMLookAtImporter } from '../lookat/VRMLookAtImporter';\nimport { VRMSchema } from '../types';\nimport { VRMLookAtHeadDebug } from './VRMLookAtHeadDebug';\n\nexport class VRMLookAtImporterDebug extends VRMLookAtImporter {\n  public import(\n    gltf: THREE.GLTF,\n    firstPerson: VRMFirstPerson,\n    blendShapeProxy: VRMBlendShapeProxy,\n    humanoid: VRMHumanoid,\n  ): VRMLookAtHead | null {\n    const vrmExt: VRMSchema.VRM | undefined = gltf.parser.json.extensions && gltf.parser.json.extensions.VRM;\n    if (!vrmExt) {\n      return null;\n    }\n\n    const schemaFirstPerson: VRMSchema.FirstPerson | undefined = vrmExt.firstPerson;\n    if (!schemaFirstPerson) {\n      return null;\n    }\n\n    const applyer = this._importApplyer(schemaFirstPerson, blendShapeProxy, humanoid);\n    return new VRMLookAtHeadDebug(firstPerson, applyer || undefined);\n  }\n}\n","import * as THREE from 'three';\nimport { GIZMO_RENDER_ORDER, VRMSpringBone } from '../springbone';\n\nconst _v3A = new THREE.Vector3();\n\nexport class VRMSpringBoneDebug extends VRMSpringBone {\n  private _gizmo?: THREE.ArrowHelper;\n\n  constructor(\n    bone: THREE.Object3D,\n    radius: number,\n    stiffiness: number,\n    gravityDir: THREE.Vector3,\n    gravityPower: number,\n    dragForce: number,\n    colliders: THREE.Mesh[] = [],\n  ) {\n    super(bone, radius, stiffiness, gravityDir, gravityPower, dragForce, colliders);\n  }\n\n  /**\n   * Return spring bone gizmo, as `THREE.ArrowHelper`.\n   * Useful in debugging spring bones.\n   */\n  public getGizmo(): THREE.ArrowHelper {\n    // return if gizmo is already existed\n    if (this._gizmo) {\n      return this._gizmo;\n    }\n\n    const nextTailRelative = _v3A.copy(this._nextTail).sub(this._worldPosition);\n    const nextTailRelativeLength = nextTailRelative.length();\n\n    this._gizmo = new THREE.ArrowHelper(\n      nextTailRelative.normalize(),\n      this._worldPosition,\n      nextTailRelativeLength,\n      0xffff00,\n      this.radius,\n      this.radius,\n    );\n\n    // it should be always visible\n    this._gizmo.line.renderOrder = GIZMO_RENDER_ORDER;\n    this._gizmo.cone.renderOrder = GIZMO_RENDER_ORDER;\n    (this._gizmo.line.material as THREE.Material).depthTest = false;\n    (this._gizmo.line.material as THREE.Material).transparent = true;\n    (this._gizmo.cone.material as THREE.Material).depthTest = false;\n    (this._gizmo.cone.material as THREE.Material).transparent = true;\n\n    return this._gizmo;\n  }\n\n  public update(delta: number): void {\n    super.update(delta);\n    // lastly we're gonna update gizmo\n    this._updateGizmo();\n  }\n\n  private _updateGizmo(): void {\n    if (!this._gizmo) {\n      return;\n    }\n\n    const nextTailRelative = _v3A.copy(this._currentTail).sub(this._worldPosition);\n    const nextTailRelativeLength = nextTailRelative.length();\n\n    this._gizmo.setDirection(nextTailRelative.normalize());\n    this._gizmo.setLength(nextTailRelativeLength, this.radius, this.radius);\n    this._gizmo.position.copy(this._worldPosition);\n  }\n}\n","import * as THREE from 'three';\nimport { VRMSpringBone } from '../springbone/VRMSpringBone';\nimport { VRMSpringBoneImporter } from '../springbone/VRMSpringBoneImporter';\nimport { VRMSpringBoneDebug } from './VRMSpringBoneDebug';\n\nexport class VRMSpringBoneImporterDebug extends VRMSpringBoneImporter {\n  protected get _isColiderMeshVisible(): boolean {\n    return true;\n  }\n\n  protected _createSpringBone(\n    gltf: THREE.GLTF,\n    bone: THREE.Object3D,\n    hitRadius: number,\n    stiffiness: number,\n    gravityDir: THREE.Vector3,\n    gravityPower: number,\n    dragForce: number,\n    colliders: THREE.Mesh[] = [],\n  ): VRMSpringBone {\n    const springBone = new VRMSpringBoneDebug(\n      bone,\n      hitRadius,\n      stiffiness,\n      gravityDir,\n      gravityPower,\n      dragForce,\n      colliders,\n    );\n    gltf.scene.add(springBone.getGizmo());\n    return springBone;\n  }\n}\n","export * from './VRMDebugOptions';\nexport * from './VRMDebug';\nexport * from './VRMSpringBoneDebug';\nexport * from './VRMSpringBoneImporterDebug';\n","import * as THREE from 'three';\nimport { GLTFMesh, GLTFNode } from '../types';\nimport { getWorldQuaternionLite } from '../utils/math';\n\nconst VECTOR3_FRONT = Object.freeze(new THREE.Vector3(0.0, 0.0, -1.0));\n\nconst _quat = new THREE.Quaternion();\n\nenum FirstPersonFlag {\n  Auto,\n  Both,\n  ThirdPersonOnly,\n  FirstPersonOnly,\n}\n\n/**\n * This class represents a single [`meshAnnotation`](https://github.com/vrm-c/UniVRM/blob/master/specification/0.0/schema/vrm.firstperson.meshannotation.schema.json) entry.\n * Each mesh will be assigned to specified layer when you call [[VRMFirstPerson.setup]].\n */\nexport class VRMRendererFirstPersonFlags {\n  private static _parseFirstPersonFlag(firstPersonFlag: string | undefined): FirstPersonFlag {\n    switch (firstPersonFlag) {\n      case 'Both':\n        return FirstPersonFlag.Both;\n      case 'ThirdPersonOnly':\n        return FirstPersonFlag.ThirdPersonOnly;\n      case 'FirstPersonOnly':\n        return FirstPersonFlag.FirstPersonOnly;\n      default:\n        return FirstPersonFlag.Auto;\n    }\n  }\n\n  /**\n   * A [[FirstPersonFlag]] of the annotation entry.\n   */\n  public firstPersonFlag: FirstPersonFlag;\n\n  /**\n   * A mesh of the annotation entry.\n   */\n  public mesh: GLTFMesh;\n\n  /**\n   * Create a new mesh annotation.\n   *\n   * @param firstPersonFlag A [[FirstPersonFlag]] of the annotation entry\n   * @param node A node of the annotation entry.\n   */\n  constructor(firstPersonFlag: string | undefined, mesh: GLTFMesh) {\n    this.firstPersonFlag = VRMRendererFirstPersonFlags._parseFirstPersonFlag(firstPersonFlag);\n    this.mesh = mesh;\n  }\n}\n\nexport class VRMFirstPerson {\n  /**\n   * A default camera layer for `FirstPersonOnly` layer.\n   *\n   * @see [[getFirstPersonOnlyLayer]]\n   */\n  private static readonly _DEFAULT_FIRSTPERSON_ONLY_LAYER = 9;\n\n  /**\n   * A default camera layer for `ThirdPersonOnly` layer.\n   *\n   * @see [[getThirdPersonOnlyLayer]]\n   */\n  private static readonly _DEFAULT_THIRDPERSON_ONLY_LAYER = 10;\n\n  private readonly _firstPersonBone: GLTFNode;\n  private readonly _meshAnnotations: VRMRendererFirstPersonFlags[] = [];\n  private readonly _firstPersonBoneOffset: THREE.Vector3;\n\n  private _firstPersonOnlyLayer = VRMFirstPerson._DEFAULT_FIRSTPERSON_ONLY_LAYER;\n  private _thirdPersonOnlyLayer = VRMFirstPerson._DEFAULT_THIRDPERSON_ONLY_LAYER;\n\n  private _initialized = false;\n\n  /**\n   * Create a new VRMFirstPerson object.\n   *\n   * @param firstPersonBone A first person bone\n   * @param firstPersonBoneOffset An offset from the specified first person bone\n   * @param meshAnnotations A renderer settings. See the description of [[RendererFirstPersonFlags]] for more info\n   */\n  constructor(\n    firstPersonBone: GLTFNode,\n    firstPersonBoneOffset: THREE.Vector3,\n    meshAnnotations: VRMRendererFirstPersonFlags[],\n  ) {\n    this._firstPersonBone = firstPersonBone;\n    this._firstPersonBoneOffset = firstPersonBoneOffset;\n    this._meshAnnotations = meshAnnotations;\n  }\n\n  public get firstPersonBone(): GLTFNode {\n    return this._firstPersonBone;\n  }\n\n  public get meshAnnotations(): VRMRendererFirstPersonFlags[] {\n    return this._meshAnnotations;\n  }\n\n  public getFirstPersonWorldDirection(target: THREE.Vector3): THREE.Vector3 {\n    return target.copy(VECTOR3_FRONT).applyQuaternion(getWorldQuaternionLite(this._firstPersonBone, _quat));\n  }\n\n  /**\n   * A camera layer represents `FirstPersonOnly` layer.\n   * Note that **you must call [[setup]] first before you use the layer feature** or it does not work properly.\n   *\n   * The value is [[DEFAULT_FIRSTPERSON_ONLY_LAYER]] by default but you can change the layer by specifying via [[setup]] if you prefer.\n   *\n   * @see https://vrm.dev/en/univrm/api/univrm_use_firstperson/\n   * @see https://threejs.org/docs/#api/en/core/Layers\n   */\n  public get firstPersonOnlyLayer(): number {\n    return this._firstPersonOnlyLayer;\n  }\n\n  /**\n   * A camera layer represents `ThirdPersonOnly` layer.\n   * Note that **you must call [[setup]] first before you use the layer feature** or it does not work properly.\n   *\n   * The value is [[DEFAULT_THIRDPERSON_ONLY_LAYER]] by default but you can change the layer by specifying via [[setup]] if you prefer.\n   *\n   * @see https://vrm.dev/en/univrm/api/univrm_use_firstperson/\n   * @see https://threejs.org/docs/#api/en/core/Layers\n   */\n  public get thirdPersonOnlyLayer(): number {\n    return this._thirdPersonOnlyLayer;\n  }\n\n  public getFirstPersonBoneOffset(target: THREE.Vector3): THREE.Vector3 {\n    return target.copy(this._firstPersonBoneOffset);\n  }\n\n  /**\n   * Get current world position of the first person.\n   * The position takes [[FirstPersonBone]] and [[FirstPersonOffset]] into account.\n   *\n   * @param v3 target\n   * @returns Current world position of the first person\n   */\n  public getFirstPersonWorldPosition(v3: THREE.Vector3): THREE.Vector3 {\n    // UniVRM#VRMFirstPersonEditor\n    // var worldOffset = head.localToWorldMatrix.MultiplyPoint(component.FirstPersonOffset);\n    const offset = this._firstPersonBoneOffset;\n    const v4 = new THREE.Vector4(offset.x, offset.y, offset.z, 1.0);\n    v4.applyMatrix4(this._firstPersonBone.matrixWorld);\n    return v3.set(v4.x, v4.y, v4.z);\n  }\n\n  /**\n   * In this method, it assigns layers for every meshes based on mesh annotations.\n   * You must call this method first before you use the layer feature.\n   *\n   * This is an equivalent of [VRMFirstPerson.Setup](https://github.com/vrm-c/UniVRM/blob/master/Assets/VRM/UniVRM/Scripts/FirstPerson/VRMFirstPerson.cs) of the UniVRM.\n   *\n   * The `cameraLayer` parameter specifies which layer will be assigned for `FirstPersonOnly` / `ThirdPersonOnly`.\n   * In UniVRM, we specified those by naming each desired layer as `FIRSTPERSON_ONLY_LAYER` / `THIRDPERSON_ONLY_LAYER`\n   * but we are going to specify these layers at here since we are unable to name layers in Three.js.\n   *\n   * @param cameraLayer Specify which layer will be for `FirstPersonOnly` / `ThirdPersonOnly`.\n   */\n  public setup({\n    firstPersonOnlyLayer = VRMFirstPerson._DEFAULT_FIRSTPERSON_ONLY_LAYER,\n    thirdPersonOnlyLayer = VRMFirstPerson._DEFAULT_THIRDPERSON_ONLY_LAYER,\n  } = {}): void {\n    if (this._initialized) {\n      return;\n    }\n    this._initialized = true;\n    this._firstPersonOnlyLayer = firstPersonOnlyLayer;\n    this._thirdPersonOnlyLayer = thirdPersonOnlyLayer;\n\n    this._meshAnnotations.forEach((item) => {\n      if (item.firstPersonFlag === FirstPersonFlag.FirstPersonOnly) {\n        item.mesh.layers.set(this._firstPersonOnlyLayer);\n        item.mesh.traverse((child) => child.layers.set(this._firstPersonOnlyLayer));\n      } else if (item.firstPersonFlag === FirstPersonFlag.ThirdPersonOnly) {\n        item.mesh.layers.set(this._thirdPersonOnlyLayer);\n        item.mesh.traverse((child) => child.layers.set(this._thirdPersonOnlyLayer));\n      } else if (item.firstPersonFlag === FirstPersonFlag.Auto) {\n        this._createHeadlessModel(item.mesh);\n      }\n    });\n  }\n\n  private _excludeTriangles(triangles: number[], bws: number[][], skinIndex: number[][], exclude: number[]): number {\n    let count = 0;\n    if (bws != null && bws.length > 0) {\n      for (let i = 0; i < triangles.length; i += 3) {\n        const a = triangles[i];\n        const b = triangles[i + 1];\n        const c = triangles[i + 2];\n        const bw0 = bws[a];\n        const skin0 = skinIndex[a];\n\n        if (bw0[0] > 0 && exclude.includes(skin0[0])) continue;\n        if (bw0[1] > 0 && exclude.includes(skin0[1])) continue;\n        if (bw0[2] > 0 && exclude.includes(skin0[2])) continue;\n        if (bw0[3] > 0 && exclude.includes(skin0[3])) continue;\n\n        const bw1 = bws[b];\n        const skin1 = skinIndex[b];\n        if (bw1[0] > 0 && exclude.includes(skin1[0])) continue;\n        if (bw1[1] > 0 && exclude.includes(skin1[1])) continue;\n        if (bw1[2] > 0 && exclude.includes(skin1[2])) continue;\n        if (bw1[3] > 0 && exclude.includes(skin1[3])) continue;\n\n        const bw2 = bws[c];\n        const skin2 = skinIndex[c];\n        if (bw2[0] > 0 && exclude.includes(skin2[0])) continue;\n        if (bw2[1] > 0 && exclude.includes(skin2[1])) continue;\n        if (bw2[2] > 0 && exclude.includes(skin2[2])) continue;\n        if (bw2[3] > 0 && exclude.includes(skin2[3])) continue;\n\n        triangles[count++] = a;\n        triangles[count++] = b;\n        triangles[count++] = c;\n      }\n    }\n    return count;\n  }\n\n  private _createErasedMesh(src: THREE.SkinnedMesh, erasingBonesIndex: number[]): THREE.SkinnedMesh {\n    const dst = new THREE.SkinnedMesh(src.geometry.clone(), src.material);\n    dst.name = `${src.name}(erase)`;\n    dst.frustumCulled = src.frustumCulled;\n    dst.layers.set(this._firstPersonOnlyLayer);\n\n    const geometry = dst.geometry as THREE.BufferGeometry;\n    const skinIndexAttr = geometry.getAttribute('skinIndex').array;\n    const skinIndex = [];\n    for (let i = 0; i < skinIndexAttr.length; i += 4) {\n      skinIndex.push([skinIndexAttr[i], skinIndexAttr[i + 1], skinIndexAttr[i + 2], skinIndexAttr[i + 3]]);\n    }\n    const skinWeightAttr = geometry.getAttribute('skinWeight').array;\n    const skinWeight = [];\n    for (let i = 0; i < skinWeightAttr.length; i += 4) {\n      skinWeight.push([skinWeightAttr[i], skinWeightAttr[i + 1], skinWeightAttr[i + 2], skinWeightAttr[i + 3]]);\n    }\n    const oldTriangles = Array.from(geometry.getIndex().array);\n    const count = this._excludeTriangles(oldTriangles, skinWeight, skinIndex, erasingBonesIndex);\n    const newTriangle: number[] = [];\n    for (let i = 0; i < count; i++) {\n      newTriangle[i] = oldTriangles[i];\n    }\n    geometry.setIndex(newTriangle);\n\n    // mtoon material includes onBeforeRender. this is unsupported at SkinnedMesh#clone\n    if (src.onBeforeRender) {\n      dst.onBeforeRender = src.onBeforeRender;\n    }\n    dst.bind(new THREE.Skeleton(src.skeleton.bones, src.skeleton.boneInverses), new THREE.Matrix4());\n    return dst;\n  }\n\n  private _createHeadlessModelForSkinnedMesh(parent: THREE.Object3D, mesh: THREE.SkinnedMesh): void {\n    const eraseBoneIndexes: number[] = [];\n    mesh.skeleton.bones.forEach((bone, index) => {\n      if (this._isEraseTarget(bone)) eraseBoneIndexes.push(index);\n    });\n\n    // Unlike UniVRM we don't copy mesh if no invisible bone was found\n    if (!eraseBoneIndexes.length) {\n      mesh.layers.enable(this._thirdPersonOnlyLayer);\n      mesh.layers.enable(this._firstPersonOnlyLayer);\n      return;\n    }\n    mesh.layers.set(this._thirdPersonOnlyLayer);\n    const newMesh = this._createErasedMesh(mesh, eraseBoneIndexes);\n    parent.add(newMesh);\n  }\n\n  private _createHeadlessModel(node: GLTFNode): void {\n    if (node.type === 'Group') {\n      node.layers.set(this._thirdPersonOnlyLayer);\n      if (this._isEraseTarget(node)) {\n        node.traverse((child) => child.layers.set(this._thirdPersonOnlyLayer));\n      } else {\n        const parent = new THREE.Group();\n        parent.name = `_headless_${node.name}`;\n        parent.layers.set(this._firstPersonOnlyLayer);\n        node.parent!.add(parent);\n        node.children\n          .filter((child) => child.type === 'SkinnedMesh')\n          .forEach((child) => {\n            this._createHeadlessModelForSkinnedMesh(parent, child as THREE.SkinnedMesh);\n          });\n      }\n    } else if (node.type === 'SkinnedMesh') {\n      this._createHeadlessModelForSkinnedMesh(node.parent!, node as THREE.SkinnedMesh);\n    } else {\n      if (this._isEraseTarget(node)) {\n        node.layers.set(this._thirdPersonOnlyLayer);\n        node.traverse((child) => child.layers.set(this._thirdPersonOnlyLayer));\n      }\n    }\n  }\n\n  private _isEraseTarget(bone: GLTFNode): boolean {\n    if (bone.name === this._firstPersonBone.name) {\n      return true;\n    } else if (!bone.parent) {\n      return false;\n    } else {\n      return this._isEraseTarget(bone.parent!);\n    }\n  }\n}\n","import * as THREE from 'three';\nimport { VRMHumanoid } from '../humanoid';\nimport { GLTFMesh, GLTFNode, VRMSchema } from '../types';\nimport { VRMFirstPerson, VRMRendererFirstPersonFlags } from './VRMFirstPerson';\n\n/**\n * An importer that imports a [[VRMFirstPerson]] from a VRM extension of a GLTF.\n */\nexport class VRMFirstPersonImporter {\n  /**\n   * Import a [[VRMFirstPerson]] from a VRM.\n   *\n   * @param gltf A parsed result of GLTF taken from GLTFLoader\n   * @param humanoid A [[VRMHumanoid]] instance that represents the VRM\n   */\n  public async import(gltf: THREE.GLTF, humanoid: VRMHumanoid): Promise<VRMFirstPerson | null> {\n    const vrmExt: VRMSchema.VRM | undefined = gltf.parser.json.extensions && gltf.parser.json.extensions.VRM;\n    if (!vrmExt) {\n      return null;\n    }\n\n    const schemaFirstPerson: VRMSchema.FirstPerson | undefined = vrmExt.firstPerson;\n    if (!schemaFirstPerson) {\n      return null;\n    }\n\n    const firstPersonBoneIndex = schemaFirstPerson.firstPersonBone;\n\n    let firstPersonBone: GLTFNode | null;\n    if (firstPersonBoneIndex === undefined || firstPersonBoneIndex === -1) {\n      firstPersonBone = humanoid.getBoneNode(VRMSchema.HumanoidBoneName.Head);\n    } else {\n      firstPersonBone = await gltf.parser.getDependency('node', firstPersonBoneIndex);\n    }\n\n    if (!firstPersonBone) {\n      console.warn('VRMFirstPersonImporter: Could not find firstPersonBone of the VRM');\n      return null;\n    }\n\n    const firstPersonBoneOffset = schemaFirstPerson.firstPersonBoneOffset\n      ? new THREE.Vector3(\n          schemaFirstPerson.firstPersonBoneOffset.x,\n          schemaFirstPerson.firstPersonBoneOffset.y,\n          schemaFirstPerson.firstPersonBoneOffset.z,\n        )\n      : new THREE.Vector3(0.0, 0.06, 0.0); // fallback, taken from UniVRM implementation\n\n    const meshAnnotations: VRMRendererFirstPersonFlags[] = [];\n    const meshes: GLTFMesh[] = await gltf.parser.getDependencies('mesh');\n    meshes.forEach((mesh, meshIndex) => {\n      const flag = schemaFirstPerson.meshAnnotations\n        ? schemaFirstPerson.meshAnnotations.find((a) => a.mesh === meshIndex)\n        : undefined;\n      meshAnnotations.push(new VRMRendererFirstPersonFlags(flag && flag.firstPersonFlag, mesh));\n    });\n\n    return new VRMFirstPerson(firstPersonBone, firstPersonBoneOffset, meshAnnotations);\n  }\n}\n","export * from './VRMFirstPerson';\nexport * from './VRMFirstPersonImporter';\n","import { GLTFNode } from '../types';\nimport { VRMHumanLimit } from './VRMHumanLimit';\n\n/**\n * A class represents a single `humanBone` of a VRM.\n */\nexport class VRMHumanBone {\n  /**\n   * A [[GLTFNode]] (that actually is a `THREE.Object3D`) that represents the bone.\n   */\n  public readonly node: GLTFNode;\n\n  /**\n   * A [[VRMHumanLimit]] object that represents properties of the bone.\n   */\n  public readonly humanLimit: VRMHumanLimit;\n\n  /**\n   * Create a new VRMHumanBone.\n   *\n   * @param node A [[GLTFNode]] that represents the new bone\n   * @param humanLimit A [[VRMHumanLimit]] object that represents properties of the new bone\n   */\n  public constructor(node: GLTFNode, humanLimit: VRMHumanLimit) {\n    this.node = node;\n    this.humanLimit = humanLimit;\n  }\n}\n","import { GLTFNode, RawVector3, RawVector4, VRMPose, VRMSchema } from '../types';\nimport { VRMHumanBone } from './VRMHumanBone';\nimport { VRMHumanBoneArray } from './VRMHumanBoneArray';\nimport { VRMHumanBones } from './VRMHumanBones';\nimport { VRMHumanDescription } from './VRMHumanDescription';\n\n/**\n * A class represents humanoid of a VRM.\n */\nexport class VRMHumanoid {\n  /**\n   * A [[VRMHumanBones]] that contains all the human bones of the VRM.\n   * You might want to get these bones using [[VRMHumanoid.getBone]].\n   */\n  public readonly humanBones: VRMHumanBones;\n\n  /**\n   * A [[VRMHumanDescription]] that represents properties of the humanoid.\n   */\n  public readonly humanDescription: VRMHumanDescription;\n\n  /**\n   * A [[VRMPose]] that is its default state.\n   * You might use [[VRMHumanoid.setPose]] with this pose to reset its state.\n   */\n  public readonly restPose: VRMPose;\n\n  /**\n   * Create a new [[VRMHumanoid]].\n   * @param boneArray A [[VRMHumanBoneArray]] contains all the bones of the new humanoid\n   * @param humanDescription A [[VRMHumanDescription]] that represents properties of the new humanoid\n   */\n  public constructor(boneArray: VRMHumanBoneArray, humanDescription: VRMHumanDescription) {\n    this.humanBones = this._createHumanBones(boneArray);\n    this.humanDescription = humanDescription;\n\n    this.restPose = this.getPose();\n  }\n\n  /**\n   * Return the current pose of this humanoid as a [[VRMPose]].\n   */\n  public getPose(): VRMPose {\n    const pose: VRMPose = {};\n    Object.keys(this.humanBones).forEach(\n      (vrmBoneName) => {\n        const node = this.getBoneNode(vrmBoneName as VRMSchema.HumanoidBoneName)!;\n\n        // Ignore when there are no bone on the VRMHumanoid\n        if (!node) {\n          return;\n        }\n\n        // When there are two or more bones in a same name, we are not going to overwrite existing one\n        if (pose[vrmBoneName]) {\n          return;\n        }\n\n        pose[vrmBoneName] = {\n          position: node.position.toArray() as RawVector3,\n          rotation: node.quaternion.toArray() as RawVector4,\n        };\n      },\n      {} as VRMPose,\n    );\n    return pose;\n  }\n\n  /**\n   * Let the humanoid do a specified pose.\n   *\n   * @param poseObject A [[VRMPose]] that represents a single pose\n   */\n  public setPose(poseObject: VRMPose): void {\n    Object.keys(poseObject).forEach((boneName) => {\n      const state = poseObject[boneName]!;\n      const node = this.getBoneNode(boneName as VRMSchema.HumanoidBoneName);\n\n      // Ignore when there are no bone that is defined in the pose on the VRMHumanoid\n      if (!node) {\n        return;\n      }\n\n      const restState = this.restPose[boneName];\n      if (!restState) {\n        return;\n      }\n\n      if (state.position) {\n        // \n        node.position.set(\n          restState.position![0] + state.position[0],\n          restState.position![1] + state.position[1],\n          restState.position![2] + state.position[2],\n        );\n      }\n      if (state.rotation) {\n        node.quaternion.fromArray(state.rotation);\n      }\n    });\n  }\n\n  /**\n   * Return a bone bound to a specified [[HumanBone]], as a [[VRMHumanBone]].\n   *\n   * See also: [[VRMHumanoid.getBones]]\n   *\n   * @param name Name of the bone you want\n   */\n  public getBone(name: VRMSchema.HumanoidBoneName): VRMHumanBone | undefined {\n    return this.humanBones[name][0] || undefined;\n  }\n\n  /**\n   * Return bones bound to a specified [[HumanBone]], as an array of [[VRMHumanBone]].\n   *\n   * See also: [[VRMHumanoid.getBone]]\n   *\n   * @param name Name of the bone you want\n   */\n  public getBones(name: VRMSchema.HumanoidBoneName): VRMHumanBone[] {\n    return this.humanBones[name];\n  }\n\n  /**\n   * Return a bone bound to a specified [[HumanBone]], as a THREE.Object3D.\n   *\n   * See also: [[VRMHumanoid.getBoneNodes]]\n   *\n   * @param name Name of the bone you want\n   */\n  public getBoneNode(name: VRMSchema.HumanoidBoneName): GLTFNode | null {\n    return (this.humanBones[name][0] && this.humanBones[name][0].node) || null;\n  }\n\n  /**\n   * Return bones bound to a specified [[HumanBone]], as an array of THREE.Object3D.\n   *\n   * See also: [[VRMHumanoid.getBoneNode]]\n   *\n   * @param name Name of the bone you want\n   */\n  public getBoneNodes(name: VRMSchema.HumanoidBoneName): GLTFNode[] {\n    return this.humanBones[name].map((bone) => bone.node);\n  }\n\n  /**\n   * Prepare a [[VRMHumanBones]] from a [[VRMHumanBoneArray]].\n   */\n  private _createHumanBones(boneArray: VRMHumanBoneArray): VRMHumanBones {\n    const bones: VRMHumanBones = Object.values(VRMSchema.HumanoidBoneName).reduce((accum, name) => {\n      accum[name] = [];\n      return accum;\n    }, {});\n\n    boneArray.forEach((bone) => {\n      bones[bone.name].push(bone.bone);\n    });\n\n    return bones;\n  }\n}\n","import * as THREE from 'three';\nimport { VRMSchema } from '../types';\nimport { VRMHumanBone } from './VRMHumanBone';\nimport { VRMHumanBoneArray } from './VRMHumanBoneArray';\nimport { VRMHumanDescription } from './VRMHumanDescription';\nimport { VRMHumanoid } from './VRMHumanoid';\n\n/**\n * An importer that imports a [[VRMHumanoid]] from a VRM extension of a GLTF.\n */\nexport class VRMHumanoidImporter {\n  /**\n   * Import a [[VRMHumanoid]] from a VRM.\n   *\n   * @param gltf A parsed result of GLTF taken from GLTFLoader\n   */\n  public async import(gltf: THREE.GLTF): Promise<VRMHumanoid | null> {\n    const vrmExt: VRMSchema.VRM | undefined = gltf.parser.json.extensions && gltf.parser.json.extensions.VRM;\n    if (!vrmExt) {\n      return null;\n    }\n\n    const schemaHumanoid: VRMSchema.Humanoid | undefined = vrmExt.humanoid;\n    if (!schemaHumanoid) {\n      return null;\n    }\n\n    const humanBoneArray: VRMHumanBoneArray = [];\n    if (schemaHumanoid.humanBones) {\n      await Promise.all(\n        schemaHumanoid.humanBones.map(async (bone) => {\n          if (!bone.bone || !bone.node) {\n            return;\n          }\n\n          const node = await gltf.parser.getDependency('node', bone.node);\n          humanBoneArray.push({\n            name: bone.bone,\n            bone: new VRMHumanBone(node, {\n              axisLength: bone.axisLength,\n              center: bone.center && new THREE.Vector3(bone.center.x, bone.center.y, bone.center.z),\n              max: bone.max && new THREE.Vector3(bone.max.x, bone.max.y, bone.max.z),\n              min: bone.min && new THREE.Vector3(bone.min.x, bone.min.y, bone.min.z),\n              useDefaultValues: bone.useDefaultValues,\n            }),\n          });\n        }),\n      );\n    }\n\n    const humanDescription: VRMHumanDescription = {\n      armStretch: schemaHumanoid.armStretch,\n      legStretch: schemaHumanoid.legStretch,\n      upperArmTwist: schemaHumanoid.upperArmTwist,\n      lowerArmTwist: schemaHumanoid.lowerArmTwist,\n      upperLegTwist: schemaHumanoid.upperLegTwist,\n      lowerLegTwist: schemaHumanoid.lowerLegTwist,\n      feetSpacing: schemaHumanoid.feetSpacing,\n      hasTranslationDoF: schemaHumanoid.hasTranslationDoF,\n    };\n\n    return new VRMHumanoid(humanBoneArray, humanDescription);\n  }\n}\n","export * from './VRMHumanBone';\nexport * from './VRMHumanBones';\nexport * from './VRMHumanDescription';\nexport * from './VRMHumanLimit';\nexport * from './VRMHumanoid';\nexport * from './VRMHumanoidImporter';\n","export * from './VRM';\nexport * from './VRMImporter';\nexport * from './reduceBones';\nexport * from './blendshape';\nexport * from './debug';\nexport * from './firstperson';\nexport * from './humanoid';\nexport * from './lookat';\nexport * from './springbone';\nexport * from './types';\nexport * from './material';\n","/**\n * Evaluate a hermite spline.\n *\n * @param y0 y on start\n * @param y1 y on end\n * @param t0 delta y on start\n * @param t1 delta y on end\n * @param x input value\n */\nconst hermiteSpline = (y0: number, y1: number, t0: number, t1: number, x: number): number => {\n  const xc = x * x * x;\n  const xs = x * x;\n  const dy = y1 - y0;\n  const h01 = -2.0 * xc + 3.0 * xs;\n  const h10 = xc - 2.0 * xs + x;\n  const h11 = xc - xs;\n  return y0 + dy * h01 + t0 * h10 + t1 * h11;\n};\n\n/**\n * Evaluate an AnimationCurve array. See AnimationCurve class of Unity for its details.\n *\n * See: https://docs.unity3d.com/ja/current/ScriptReference/AnimationCurve.html\n *\n * @param arr An array represents a curve\n * @param x An input value\n */\nconst evaluateCurve = (arr: number[], x: number): number => {\n  // -- sanity check -----------------------------------------------------------\n  if (arr.length < 8) {\n    throw new Error('evaluateCurve: Invalid curve detected! (Array length must be 8 at least)');\n  }\n  if (arr.length % 4 !== 0) {\n    throw new Error('evaluateCurve: Invalid curve detected! (Array length must be multiples of 4');\n  }\n\n  // -- check range ------------------------------------------------------------\n  let outNode;\n  for (outNode = 0; ; outNode++) {\n    if (arr.length <= 4 * outNode) {\n      return arr[4 * outNode - 3]; // too further!! assume as \"Clamp\"\n    } else if (x <= arr[4 * outNode]) {\n      break;\n    }\n  }\n\n  const inNode = outNode - 1;\n  if (inNode < 0) {\n    return arr[4 * inNode + 5]; // too behind!! assume as \"Clamp\"\n  }\n\n  // -- calculate local x ------------------------------------------------------\n  const x0 = arr[4 * inNode];\n  const x1 = arr[4 * outNode];\n  const xHermite = (x - x0) / (x1 - x0);\n\n  // -- finally do the hermite spline ------------------------------------------\n  const y0 = arr[4 * inNode + 1];\n  const y1 = arr[4 * outNode + 1];\n  const t0 = arr[4 * inNode + 3];\n  const t1 = arr[4 * outNode + 2];\n  return hermiteSpline(y0, y1, t0, t1, xHermite);\n};\n\n/**\n * This is an equivalent of CurveMapper class defined in UniVRM.\n * Will be used for [[VRMLookAtApplyer]]s, to define behavior of LookAt.\n *\n * See: https://github.com/vrm-c/UniVRM/blob/master/Assets/VRM/UniVRM/Scripts/LookAt/CurveMapper.cs\n */\nexport class CurveMapper {\n  /**\n   * An array represents the curve. See AnimationCurve class of Unity for its details.\n   *\n   * See: https://docs.unity3d.com/ja/current/ScriptReference/AnimationCurve.html\n   */\n  public curve: number[] = [0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 1.0, 0.0];\n\n  /**\n   * The maximum input range of the [[CurveMapper]].\n   */\n  public curveXRangeDegree = 90.0;\n\n  /**\n   * The maximum output value of the [[CurveMapper]].\n   */\n  public curveYRangeDegree = 10.0;\n\n  /**\n   * Create a new [[CurveMapper]].\n   *\n   * @param xRange The maximum input range\n   * @param yRange The maximum output value\n   * @param curve An array represents the curve\n   */\n  constructor(xRange?: number, yRange?: number, curve?: number[]) {\n    if (xRange !== undefined) {\n      this.curveXRangeDegree = xRange;\n    }\n\n    if (yRange !== undefined) {\n      this.curveYRangeDegree = yRange;\n    }\n\n    if (curve !== undefined) {\n      this.curve = curve;\n    }\n  }\n\n  /**\n   * Evaluate an input value and output a mapped value.\n   *\n   * @param src The input value\n   */\n  public map(src: number): number {\n    const clampedSrc = Math.min(Math.max(src, 0.0), this.curveXRangeDegree);\n    const x = clampedSrc / this.curveXRangeDegree;\n    return this.curveYRangeDegree * evaluateCurve(this.curve, x);\n  }\n}\n","import * as THREE from 'three';\nimport { VRMSchema } from '../types';\n\n/**\n * This class is used by [[VRMLookAtHead]], applies look at direction.\n * There are currently two variant of applier: [[VRMLookAtBoneApplyer]] and [[VRMLookAtBlendShapeApplyer]].\n */\nexport abstract class VRMLookAtApplyer {\n  /**\n   * It represents its type of applier.\n   */\n  public abstract readonly type: VRMSchema.FirstPersonLookAtTypeName;\n\n  /**\n   * Apply look at direction to its associated VRM model.\n   *\n   * @param euler `THREE.Euler` object that represents the look at direction\n   */\n  public abstract lookAt(euler: THREE.Euler): void;\n}\n","import * as THREE from 'three';\nimport { VRMBlendShapeProxy } from '../blendshape';\nimport { VRMSchema } from '../types';\nimport { CurveMapper } from './CurveMapper';\nimport { VRMLookAtApplyer } from './VRMLookAtApplyer';\n\n/**\n * This class is used by [[VRMLookAtHead]], applies look at direction to eye blend shapes of a VRM.\n */\nexport class VRMLookAtBlendShapeApplyer extends VRMLookAtApplyer {\n  public readonly type = VRMSchema.FirstPersonLookAtTypeName.BlendShape;\n\n  private readonly _curveHorizontal: CurveMapper;\n  private readonly _curveVerticalDown: CurveMapper;\n  private readonly _curveVerticalUp: CurveMapper;\n\n  private readonly _blendShapeProxy: VRMBlendShapeProxy;\n\n  /**\n   * Create a new VRMLookAtBlendShapeApplyer.\n   *\n   * @param blendShapeProxy A [[VRMBlendShapeProxy]] used by this applier\n   * @param curveHorizontal A [[CurveMapper]] used for transverse direction\n   * @param curveVerticalDown A [[CurveMapper]] used for down direction\n   * @param curveVerticalUp A [[CurveMapper]] used for up direction\n   */\n  constructor(\n    blendShapeProxy: VRMBlendShapeProxy,\n    curveHorizontal: CurveMapper,\n    curveVerticalDown: CurveMapper,\n    curveVerticalUp: CurveMapper,\n  ) {\n    super();\n\n    this._curveHorizontal = curveHorizontal;\n    this._curveVerticalDown = curveVerticalDown;\n    this._curveVerticalUp = curveVerticalUp;\n\n    this._blendShapeProxy = blendShapeProxy;\n  }\n\n  public name(): VRMSchema.FirstPersonLookAtTypeName {\n    return VRMSchema.FirstPersonLookAtTypeName.BlendShape;\n  }\n\n  public lookAt(euler: THREE.Euler): void {\n    const srcX = euler.x;\n    const srcY = euler.y;\n\n    if (srcX < 0.0) {\n      this._blendShapeProxy.setValue(VRMSchema.BlendShapePresetName.Lookup, 0.0);\n      this._blendShapeProxy.setValue(VRMSchema.BlendShapePresetName.Lookdown, this._curveVerticalDown.map(-srcX));\n    } else {\n      this._blendShapeProxy.setValue(VRMSchema.BlendShapePresetName.Lookdown, 0.0);\n      this._blendShapeProxy.setValue(VRMSchema.BlendShapePresetName.Lookup, this._curveVerticalUp.map(srcX));\n    }\n\n    if (srcY < 0.0) {\n      this._blendShapeProxy.setValue(VRMSchema.BlendShapePresetName.Lookleft, 0.0);\n      this._blendShapeProxy.setValue(VRMSchema.BlendShapePresetName.Lookright, this._curveHorizontal.map(-srcY));\n    } else {\n      this._blendShapeProxy.setValue(VRMSchema.BlendShapePresetName.Lookright, 0.0);\n      this._blendShapeProxy.setValue(VRMSchema.BlendShapePresetName.Lookleft, this._curveHorizontal.map(srcY));\n    }\n  }\n}\n","import * as THREE from 'three';\nimport { VRMHumanoid } from '../humanoid';\nimport { GLTFNode, VRMSchema } from '../types';\nimport { CurveMapper } from './CurveMapper';\nimport { VRMLookAtApplyer } from './VRMLookAtApplyer';\nimport { VRMLookAtHead } from './VRMLookAtHead';\n\nconst _euler = new THREE.Euler(0.0, 0.0, 0.0, VRMLookAtHead.EULER_ORDER);\n\n/**\n * This class is used by [[VRMLookAtHead]], applies look at direction to eye bones of a VRM.\n */\nexport class VRMLookAtBoneApplyer extends VRMLookAtApplyer {\n  public readonly type = VRMSchema.FirstPersonLookAtTypeName.Bone;\n\n  private readonly _curveHorizontalInner: CurveMapper;\n  private readonly _curveHorizontalOuter: CurveMapper;\n  private readonly _curveVerticalDown: CurveMapper;\n  private readonly _curveVerticalUp: CurveMapper;\n\n  private readonly _leftEye: GLTFNode | null;\n  private readonly _rightEye: GLTFNode | null;\n\n  /**\n   * Create a new VRMLookAtBoneApplyer.\n   *\n   * @param humanoid A [[VRMHumanoid]] used by this applier\n   * @param curveHorizontalInner A [[CurveMapper]] used for inner transverse direction\n   * @param curveHorizontalOuter A [[CurveMapper]] used for outer transverse direction\n   * @param curveVerticalDown A [[CurveMapper]] used for down direction\n   * @param curveVerticalUp A [[CurveMapper]] used for up direction\n   */\n  constructor(\n    humanoid: VRMHumanoid,\n    curveHorizontalInner: CurveMapper,\n    curveHorizontalOuter: CurveMapper,\n    curveVerticalDown: CurveMapper,\n    curveVerticalUp: CurveMapper,\n  ) {\n    super();\n\n    this._curveHorizontalInner = curveHorizontalInner;\n    this._curveHorizontalOuter = curveHorizontalOuter;\n    this._curveVerticalDown = curveVerticalDown;\n    this._curveVerticalUp = curveVerticalUp;\n\n    this._leftEye = humanoid.getBoneNode(VRMSchema.HumanoidBoneName.LeftEye);\n    this._rightEye = humanoid.getBoneNode(VRMSchema.HumanoidBoneName.RightEye);\n  }\n\n  public lookAt(euler: THREE.Euler): void {\n    const srcX = euler.x;\n    const srcY = euler.y;\n\n    // left\n    if (this._leftEye) {\n      if (srcX < 0.0) {\n        _euler.x = -this._curveVerticalDown.map(-srcX);\n      } else {\n        _euler.x = this._curveVerticalUp.map(srcX);\n      }\n\n      if (srcY < 0.0) {\n        _euler.y = -this._curveHorizontalInner.map(-srcY);\n      } else {\n        _euler.y = this._curveHorizontalOuter.map(srcY);\n      }\n\n      this._leftEye.quaternion.setFromEuler(_euler);\n    }\n\n    // right\n    if (this._rightEye) {\n      if (srcX < 0.0) {\n        _euler.x = -this._curveVerticalDown.map(-srcX);\n      } else {\n        _euler.x = this._curveVerticalUp.map(srcX);\n      }\n\n      if (srcY < 0.0) {\n        _euler.y = -this._curveHorizontalOuter.map(-srcY);\n      } else {\n        _euler.y = this._curveHorizontalInner.map(srcY);\n      }\n\n      this._rightEye.quaternion.setFromEuler(_euler);\n    }\n  }\n}\n","import * as THREE from 'three';\nimport { VRMFirstPerson } from '../firstperson/VRMFirstPerson';\nimport { getWorldQuaternionLite } from '../utils/math';\nimport { VRMLookAtApplyer } from './VRMLookAtApplyer';\n\nconst VECTOR3_FRONT = Object.freeze(new THREE.Vector3(0.0, 0.0, -1.0));\n\nconst _v3A = new THREE.Vector3();\nconst _v3B = new THREE.Vector3();\nconst _v3C = new THREE.Vector3();\nconst _quat = new THREE.Quaternion();\n\n/**\n * A class represents look at of a VRM.\n */\nexport class VRMLookAtHead {\n  public static readonly EULER_ORDER = 'YXZ'; // yaw-pitch-roll\n\n  /**\n   * Associated [[VRMFirstPerson]], will be used for direction calculation.\n   */\n  public readonly firstPerson: VRMFirstPerson;\n\n  /**\n   * Associated [[VRMLookAtApplyer]], its look at direction will be applied to the model using this applier.\n   */\n  public readonly applyer?: VRMLookAtApplyer;\n\n  /**\n   * If this is true, its look at direction will be updated automatically by calling [[VRMLookAtHead.update]] (which is called from [[VRM.update]]).\n   *\n   * See also: [[VRMLookAtHead.target]]\n   */\n  public autoUpdate = true;\n\n  /**\n   * The target object of the look at.\n   * Note that it does not make any sense if [[VRMLookAtHead.autoUpdate]] is disabled.\n   */\n  public target?: THREE.Object3D;\n\n  protected _euler: THREE.Euler = new THREE.Euler(0.0, 0.0, 0.0, VRMLookAtHead.EULER_ORDER);\n\n  /**\n   * Create a new VRMLookAtHead.\n   *\n   * @param firstPerson A [[VRMFirstPerson]] that will be associated with this new VRMLookAtHead\n   * @param applyer A [[VRMLookAtApplyer]] that will be associated with this new VRMLookAtHead\n   */\n  constructor(firstPerson: VRMFirstPerson, applyer?: VRMLookAtApplyer) {\n    this.firstPerson = firstPerson;\n    this.applyer = applyer;\n  }\n\n  /**\n   * Get its look at direction in world coordinate.\n   *\n   * @param target A target `THREE.Vector3`\n   */\n  public getLookAtWorldDirection(target: THREE.Vector3): THREE.Vector3 {\n    const rot = getWorldQuaternionLite(this.firstPerson.firstPersonBone, _quat);\n    return target\n      .copy(VECTOR3_FRONT)\n      .applyEuler(this._euler)\n      .applyQuaternion(rot);\n  }\n\n  /**\n   * Set its look at position.\n   * Note that its result will be instantly overwritten if [[VRMLookAtHead.autoUpdate]] is enabled.\n   *\n   * @param position A target position\n   */\n  public lookAt(position: THREE.Vector3): void {\n    this._calcEuler(this._euler, position);\n\n    if (this.applyer) {\n      this.applyer.lookAt(this._euler);\n    }\n  }\n\n  /**\n   * Update the VRMLookAtHead.\n   * If [[VRMLookAtHead.autoUpdate]] is disabled, it will do nothing.\n   *\n   * @param delta deltaTime\n   */\n  public update(delta: number): void {\n    if (this.target && this.autoUpdate) {\n      this.lookAt(this.target.getWorldPosition(_v3A));\n\n      if (this.applyer) {\n        this.applyer.lookAt(this._euler);\n      }\n    }\n  }\n\n  protected _calcEuler(target: THREE.Euler, position: THREE.Vector3): THREE.Euler {\n    const headPosition = this.firstPerson.getFirstPersonWorldPosition(_v3B);\n\n    // Look at direction in world coordinate\n    const lookAtDir = _v3C\n      .copy(position)\n      .sub(headPosition)\n      .normalize();\n\n    // Transform the direction into local coordinate from the first person bone\n    lookAtDir.applyQuaternion(getWorldQuaternionLite(this.firstPerson.firstPersonBone, _quat).inverse());\n\n    // convert the direction into euler\n    target.x = Math.atan2(lookAtDir.y, Math.sqrt(lookAtDir.x * lookAtDir.x + lookAtDir.z * lookAtDir.z));\n    target.y = Math.atan2(-lookAtDir.x, -lookAtDir.z);\n\n    return target;\n  }\n}\n","import * as THREE from 'three';\nimport { VRMBlendShapeProxy } from '../blendshape';\nimport { VRMFirstPerson } from '../firstperson';\nimport { VRMHumanoid } from '../humanoid';\nimport { VRMSchema } from '../types';\nimport { CurveMapper } from './CurveMapper';\nimport { VRMLookAtApplyer } from './VRMLookAtApplyer';\nimport { VRMLookAtBlendShapeApplyer } from './VRMLookAtBlendShapeApplyer';\nimport { VRMLookAtBoneApplyer } from './VRMLookAtBoneApplyer';\nimport { VRMLookAtHead } from './VRMLookAtHead';\n\n/**\n * An importer that imports a [[VRMLookAtHead]] from a VRM extension of a GLTF.\n */\nexport class VRMLookAtImporter {\n  /**\n   * Import a [[VRMLookAtHead]] from a VRM.\n   *\n   * @param gltf A parsed result of GLTF taken from GLTFLoader\n   * @param blendShapeProxy A [[VRMBlendShapeProxy]] instance that represents the VRM\n   * @param humanoid A [[VRMHumanoid]] instance that represents the VRM\n   */\n  public import(\n    gltf: THREE.GLTF,\n    firstPerson: VRMFirstPerson,\n    blendShapeProxy: VRMBlendShapeProxy,\n    humanoid: VRMHumanoid,\n  ): VRMLookAtHead | null {\n    const vrmExt: VRMSchema.VRM | undefined = gltf.parser.json.extensions && gltf.parser.json.extensions.VRM;\n    if (!vrmExt) {\n      return null;\n    }\n\n    const schemaFirstPerson: VRMSchema.FirstPerson | undefined = vrmExt.firstPerson;\n    if (!schemaFirstPerson) {\n      return null;\n    }\n\n    const applyer = this._importApplyer(schemaFirstPerson, blendShapeProxy, humanoid);\n    return new VRMLookAtHead(firstPerson, applyer || undefined);\n  }\n\n  protected _importApplyer(\n    schemaFirstPerson: VRMSchema.FirstPerson,\n    blendShapeProxy: VRMBlendShapeProxy,\n    humanoid: VRMHumanoid,\n  ): VRMLookAtApplyer | null {\n    const lookAtHorizontalInner = schemaFirstPerson.lookAtHorizontalInner;\n    const lookAtHorizontalOuter = schemaFirstPerson.lookAtHorizontalOuter;\n    const lookAtVerticalDown = schemaFirstPerson.lookAtVerticalDown;\n    const lookAtVerticalUp = schemaFirstPerson.lookAtVerticalUp;\n\n    switch (schemaFirstPerson.lookAtTypeName) {\n      case VRMSchema.FirstPersonLookAtTypeName.Bone: {\n        if (\n          lookAtHorizontalInner === undefined ||\n          lookAtHorizontalOuter === undefined ||\n          lookAtVerticalDown === undefined ||\n          lookAtVerticalUp === undefined\n        ) {\n          return null;\n        } else {\n          return new VRMLookAtBoneApplyer(\n            humanoid,\n            this._importCurveMapperBone(lookAtHorizontalInner),\n            this._importCurveMapperBone(lookAtHorizontalOuter),\n            this._importCurveMapperBone(lookAtVerticalDown),\n            this._importCurveMapperBone(lookAtVerticalUp),\n          );\n        }\n      }\n      case VRMSchema.FirstPersonLookAtTypeName.BlendShape: {\n        if (lookAtHorizontalOuter === undefined || lookAtVerticalDown === undefined || lookAtVerticalUp === undefined) {\n          return null;\n        } else {\n          return new VRMLookAtBlendShapeApplyer(\n            blendShapeProxy,\n            this._importCurveMapperBlendShape(lookAtHorizontalOuter),\n            this._importCurveMapperBlendShape(lookAtVerticalDown),\n            this._importCurveMapperBlendShape(lookAtVerticalUp),\n          );\n        }\n      }\n      default: {\n        return null;\n      }\n    }\n  }\n\n  private _importCurveMapperBone(map: VRMSchema.FirstPersonDegreeMap): CurveMapper {\n    return new CurveMapper(\n      typeof map.xRange === 'number' ? THREE.Math.DEG2RAD * map.xRange : undefined,\n      typeof map.yRange === 'number' ? THREE.Math.DEG2RAD * map.yRange : undefined,\n      map.curve,\n    );\n  }\n\n  private _importCurveMapperBlendShape(map: VRMSchema.FirstPersonDegreeMap): CurveMapper {\n    return new CurveMapper(\n      typeof map.xRange === 'number' ? THREE.Math.DEG2RAD * map.xRange : undefined,\n      map.yRange,\n      map.curve,\n    );\n  }\n}\n","export * from './CurveMapper';\nexport * from './VRMLookAtApplyer';\nexport * from './VRMLookAtBlendShapeApplyer';\nexport * from './VRMLookAtBoneApplyer';\nexport * from './VRMLookAtHead';\nexport * from './VRMLookAtImporter';\n","/* tslint:disable:member-ordering */\n\nimport * as THREE from 'three';\nimport { getTexelDecodingFunction } from './getTexelDecodingFunction';\nimport vertexShader from './shaders/mtoon.vert';\nimport fragmentShader from './shaders/mtoon.frag';\n\nconst TAU = 2.0 * Math.PI;\n\nexport interface MToonParameters extends THREE.ShaderMaterialParameters {\n  mToonVersion?: number; // _MToonVersion\n\n  cutoff?: number; // _Cutoff\n  color?: THREE.Vector4; // rgb of _Color\n  shadeColor?: THREE.Vector4; // _ShadeColor\n  map?: THREE.Texture; // _MainTex\n  mainTex?: THREE.Texture; // _MainTex (will be renamed to map)\n  mainTex_ST?: THREE.Vector4; // _MainTex_ST\n  shadeTexture?: THREE.Texture; // _ShadeTexture\n  bumpScale?: number; // _BumpScale\n  normalMap?: THREE.Texture; // _BumpMap\n  bumpMap?: THREE.Texture; // _BumpMap (will be renamed to normalMap)\n  receiveShadowRate?: number; // _ReceiveShadowRate\n  receiveShadowTexture?: THREE.Texture; // _ReceiveShadowTexture\n  shadingGradeRate?: number; // _ShadingGradeRate\n  shadingGradeTexture?: THREE.Texture; // _ShadingGradeTexture\n  shadeShift?: number; // _ShadeShift\n  shadeToony?: number; // _ShadeToony\n  lightColorAttenuation?: number; // _LightColorAttenuation\n  indirectLightIntensity?: number; // _IndirectLightIntensity\n  rimTexture?: THREE.Texture; // _RimTexture\n  rimColor?: THREE.Vector4; // _RimColor\n  rimLightingMix?: number; // _RimLightingMix\n  rimFresnelPower?: number; // _RimFresnelPower\n  rimLift?: number; // _RimLift\n  sphereAdd?: THREE.Texture; // _SphereAdd\n  emissionColor?: THREE.Vector4; // _EmissionColor\n  emissiveMap?: THREE.Texture; // _EmissionMap\n  emissionMap?: THREE.Texture; // _EmissionMap (will be renamed to emissiveMap)\n  outlineWidthTexture?: THREE.Texture; // _OutlineWidthTexture\n  outlineWidth?: number; // _OutlineWidth\n  outlineScaledMaxDistance?: number; // _OutlineScaledMaxDistance\n  outlineColor?: THREE.Vector4; // _OutlineColor\n  outlineLightingMix?: number; // _OutlineLightingMix\n  uvAnimMaskTexture?: THREE.Texture; // _UvAnimMaskTexture\n  uvAnimScrollX?: number; // _UvAnimScrollX\n  uvAnimScrollY?: number; // _UvAnimScrollY\n  uvAnimRotation?: number; // _uvAnimRotation\n\n  debugMode?: MToonMaterialDebugMode | number; // _DebugMode\n  blendMode?: MToonMaterialRenderMode | number; // _BlendMode\n  outlineWidthMode?: MToonMaterialOutlineWidthMode | number; // OutlineWidthMode\n  outlineColorMode?: MToonMaterialOutlineColorMode | number; // OutlineColorMode\n  cullMode?: MToonMaterialCullMode | number; // _CullMode\n  outlineCullMode?: MToonMaterialCullMode | number; // _OutlineCullMode\n  srcBlend?: number; // _SrcBlend\n  dstBlend?: number; // _DstBlend\n  zWrite?: number; // _ZWrite (will be renamed to depthWrite)\n\n  isOutline?: boolean;\n}\n\nexport enum MToonMaterialCullMode {\n  Off,\n  Front,\n  Back,\n}\n\nexport enum MToonMaterialDebugMode {\n  None,\n  Normal,\n  LitShadeRate,\n  UV,\n}\n\nexport enum MToonMaterialOutlineColorMode {\n  FixedColor,\n  MixedLighting,\n}\n\nexport enum MToonMaterialOutlineWidthMode {\n  None,\n  WorldCoordinates,\n  ScreenCoordinates,\n}\n\nexport enum MToonMaterialRenderMode {\n  Opaque,\n  Cutout,\n  Transparent,\n  TransparentWithZWrite,\n}\n\n/**\n * MToon is a material specification that has various features.\n * The spec and implementation are originally founded for Unity engine and this is a port of the material.\n *\n * See: https://github.com/Santarh/MToon\n */\nexport class MToonMaterial extends THREE.ShaderMaterial {\n  /**\n   * Readonly boolean that indicates this is a [[MToonMaterial]].\n   */\n  public readonly isMToonMaterial: boolean = true;\n\n  public cutoff = 0.5; // _Cutoff\n  public color: THREE.Vector4 = new THREE.Vector4(1.0, 1.0, 1.0, 1.0); // _Color\n  public shadeColor: THREE.Vector4 = new THREE.Vector4(0.97, 0.81, 0.86, 1.0); // _ShadeColor\n  public map: THREE.Texture | null = null; // _MainTex\n  public mainTex_ST: THREE.Vector4 = new THREE.Vector4(0.0, 0.0, 1.0, 1.0); // _MainTex_ST\n  public shadeTexture: THREE.Texture | null = null; // _ShadeTexture\n  // public shadeTexture_ST: THREE.Vector4 = new THREE.Vector4(0.0, 0.0, 1.0, 1.0); // _ShadeTexture_ST (unused)\n  public bumpScale = 1.0; // _BumpScale\n  public normalMap: THREE.Texture | null = null; // _BumpMap. again, THIS IS _BumpMap\n  // public bumpMap_ST: THREE.Vector4 = new THREE.Vector4(0.0, 0.0, 1.0, 1.0); // _BumpMap_ST (unused)\n  public receiveShadowRate = 1.0; // _ReceiveShadowRate\n  public receiveShadowTexture: THREE.Texture | null = null; // _ReceiveShadowTexture\n  // public receiveShadowTexture_ST: THREE.Vector4 = new THREE.Vector4(0.0, 0.0, 1.0, 1.0); // _ReceiveShadowTexture_ST (unused)\n  public shadingGradeRate = 1.0; // _ShadingGradeRate\n  public shadingGradeTexture: THREE.Texture | null = null; // _ShadingGradeTexture\n  // public shadingGradeTexture_ST: THREE.Vector4 = new THREE.Vector4(0.0, 0.0, 1.0, 1.0); // _ShadingGradeTexture_ST (unused)\n  public shadeShift = 0.0; // _ShadeShift\n  public shadeToony = 0.9; // _ShadeToony\n  public lightColorAttenuation = 0.0; // _LightColorAttenuation\n  public indirectLightIntensity = 0.1; // _IndirectLightIntensity\n  public rimTexture: THREE.Texture | null = null; // _RimTexture\n  public rimColor: THREE.Vector4 = new THREE.Vector4(0.0, 0.0, 0.0, 1.0); // _RimColor\n  public rimLightingMix = 0.0; // _RimLightingMix\n  public rimFresnelPower = 1.0; // _RimFresnelPower\n  public rimLift = 0.0; // _RimLift\n  public sphereAdd: THREE.Texture | null = null; // _SphereAdd\n  // public sphereAdd_ST: THREE.Vector4 = new THREE.Vector4(0.0, 0.0, 1.0, 1.0); // _SphereAdd_ST (unused)\n  public emissionColor: THREE.Vector4 = new THREE.Vector4(0.0, 0.0, 0.0, 1.0); // _EmissionColor\n  public emissiveMap: THREE.Texture | null = null; // _EmissionMap\n  // public emissionMap_ST: THREE.Vector4 = new THREE.Vector4(0.0, 0.0, 1.0, 1.0); // _EmissionMap_ST (unused)\n  public outlineWidthTexture: THREE.Texture | null = null; // _OutlineWidthTexture\n  // public outlineWidthTexture_ST: THREE.Vector4 = new THREE.Vector4(0.0, 0.0, 1.0, 1.0); // _OutlineWidthTexture_ST (unused)\n  public outlineWidth = 0.5; // _OutlineWidth\n  public outlineScaledMaxDistance = 1.0; // _OutlineScaledMaxDistance\n  public outlineColor: THREE.Vector4 = new THREE.Vector4(0.0, 0.0, 0.0, 1.0); // _OutlineColor\n  public outlineLightingMix = 1.0; // _OutlineLightingMix\n  public uvAnimMaskTexture: THREE.Texture | null = null; // _UvAnimMaskTexture\n  public uvAnimScrollX = 0.0; // _UvAnimScrollX\n  public uvAnimScrollY = 0.0; // _UvAnimScrollY\n  public uvAnimRotation = 0.0; // _uvAnimRotation\n\n  public shouldApplyUniforms = true; // when this is true, applyUniforms effects\n\n  private _debugMode: MToonMaterialDebugMode = MToonMaterialDebugMode.None; // _DebugMode\n  private _blendMode: MToonMaterialRenderMode = MToonMaterialRenderMode.Opaque; // _BlendMode\n  private _outlineWidthMode: MToonMaterialOutlineWidthMode = MToonMaterialOutlineWidthMode.None; // _OutlineWidthMode\n  private _outlineColorMode: MToonMaterialOutlineColorMode = MToonMaterialOutlineColorMode.FixedColor; // _OutlineColorMode\n  private _cullMode: MToonMaterialCullMode = MToonMaterialCullMode.Back; // _CullMode\n  private _outlineCullMode: MToonMaterialCullMode = MToonMaterialCullMode.Front; // _OutlineCullMode\n  // public srcBlend: number = 1.0; // _SrcBlend (is not supported)\n  // public dstBlend: number = 0.0; // _DstBlend (is not supported)\n  // public zWrite: number = 1.0; // _ZWrite (will be converted to depthWrite)\n\n  private _isOutline = false;\n\n  private readonly _colorSpaceGamma: boolean;\n\n  private _uvAnimOffsetX = 0.0;\n  private _uvAnimOffsetY = 0.0;\n  private _uvAnimPhase = 0.0;\n\n  // TODO: colorSpaceGamma\n  constructor(colorSpaceGamma: boolean, parameters?: MToonParameters) {\n    super();\n\n    this._colorSpaceGamma = colorSpaceGamma;\n\n    if (parameters === undefined) {\n      parameters = {};\n    }\n\n    // == these parameter has no compatibility with this implementation ========\n    [\n      'mToonVersion',\n      'shadeTexture_ST',\n      'bumpMap_ST',\n      'receiveShadowTexture_ST',\n      'shadingGradeTexture_ST',\n      'sphereAdd_ST',\n      'emissionMap_ST',\n      'outlineWidthTexture_ST',\n      'srcBlend',\n      'dstBlend',\n    ].forEach((key) => {\n      if ((parameters as any)[key] !== undefined) {\n        // console.warn(`THREE.${this.type}: The parameter \"${key}\" is not supported.`);\n        delete (parameters as any)[key];\n      }\n    });\n\n    // == enabling bunch of stuff ==============================================\n    parameters.fog = true;\n    parameters.lights = true;\n    parameters.clipping = true;\n\n    parameters.skinning = parameters.skinning || false;\n    parameters.morphTargets = parameters.morphTargets || false;\n    parameters.morphNormals = parameters.morphNormals || false;\n\n    // == uniforms =============================================================\n    parameters.uniforms = THREE.UniformsUtils.merge([\n      THREE.UniformsLib.common, // map\n      THREE.UniformsLib.normalmap, // normalMap\n      THREE.UniformsLib.emissivemap, // emissiveMap\n      THREE.UniformsLib.fog,\n      THREE.UniformsLib.lights,\n      {\n        cutoff: { value: 0.5 },\n        color: { value: new THREE.Color(1.0, 1.0, 1.0) },\n        colorAlpha: { value: 1.0 },\n        shadeColor: { value: new THREE.Color(0.97, 0.81, 0.86) },\n        mainTex_ST: { value: new THREE.Vector4(0.0, 0.0, 1.0, 1.0) },\n        shadeTexture: { value: null },\n        bumpScale: { value: 1.0 },\n        receiveShadowRate: { value: 1.0 },\n        receiveShadowTexture: { value: null },\n        shadingGradeRate: { value: 1.0 },\n        shadingGradeTexture: { value: null },\n        shadeShift: { value: 0.0 },\n        shadeToony: { value: 0.9 },\n        lightColorAttenuation: { value: 0.0 },\n        indirectLightIntensity: { value: 0.1 },\n        rimTexture: { value: null },\n        rimColor: { value: new THREE.Color(0.0, 0.0, 0.0) },\n        rimLightingMix: { value: 0.0 },\n        rimFresnelPower: { value: 1.0 },\n        rimLift: { value: 0.0 },\n        sphereAdd: { value: null },\n        emissionColor: { value: new THREE.Color(0.0, 0.0, 0.0) },\n        outlineWidthTexture: { value: null },\n        outlineWidth: { value: 0.5 },\n        outlineScaledMaxDistance: { value: 1.0 },\n        outlineColor: { value: new THREE.Color(0.0, 0.0, 0.0) },\n        outlineLightingMix: { value: 1.0 },\n        uvAnimMaskTexture: { value: null },\n        uvAnimOffsetX: { value: 0.0 },\n        uvAnimOffsetY: { value: 0.0 },\n        uvAnimTheta: { value: 0.0 },\n      },\n    ]);\n\n    // == finally compile the shader program ===================================\n    this.setValues(parameters);\n\n    // == update shader stuff ==================================================\n    this._updateShaderCode();\n    this._applyUniforms();\n  }\n\n  get mainTex(): THREE.Texture | null {\n    return this.map;\n  }\n\n  set mainTex(t: THREE.Texture | null) {\n    this.map = t;\n  }\n\n  get bumpMap(): THREE.Texture | null {\n    return this.normalMap;\n  }\n\n  set bumpMap(t: THREE.Texture | null) {\n    this.normalMap = t;\n  }\n\n  get emissionMap(): THREE.Texture | null {\n    return this.emissiveMap;\n  }\n\n  set emissionMap(t: THREE.Texture | null) {\n    this.emissiveMap = t;\n  }\n\n  get blendMode(): MToonMaterialRenderMode {\n    return this._blendMode;\n  }\n\n  set blendMode(m: MToonMaterialRenderMode) {\n    this._blendMode = m;\n\n    this.depthWrite = this._blendMode !== MToonMaterialRenderMode.Transparent;\n    this.transparent =\n      this._blendMode === MToonMaterialRenderMode.Transparent ||\n      this._blendMode === MToonMaterialRenderMode.TransparentWithZWrite;\n    this._updateShaderCode();\n  }\n\n  get debugMode(): MToonMaterialDebugMode {\n    return this._debugMode;\n  }\n\n  set debugMode(m: MToonMaterialDebugMode) {\n    this._debugMode = m;\n\n    this._updateShaderCode();\n  }\n\n  get outlineWidthMode(): MToonMaterialOutlineWidthMode {\n    return this._outlineWidthMode;\n  }\n\n  set outlineWidthMode(m: MToonMaterialOutlineWidthMode) {\n    this._outlineWidthMode = m;\n\n    this._updateShaderCode();\n  }\n\n  get outlineColorMode(): MToonMaterialOutlineColorMode {\n    return this._outlineColorMode;\n  }\n\n  set outlineColorMode(m: MToonMaterialOutlineColorMode) {\n    this._outlineColorMode = m;\n\n    this._updateShaderCode();\n  }\n\n  get cullMode(): MToonMaterialCullMode {\n    return this._cullMode;\n  }\n\n  set cullMode(m: MToonMaterialCullMode) {\n    this._cullMode = m;\n\n    this._updateCullFace();\n  }\n\n  get outlineCullMode(): MToonMaterialCullMode {\n    return this._outlineCullMode;\n  }\n\n  set outlineCullMode(m: MToonMaterialCullMode) {\n    this._outlineCullMode = m;\n\n    this._updateCullFace();\n  }\n\n  get zWrite(): number {\n    return this.depthWrite ? 1 : 0;\n  }\n\n  set zWrite(i: number) {\n    this.depthWrite = 0.5 <= i;\n  }\n\n  get isOutline(): boolean {\n    return this._isOutline;\n  }\n\n  set isOutline(b: boolean) {\n    this._isOutline = b;\n\n    this._updateShaderCode();\n    this._updateCullFace();\n  }\n\n  /**\n   * Update this material.\n   * Usually this will be called via [[VRM.update]] so you don't have to call this manually.\n   *\n   * @param delta deltaTime since last update\n   */\n  public updateVRMMaterials(delta: number): void {\n    this._uvAnimOffsetX = this._uvAnimOffsetX + delta * this.uvAnimScrollX;\n    this._uvAnimOffsetY = this._uvAnimOffsetY + delta * this.uvAnimScrollY;\n    this._uvAnimPhase = this._uvAnimPhase + delta * this.uvAnimRotation;\n\n    this._applyUniforms();\n  }\n\n  public copy(source: this): this {\n    super.copy(source);\n\n    // == copy members =========================================================\n    this.cutoff = source.cutoff;\n    this.color.copy(source.color);\n    this.shadeColor.copy(source.shadeColor);\n    this.map = source.map;\n    this.mainTex_ST.copy(source.mainTex_ST);\n    this.shadeTexture = source.shadeTexture;\n    this.bumpScale = source.bumpScale;\n    this.normalMap = source.normalMap;\n    this.receiveShadowRate = source.receiveShadowRate;\n    this.receiveShadowTexture = source.receiveShadowTexture;\n    this.shadingGradeRate = source.shadingGradeRate;\n    this.shadingGradeTexture = source.shadingGradeTexture;\n    this.shadeShift = source.shadeShift;\n    this.shadeToony = source.shadeToony;\n    this.lightColorAttenuation = source.lightColorAttenuation;\n    this.indirectLightIntensity = source.indirectLightIntensity;\n    this.rimTexture = source.rimTexture;\n    this.rimColor.copy(source.rimColor);\n    this.rimLightingMix = source.rimLightingMix;\n    this.rimFresnelPower = source.rimFresnelPower;\n    this.rimLift = source.rimLift;\n    this.sphereAdd = source.sphereAdd;\n    this.emissionColor.copy(source.emissionColor);\n    this.emissiveMap = source.emissiveMap;\n    this.outlineWidthTexture = source.outlineWidthTexture;\n    this.outlineWidth = source.outlineWidth;\n    this.outlineScaledMaxDistance = source.outlineScaledMaxDistance;\n    this.outlineColor.copy(source.outlineColor);\n    this.outlineLightingMix = source.outlineLightingMix;\n    this.uvAnimMaskTexture = source.uvAnimMaskTexture;\n    this.uvAnimScrollX = source.uvAnimScrollX;\n    this.uvAnimScrollY = source.uvAnimScrollY;\n    this.uvAnimRotation = source.uvAnimRotation;\n\n    this.debugMode = source.debugMode;\n    this.blendMode = source.blendMode;\n    this.outlineWidthMode = source.outlineWidthMode;\n    this.outlineColorMode = source.outlineColorMode;\n    this.cullMode = source.cullMode;\n    this.outlineCullMode = source.outlineCullMode;\n\n    this.isOutline = source.isOutline;\n\n    return this;\n  }\n\n  /**\n   * Apply updated uniform variables.\n   */\n  private _applyUniforms(): void {\n    this.uniforms.uvAnimOffsetX.value = this._uvAnimOffsetX;\n    this.uniforms.uvAnimOffsetY.value = this._uvAnimOffsetY;\n    this.uniforms.uvAnimTheta.value = TAU * this._uvAnimPhase;\n\n    if (!this.shouldApplyUniforms) {\n      return;\n    }\n    this.shouldApplyUniforms = false;\n\n    this.uniforms.cutoff.value = this.cutoff;\n    this.uniforms.color.value.setRGB(this.color.x, this.color.y, this.color.z);\n    if (!this._colorSpaceGamma) {\n      this.uniforms.color.value.convertSRGBToLinear();\n    }\n    this.uniforms.colorAlpha.value = this.color.w;\n    this.uniforms.shadeColor.value.setRGB(this.shadeColor.x, this.shadeColor.y, this.shadeColor.z);\n    if (!this._colorSpaceGamma) {\n      this.uniforms.shadeColor.value.convertSRGBToLinear();\n    }\n    this.uniforms.map.value = this.map;\n    this.uniforms.mainTex_ST.value.copy(this.mainTex_ST);\n    this.uniforms.shadeTexture.value = this.shadeTexture;\n    this.uniforms.bumpScale.value = this.bumpScale;\n    this.uniforms.normalMap.value = this.normalMap;\n    this.uniforms.receiveShadowRate.value = this.receiveShadowRate;\n    this.uniforms.receiveShadowTexture.value = this.receiveShadowTexture;\n    this.uniforms.shadingGradeRate.value = this.shadingGradeRate;\n    this.uniforms.shadingGradeTexture.value = this.shadingGradeTexture;\n    this.uniforms.shadeShift.value = this.shadeShift;\n    this.uniforms.shadeToony.value = this.shadeToony;\n    this.uniforms.lightColorAttenuation.value = this.lightColorAttenuation;\n    this.uniforms.indirectLightIntensity.value = this.indirectLightIntensity;\n    this.uniforms.rimTexture.value = this.rimTexture;\n    this.uniforms.rimColor.value.setRGB(this.rimColor.x, this.rimColor.y, this.rimColor.z);\n    if (!this._colorSpaceGamma) {\n      this.uniforms.rimColor.value.convertSRGBToLinear();\n    }\n    this.uniforms.rimLightingMix.value = this.rimLightingMix;\n    this.uniforms.rimFresnelPower.value = this.rimFresnelPower;\n    this.uniforms.rimLift.value = this.rimLift;\n    this.uniforms.sphereAdd.value = this.sphereAdd;\n    this.uniforms.emissionColor.value.setRGB(this.emissionColor.x, this.emissionColor.y, this.emissionColor.z);\n    if (!this._colorSpaceGamma) {\n      this.uniforms.emissionColor.value.convertSRGBToLinear();\n    }\n    this.uniforms.emissiveMap.value = this.emissiveMap;\n    this.uniforms.outlineWidthTexture.value = this.outlineWidthTexture;\n    this.uniforms.outlineWidth.value = this.outlineWidth;\n    this.uniforms.outlineScaledMaxDistance.value = this.outlineScaledMaxDistance;\n    this.uniforms.outlineColor.value.setRGB(this.outlineColor.x, this.outlineColor.y, this.outlineColor.z);\n    if (!this._colorSpaceGamma) {\n      this.uniforms.outlineColor.value.convertSRGBToLinear();\n    }\n    this.uniforms.outlineLightingMix.value = this.outlineLightingMix;\n    this.uniforms.uvAnimMaskTexture.value = this.uvAnimMaskTexture;\n\n    this._updateCullFace();\n  }\n\n  private _updateShaderCode(): void {\n    this.defines = {\n      OUTLINE: this._isOutline,\n      BLENDMODE_OPAQUE: this._blendMode === MToonMaterialRenderMode.Opaque,\n      BLENDMODE_CUTOUT: this._blendMode === MToonMaterialRenderMode.Cutout,\n      BLENDMODE_TRANSPARENT:\n        this._blendMode === MToonMaterialRenderMode.Transparent ||\n        this._blendMode === MToonMaterialRenderMode.TransparentWithZWrite,\n      USE_SHADETEXTURE: this.shadeTexture !== null,\n      USE_RECEIVESHADOWTEXTURE: this.receiveShadowTexture !== null,\n      USE_SHADINGGRADETEXTURE: this.shadingGradeTexture !== null,\n      USE_RIMTEXTURE: this.rimTexture !== null,\n      USE_SPHEREADD: this.sphereAdd !== null,\n      USE_OUTLINEWIDTHTEXTURE: this.outlineWidthTexture !== null,\n      USE_UVANIMMASKTEXTURE: this.uvAnimMaskTexture !== null,\n      DEBUG_NORMAL: this._debugMode === MToonMaterialDebugMode.Normal,\n      DEBUG_LITSHADERATE: this._debugMode === MToonMaterialDebugMode.LitShadeRate,\n      DEBUG_UV: this._debugMode === MToonMaterialDebugMode.UV,\n      OUTLINE_WIDTH_WORLD: this._outlineWidthMode === MToonMaterialOutlineWidthMode.WorldCoordinates,\n      OUTLINE_WIDTH_SCREEN: this._outlineWidthMode === MToonMaterialOutlineWidthMode.ScreenCoordinates,\n      OUTLINE_COLOR_FIXED: this._outlineColorMode === MToonMaterialOutlineColorMode.FixedColor,\n      OUTLINE_COLOR_MIXED: this._outlineColorMode === MToonMaterialOutlineColorMode.MixedLighting,\n    };\n\n    // == texture encodings ====================================================\n    const encodings =\n      (this.shadeTexture !== null\n        ? getTexelDecodingFunction('shadeTextureTexelToLinear', this.shadeTexture.encoding) + '\\n'\n        : '') +\n      (this.sphereAdd !== null\n        ? getTexelDecodingFunction('sphereAddTexelToLinear', this.sphereAdd.encoding) + '\\n'\n        : '');\n\n    // == generate shader code =================================================\n    this.vertexShader = vertexShader;\n    this.fragmentShader = encodings + fragmentShader;\n\n    // == set needsUpdate flag =================================================\n    this.needsUpdate = true;\n  }\n\n  private _updateCullFace(): void {\n    if (!this.isOutline) {\n      if (this.cullMode === MToonMaterialCullMode.Off) {\n        this.side = THREE.DoubleSide;\n      } else if (this.cullMode === MToonMaterialCullMode.Front) {\n        this.side = THREE.BackSide;\n      } else if (this.cullMode === MToonMaterialCullMode.Back) {\n        this.side = THREE.FrontSide;\n      }\n    } else {\n      if (this.outlineCullMode === MToonMaterialCullMode.Off) {\n        this.side = THREE.DoubleSide;\n      } else if (this.outlineCullMode === MToonMaterialCullMode.Front) {\n        this.side = THREE.BackSide;\n      } else if (this.outlineCullMode === MToonMaterialCullMode.Back) {\n        this.side = THREE.FrontSide;\n      }\n    }\n  }\n}\n","import * as THREE from 'three';\nimport { GLTFMesh, GLTFPrimitive, VRMSchema } from '../types';\nimport { MToonMaterial, MToonMaterialOutlineWidthMode, MToonMaterialRenderMode } from './MToonMaterial';\nimport { VRMUnlitMaterial, VRMUnlitMaterialRenderType } from './VRMUnlitMaterial';\n\n/**\n * Options for a [[VRMMaterialImporter]] instance.\n */\nexport interface VRMMaterialImporterOptions {\n  /**\n   * Whether the workflow should be linear or gamma.\n   *\n   * See also: https://threejs.org/docs/#api/en/renderers/WebGLRenderer.gammaOutput\n   */\n  colorSpaceGamma?: boolean;\n\n  /**\n   * A function that returns a `Promise` of environment map texture.\n   * The importer will attempt to call this function when it have to use an envmap.\n   */\n  requestEnvMap?: () => Promise<THREE.Texture | null>;\n}\n\n/**\n * An importer that imports VRM materials from a VRM extension of a GLTF.\n */\nexport class VRMMaterialImporter {\n  private readonly _colorSpaceGamma: boolean;\n  private readonly _requestEnvMap?: () => Promise<THREE.Texture | null>;\n\n  /**\n   * Create a new VRMMaterialImporter.\n   *\n   * @param options Options of the VRMMaterialImporter\n   */\n  constructor(options: VRMMaterialImporterOptions = {}) {\n    this._colorSpaceGamma = options.colorSpaceGamma || true;\n    this._requestEnvMap = options.requestEnvMap;\n  }\n\n  /**\n   * Convert all the materials of given GLTF based on VRM extension field `materialProperties`.\n   *\n   * @param gltf A parsed result of GLTF taken from GLTFLoader\n   */\n  public async convertGLTFMaterials(gltf: THREE.GLTF): Promise<THREE.Material[] | null> {\n    const vrmExt: VRMSchema.VRM | undefined = gltf.parser.json.extensions && gltf.parser.json.extensions.VRM;\n    if (!vrmExt) {\n      return null;\n    }\n\n    const materialProperties: VRMSchema.Material[] | undefined = vrmExt.materialProperties;\n    if (!materialProperties) {\n      return null;\n    }\n\n    const meshesMap: GLTFMesh[] = await gltf.parser.getDependencies('mesh');\n    const materialList: { [vrmMaterialIndex: number]: { surface: THREE.Material; outline?: THREE.Material } } = {};\n    const materials: THREE.Material[] = []; // result\n\n    await Promise.all(\n      meshesMap.map(async (mesh, meshIndex) => {\n        const primitives: GLTFPrimitive[] =\n          mesh.type === 'Group' ? (mesh.children as GLTFPrimitive[]) : [mesh as GLTFPrimitive];\n        await Promise.all(\n          primitives.map(async (primitive, primitiveIndex) => {\n            // if primitives material is not an array, make it an array\n            if (!Array.isArray(primitive.material)) {\n              primitive.material = [primitive.material];\n              (primitive.geometry as THREE.BufferGeometry).addGroup(\n                0,\n                (primitive.geometry as THREE.BufferGeometry).index.count,\n                0,\n              );\n            }\n\n            // create / push to cache (or pop from cache) vrm materials\n            const vrmMaterialIndex = gltf.parser.json.meshes![meshIndex].primitives[primitiveIndex].material!;\n\n            let props = materialProperties[vrmMaterialIndex];\n            if (!props) {\n              console.warn(\n                `VRMMaterialImporter: There are no material definition for material #${vrmMaterialIndex} on VRM extension.`,\n              );\n              props = { shader: 'VRM_USE_GLTFSHADER' }; // fallback\n            }\n\n            let vrmMaterials: { surface: THREE.Material; outline?: THREE.Material };\n            if (materialList[vrmMaterialIndex]) {\n              vrmMaterials = materialList[vrmMaterialIndex];\n            } else {\n              vrmMaterials = await this.createVRMMaterials(primitive.material[0], props, gltf);\n              materialList[vrmMaterialIndex] = vrmMaterials;\n\n              materials.push(vrmMaterials.surface);\n              if (vrmMaterials.outline) {\n                materials.push(vrmMaterials.outline);\n              }\n            }\n\n            // surface\n            primitive.material[0] = vrmMaterials.surface;\n\n            // envmap\n            if (this._requestEnvMap) {\n              this._requestEnvMap().then((envMap) => {\n                (vrmMaterials.surface as any).envMap = envMap;\n                vrmMaterials.surface.needsUpdate = true;\n              });\n            }\n\n            // render order\n            primitive.renderOrder = props.renderQueue || 2000;\n\n            // outline (\"2 pass shading using groups\" trick here)\n            if (vrmMaterials.outline) {\n              primitive.material[1] = vrmMaterials.outline;\n              (primitive.geometry as THREE.BufferGeometry).addGroup(\n                0,\n                (primitive.geometry as THREE.BufferGeometry).index.count,\n                1,\n              );\n            }\n          }),\n        );\n      }),\n    );\n\n    return materials;\n  }\n\n  public async createVRMMaterials(\n    originalMaterial: THREE.Material,\n    vrmProps: VRMSchema.Material,\n    gltf: THREE.GLTF,\n  ): Promise<{\n    surface: THREE.Material;\n    outline?: THREE.Material;\n  }> {\n    let newSurface: THREE.Material | undefined;\n    let newOutline: THREE.Material | undefined;\n\n    if (vrmProps.shader === 'VRM/MToon') {\n      const params = await this._extractMaterialProperties(originalMaterial, vrmProps, gltf);\n\n      // we need to get rid of these properties\n      ['srcBlend', 'dstBlend', 'isFirstSetup'].forEach((name) => {\n        if (params[name] !== undefined) {\n          delete params[name];\n        }\n      });\n\n      // these textures must be sRGB Encoding, depends on current colorspace\n      ['mainTex', 'shadeTexture', 'emission', 'sphereAdd'].forEach((name) => {\n        if (params[name] !== undefined) {\n          params[name].encoding = this._colorSpaceGamma ? THREE.LinearEncoding : THREE.sRGBEncoding;\n        }\n      });\n\n      // done\n      newSurface = new MToonMaterial(this._colorSpaceGamma, params);\n\n      // outline\n      if (params.outlineWidthMode !== MToonMaterialOutlineWidthMode.None) {\n        params.isOutline = true;\n        newOutline = new MToonMaterial(this._colorSpaceGamma, params);\n      }\n    } else if (vrmProps.shader === 'VRM/UnlitTexture') {\n      // this is very legacy\n      const params = await this._extractMaterialProperties(originalMaterial, vrmProps, gltf);\n      params.renderType = VRMUnlitMaterialRenderType.Opaque;\n      newSurface = new VRMUnlitMaterial(params);\n    } else if (vrmProps.shader === 'VRM/UnlitCutout') {\n      // this is very legacy\n      const params = await this._extractMaterialProperties(originalMaterial, vrmProps, gltf);\n      params.renderType = VRMUnlitMaterialRenderType.Cutout;\n      newSurface = new VRMUnlitMaterial(params);\n    } else if (vrmProps.shader === 'VRM/UnlitTransparent') {\n      // this is very legacy\n      const params = await this._extractMaterialProperties(originalMaterial, vrmProps, gltf);\n      params.renderType = VRMUnlitMaterialRenderType.Transparent;\n      newSurface = new VRMUnlitMaterial(params);\n    } else if (vrmProps.shader === 'VRM/UnlitTransparentZWrite') {\n      // this is very legacy\n      const params = await this._extractMaterialProperties(originalMaterial, vrmProps, gltf);\n      params.renderType = VRMUnlitMaterialRenderType.TransparentWithZWrite;\n      newSurface = new VRMUnlitMaterial(params);\n    } else {\n      if (vrmProps.shader !== 'VRM_USE_GLTFSHADER') {\n        console.warn(`Unknown shader detected: \"${vrmProps.shader}\"`);\n        // then presume as VRM_USE_GLTFSHADER\n      }\n\n      newSurface = this._convertGLTFMaterial(originalMaterial.clone());\n    }\n\n    newSurface.name = originalMaterial.name;\n    newSurface.userData = JSON.parse(JSON.stringify(originalMaterial.userData));\n    newSurface.userData.vrmMaterialProperties = vrmProps;\n\n    if (newOutline) {\n      newOutline.name = originalMaterial.name + ' (Outline)';\n      newOutline.userData = JSON.parse(JSON.stringify(originalMaterial.userData));\n      newOutline.userData.vrmMaterialProperties = vrmProps;\n    }\n\n    return {\n      surface: newSurface,\n      outline: newOutline,\n    };\n  }\n\n  private _renameMaterialProperty(name: string): string {\n    if (name[0] !== '_') {\n      console.warn(`VRMMaterials: Given property name \"${name}\" might be invalid`);\n      return name;\n    }\n    name = name.substring(1);\n\n    if (!/[A-Z]/.test(name[0])) {\n      console.warn(`VRMMaterials: Given property name \"${name}\" might be invalid`);\n      return name;\n    }\n    return name[0].toLowerCase() + name.substring(1);\n  }\n\n  private _convertGLTFMaterial(material: THREE.Material): THREE.Material {\n    if ((material as any).isMeshStandardMaterial) {\n      const mtl = material as THREE.MeshStandardMaterial;\n\n      if (this._colorSpaceGamma) {\n        if (mtl.map) {\n          mtl.map.encoding = THREE.LinearEncoding;\n        }\n        if (mtl.emissiveMap) {\n          mtl.emissiveMap.encoding = THREE.LinearEncoding;\n        }\n      } else {\n        (mtl as any).color.convertSRGBToLinear(); // TODO: `as any` is temporal, since there are no declaration in @types/three\n        (mtl as any).emissive.convertSRGBToLinear(); // TODO: `as any` is temporal, since there are no declaration in @types/three\n      }\n    }\n\n    if ((material as any).isMeshBasicMaterial) {\n      const mtl = material as THREE.MeshBasicMaterial;\n\n      if (this._colorSpaceGamma) {\n        if (mtl.map) {\n          mtl.map.encoding = THREE.LinearEncoding;\n        }\n      } else {\n        (mtl as any).color.convertSRGBToLinear(); // TODO: `as any` is temporal, since there are no declaration in @types/three\n      }\n    }\n\n    return material;\n  }\n\n  private _extractMaterialProperties(\n    originalMaterial: THREE.Material,\n    vrmProps: VRMSchema.Material,\n    gltf: THREE.GLTF,\n  ): Promise<any> {\n    const taskList: Array<Promise<any>> = [];\n    const params: any = {};\n\n    // extract texture properties\n    if (vrmProps.textureProperties) {\n      for (const name of Object.keys(vrmProps.textureProperties)) {\n        const newName = this._renameMaterialProperty(name);\n        const textureIndex = vrmProps.textureProperties[name];\n\n        taskList.push(\n          gltf.parser.getDependency('texture', textureIndex).then((texture: THREE.Texture) => {\n            params[newName] = texture;\n          }),\n        );\n      }\n    }\n\n    // extract float properties\n    if (vrmProps.floatProperties) {\n      for (const name of Object.keys(vrmProps.floatProperties)) {\n        const newName = this._renameMaterialProperty(name);\n        params[newName] = vrmProps.floatProperties[name];\n      }\n    }\n\n    // extract vector (color tbh) properties\n    if (vrmProps.vectorProperties) {\n      for (const name of Object.keys(vrmProps.vectorProperties)) {\n        let newName = this._renameMaterialProperty(name);\n\n        // if this is textureST (same name as texture name itself), add '_ST'\n        // this is my most favorite MToon feature tbh\n        const isTextureST = [\n          '_MainTex',\n          '_ShadeTexture',\n          '_BumpMap',\n          '_ReceiveShadowTexture',\n          '_ShadingGradeTexture',\n          '_SphereAdd',\n          '_EmissionMap',\n          '_OutlineWidthTexture',\n        ].some((textureName) => name === textureName);\n        if (isTextureST) {\n          newName += '_ST';\n        }\n\n        params[newName] = new THREE.Vector4(...vrmProps.vectorProperties[name]);\n      }\n    }\n\n    // TODO: f (https://github.com/dwango/UniVRM/issues/172)\n    if (vrmProps.keywordMap!._ALPHATEST_ON && params.blendMode === MToonMaterialRenderMode.Opaque) {\n      params.blendMode = MToonMaterialRenderMode.Cutout;\n    }\n\n    // set whether it needs skinning and morphing or not\n    params.skinning = (originalMaterial as any).skinning || false;\n    params.morphTargets = (originalMaterial as any).morphTargets || false;\n    params.morphNormals = (originalMaterial as any).morphNormals || false;\n\n    return Promise.all(taskList).then(() => params);\n  }\n}\n","/* tslint:disable:member-ordering */\n\nimport * as THREE from 'three';\nimport vertexShader from './shaders/unlit.vert';\nimport fragmentShader from './shaders/unlit.frag';\n\nexport interface VRMUnlitMaterialParameters extends THREE.ShaderMaterialParameters {\n  cutoff?: number; // _Cutoff\n  map?: THREE.Texture; // _MainTex\n  mainTex?: THREE.Texture; // _MainTex (will be renamed to map)\n  mainTex_ST?: THREE.Vector4; // _MainTex_ST\n\n  renderType?: VRMUnlitMaterialRenderType | number;\n}\n\nexport enum VRMUnlitMaterialRenderType {\n  Opaque,\n  Cutout,\n  Transparent,\n  TransparentWithZWrite,\n}\n\n/**\n * This is a material that is an equivalent of \"VRM/Unlit***\" on VRM spec, those materials are already kinda deprecated though...\n */\nexport class VRMUnlitMaterial extends THREE.ShaderMaterial {\n  /**\n   * Readonly boolean that indicates this is a [[VRMUnlitMaterial]].\n   */\n  public readonly isVRMUnlitMaterial: boolean = true;\n\n  public cutoff = 0.5;\n  public map: THREE.Texture | null = null; // _MainTex\n  public mainTex_ST: THREE.Vector4 = new THREE.Vector4(0.0, 0.0, 1.0, 1.0); // _MainTex_ST\n  private _renderType: VRMUnlitMaterialRenderType = VRMUnlitMaterialRenderType.Opaque;\n\n  public shouldApplyUniforms = true; // when this is true, applyUniforms effects\n\n  constructor(parameters?: VRMUnlitMaterialParameters) {\n    super();\n\n    if (parameters === undefined) {\n      parameters = {};\n    }\n\n    // == enabling bunch of stuff ==============================================\n    parameters.fog = true;\n    parameters.clipping = true;\n\n    parameters.skinning = parameters.skinning || false;\n    parameters.morphTargets = parameters.morphTargets || false;\n    parameters.morphNormals = parameters.morphNormals || false;\n\n    // == uniforms =============================================================\n    parameters.uniforms = THREE.UniformsUtils.merge([\n      THREE.UniformsLib.common, // map\n      THREE.UniformsLib.fog,\n      {\n        cutoff: { value: 0.5 },\n        mainTex_ST: { value: new THREE.Vector4(0.0, 0.0, 1.0, 1.0) },\n      },\n    ]);\n\n    // == finally compile the shader program ===================================\n    this.setValues(parameters);\n\n    // == update shader stuff ==================================================\n    this._updateShaderCode();\n    this._applyUniforms();\n  }\n\n  get mainTex(): THREE.Texture | null {\n    return this.map;\n  }\n\n  set mainTex(t: THREE.Texture | null) {\n    this.map = t;\n  }\n\n  get renderType(): VRMUnlitMaterialRenderType {\n    return this._renderType;\n  }\n\n  set renderType(t: VRMUnlitMaterialRenderType) {\n    this._renderType = t;\n\n    this.depthWrite = this._renderType !== VRMUnlitMaterialRenderType.Transparent;\n    this.transparent =\n      this._renderType === VRMUnlitMaterialRenderType.Transparent ||\n      this._renderType === VRMUnlitMaterialRenderType.TransparentWithZWrite;\n    this._updateShaderCode();\n  }\n\n  /**\n   * Update this material.\n   * Usually this will be called via [[VRM.update]] so you don't have to call this manually.\n   *\n   * @param delta deltaTime since last update\n   */\n  public updateVRMMaterials(delta: number): void {\n    this._applyUniforms();\n  }\n\n  public copy(source: this): this {\n    super.copy(source);\n\n    // == copy members =========================================================\n    this.cutoff = source.cutoff;\n    this.map = source.map;\n    this.mainTex_ST.copy(source.mainTex_ST);\n    this.renderType = source.renderType;\n\n    return this;\n  }\n\n  /**\n   * Apply updated uniform variables.\n   */\n  private _applyUniforms(): void {\n    if (!this.shouldApplyUniforms) {\n      return;\n    }\n    this.shouldApplyUniforms = false;\n\n    this.uniforms.cutoff.value = this.cutoff;\n    this.uniforms.map.value = this.map;\n    this.uniforms.mainTex_ST.value.copy(this.mainTex_ST);\n  }\n\n  private _updateShaderCode(): void {\n    this.defines = {\n      RENDERTYPE_OPAQUE: this._renderType === VRMUnlitMaterialRenderType.Opaque,\n      RENDERTYPE_CUTOUT: this._renderType === VRMUnlitMaterialRenderType.Cutout,\n      RENDERTYPE_TRANSPARENT:\n        this._renderType === VRMUnlitMaterialRenderType.Transparent ||\n        this._renderType === VRMUnlitMaterialRenderType.TransparentWithZWrite,\n    };\n\n    this.vertexShader = vertexShader;\n    this.fragmentShader = fragmentShader;\n\n    // == set needsUpdate flag =================================================\n    this.needsUpdate = true;\n  }\n}\n","import * as THREE from 'three';\n\nexport const getEncodingComponents = (encoding: THREE.TextureEncoding): [string, string] => {\n  switch (encoding) {\n    case THREE.LinearEncoding:\n      return ['Linear', '( value )'];\n    case THREE.sRGBEncoding:\n      return ['sRGB', '( value )'];\n    case THREE.RGBEEncoding:\n      return ['RGBE', '( value )'];\n    case THREE.RGBM7Encoding:\n      return ['RGBM', '( value, 7.0 )'];\n    case THREE.RGBM16Encoding:\n      return ['RGBM', '( value, 16.0 )'];\n    case THREE.RGBDEncoding:\n      return ['RGBD', '( value, 256.0 )'];\n    case THREE.GammaEncoding:\n      return ['Gamma', '( value, float( GAMMA_FACTOR ) )'];\n    default:\n      throw new Error('unsupported encoding: ' + encoding);\n  }\n};\n\nexport const getTexelDecodingFunction = (functionName: string, encoding: THREE.TextureEncoding): string => {\n  const components = getEncodingComponents(encoding);\n  return 'vec4 ' + functionName + '( vec4 value ) { return ' + components[0] + 'ToLinear' + components[1] + '; }';\n};\n","export * from './MToonMaterial';\nexport * from './VRMMaterialImporter';\nexport * from './VRMUnlitMaterial';\n","export default \"// #define PHONG\\n\\n#ifdef BLENDMODE_CUTOUT\\n  uniform float cutoff;\\n#endif\\n\\nuniform vec3 color;\\nuniform float colorAlpha;\\nuniform vec3 shadeColor;\\n#ifdef USE_SHADETEXTURE\\n  uniform sampler2D shadeTexture;\\n#endif\\n\\nuniform float receiveShadowRate;\\n#ifdef USE_RECEIVESHADOWTEXTURE\\n  uniform sampler2D receiveShadowTexture;\\n#endif\\n\\nuniform float shadingGradeRate;\\n#ifdef USE_SHADINGGRADETEXTURE\\n  uniform sampler2D shadingGradeTexture;\\n#endif\\n\\nuniform float shadeShift;\\nuniform float shadeToony;\\nuniform float lightColorAttenuation;\\nuniform float indirectLightIntensity;\\n\\n#ifdef USE_RIMTEXTURE\\n  uniform sampler2D rimTexture;\\n#endif\\nuniform vec3 rimColor;\\nuniform float rimLightingMix;\\nuniform float rimFresnelPower;\\nuniform float rimLift;\\n\\n#ifdef USE_SPHEREADD\\n  uniform sampler2D sphereAdd;\\n#endif\\n\\nuniform vec3 emissionColor;\\n\\nuniform vec3 outlineColor;\\nuniform float outlineLightingMix;\\n\\n#ifdef USE_UVANIMMASKTEXTURE\\n  uniform sampler2D uvAnimMaskTexture;\\n#endif\\n\\nuniform float uvAnimOffsetX;\\nuniform float uvAnimOffsetY;\\nuniform float uvAnimTheta;\\n\\n#include <common>\\n#include <packing>\\n#include <dithering_pars_fragment>\\n#include <color_pars_fragment>\\n\\n// #include <uv_pars_fragment>\\n#if defined( USE_MAP ) || defined( USE_SHADETEXTURE ) || defined( USE_NORMALMAP ) || defined( USE_RECEIVESHADOWTEXTURE ) || defined( USE_SHADINGGRADETEXTURE ) || defined( USE_RIMTEXTURE ) || defined( USE_EMISSIVEMAP ) || defined( USE_OUTLINEWIDTHTEXTURE ) || defined( USE_UVANIMMASKTEXTURE )\\n  varying vec2 vUv;\\n#endif\\n\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n// #include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n// #include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n// #include <envmap_pars_fragment>\\n// #include <gradientmap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <bsdfs>\\n#include <lights_pars_begin>\\n\\n// #include <lights_phong_pars_fragment>\\nvarying vec3 vViewPosition;\\n\\n#ifndef FLAT_SHADED\\n  varying vec3 vNormal;\\n#endif\\n\\n#define Material_LightProbeLOD( material ) (0)\\n\\n#include <shadowmap_pars_fragment>\\n// #include <bumpmap_pars_fragment>\\n\\n// #include <normalmap_pars_fragment>\\n#ifdef USE_NORMALMAP\\n  uniform sampler2D normalMap;\\n  uniform float bumpScale;\\n\\n  // this number is very random, this is still a \\n  #define UV_DERIVATIVE_EPSILON 1E-6\\n\\n  // Per-Pixel Tangent Space Normal Mapping\\n  // http://hacksoflife.blogspot.ch/2009/11/per-pixel-tangent-space-normal-mapping.html\\n  vec3 perturbNormal2Arb( vec2 uv, vec3 eye_pos, vec3 surf_norm ) {\\n    // Workaround for Adreno 3XX dFd*( vec3 ) bug. See #9988\\n    vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\\n    vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\\n    vec2 st0 = dFdx( uv.st );\\n    vec2 st1 = dFdy( uv.st );\\n\\n    float scale = sign( st1.t * st0.s - st0.t * st1.s ); // we do not care about the magnitude\\n    vec3 S = ( q0 * st1.t - q1 * st0.t ) * scale;\\n    vec3 T = ( - q0 * st1.s + q1 * st0.s ) * scale;\\n\\n    // Workaround for the issue that happens when delta of uv = 0.0\\n    if ( length( S ) == 0.0 || length( T ) == 0.0 ) {\\n      return surf_norm;\\n    }\\n\\n    S = normalize( S );\\n    T = normalize( T );\\n    vec3 N = normalize( surf_norm );\\n\\n    vec3 mapN = texture2D( normalMap, uv ).xyz * 2.0 - 1.0;\\n\\n    mapN.xy *= bumpScale;\\n\\n    #ifdef DOUBLE_SIDED\\n      // Workaround for Adreno GPUs gl_FrontFacing bug. See #15850 and #10331\\n      // http://hacksoflife.blogspot.com/2009/11/per-pixel-tangent-space-normal-mapping.html?showComment=1522254677437#c5087545147696715943\\n      vec3 NfromST = cross( S, T );\\n      if( dot( NfromST, N ) > 0.0 ) {\\n        S *= -1.0;\\n        T *= -1.0;\\n      }\\n    #else\\n      mapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\\n    #endif\\n\\n    mat3 tsn = mat3( S, T, N );\\n\\n    return normalize( tsn * mapN );\\n  }\\n#endif\\n\\n// #include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\n\\n// == lighting stuff ===========================================================\\nfloat getLightIntensity(\\n  const in IncidentLight directLight,\\n  const in GeometricContext geometry,\\n  const in float shadow,\\n  const in float shadingGrade\\n) {\\n  float lightIntensity = dot( geometry.normal, directLight.direction );\\n  lightIntensity = 0.5 + 0.5 * lightIntensity;\\n  lightIntensity = lightIntensity * shadow;\\n  lightIntensity = lightIntensity * shadingGrade;\\n  lightIntensity = lightIntensity * 2.0 - 1.0;\\n  return smoothstep( shadeShift, shadeShift + ( 1.0 - shadeToony ), lightIntensity );\\n}\\n\\nvec3 getLighting( const in vec3 lightColor ) {\\n  vec3 lighting = lightColor;\\n  lighting = mix(\\n    lighting,\\n    vec3( max( 0.001, max( lighting.x, max( lighting.y, lighting.z ) ) ) ),\\n    lightColorAttenuation\\n  );\\n\\n  #ifndef PHYSICALLY_CORRECT_LIGHTS\\n    lighting *= PI;\\n  #endif\\n\\n  return lighting;\\n}\\n\\nvec3 getDiffuse(\\n  const in vec3 lit,\\n  const in vec3 shade,\\n  const in float lightIntensity,\\n  const in vec3 lighting\\n) {\\n  #ifdef DEBUG_LITSHADERATE\\n    return vec3( BRDF_Diffuse_Lambert( lightIntensity * lighting ) );\\n  #endif\\n\\n  return lighting * BRDF_Diffuse_Lambert( mix( shade, lit, lightIntensity ) );\\n}\\n\\nvec3 calcDirectDiffuse(\\n  const in vec2 uv,\\n  const in vec3 lit,\\n  const in vec3 shade,\\n  in GeometricContext geometry,\\n  inout ReflectedLight reflectedLight\\n) {\\n  IncidentLight directLight;\\n  vec3 lightingSum = vec3( 0.0 );\\n\\n  float shadingGrade = 1.0;\\n  #ifdef USE_SHADINGGRADETEXTURE\\n    shadingGrade = 1.0 - shadingGradeRate * ( 1.0 - texture2D( shadingGradeTexture, uv ).r );\\n  #endif\\n\\n  float receiveShadow = receiveShadowRate;\\n  #ifdef USE_RECEIVESHADOWTEXTURE\\n    receiveShadow *= texture2D( receiveShadowTexture, uv ).a;\\n  #endif\\n\\n  #if ( NUM_POINT_LIGHTS > 0 )\\n    PointLight pointLight;\\n\\n    #pragma unroll_loop\\n    for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n      pointLight = pointLights[ i ];\\n      getPointDirectLightIrradiance( pointLight, geometry, directLight );\\n\\n      float atten = 1.0;\\n      #ifdef USE_SHADOWMAP\\n        atten = all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\\n      #endif\\n\\n      float shadow = 1.0 - receiveShadow * ( 1.0 - ( 0.5 + 0.5 * atten ) );\\n      float lightIntensity = getLightIntensity( directLight, geometry, shadow, shadingGrade );\\n      vec3 lighting = getLighting( directLight.color );\\n      reflectedLight.directDiffuse += getDiffuse( lit, shade, lightIntensity, lighting );\\n      lightingSum += lighting;\\n    }\\n  #endif\\n\\n  #if ( NUM_SPOT_LIGHTS > 0 )\\n    SpotLight spotLight;\\n\\n    #pragma unroll_loop\\n    for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n      spotLight = spotLights[ i ];\\n      getSpotDirectLightIrradiance( spotLight, geometry, directLight );\\n\\n      float atten = 1.0;\\n      #ifdef USE_SHADOWMAP\\n        atten = all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\\n      #endif\\n\\n      float shadow = 1.0 - receiveShadow * ( 1.0 - ( 0.5 + 0.5 * atten ) );\\n      float lightIntensity = getLightIntensity( directLight, geometry, shadow, shadingGrade );\\n      vec3 lighting = getLighting( directLight.color );\\n      reflectedLight.directDiffuse += getDiffuse( lit, shade, lightIntensity, lighting );\\n      lightingSum += lighting;\\n    }\\n  #endif\\n\\n  #if ( NUM_DIR_LIGHTS > 0 )\\n    DirectionalLight directionalLight;\\n\\n    #pragma unroll_loop\\n    for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n      directionalLight = directionalLights[ i ];\\n      getDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\\n\\n      float atten = 1.0;\\n      #ifdef USE_SHADOWMAP\\n        atten = all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\\n      #endif\\n\\n      float shadow = 1.0 - receiveShadow * ( 1.0 - ( 0.5 + 0.5 * atten ) );\\n      float lightIntensity = getLightIntensity( directLight, geometry, shadow, shadingGrade );\\n      vec3 lighting = getLighting( directLight.color );\\n      reflectedLight.directDiffuse += getDiffuse( lit, shade, lightIntensity, lighting );\\n      lightingSum += lighting;\\n    }\\n  #endif\\n\\n  return lightingSum;\\n}\\n\\n// == post correction ==========================================================\\nvoid postCorrection() {\\n  #include <tonemapping_fragment>\\n  #include <encodings_fragment>\\n  #include <fog_fragment>\\n  #include <premultiplied_alpha_fragment>\\n  #include <dithering_fragment>\\n}\\n\\n// == main procedure ===========================================================\\nvoid main() {\\n  #include <clipping_planes_fragment>\\n\\n  vec2 uv = vec2(0.5, 0.5);\\n\\n  #if defined( USE_MAP ) || defined( USE_SHADETEXTURE ) || defined( USE_NORMALMAP ) || defined( USE_RECEIVESHADOWTEXTURE ) || defined( USE_SHADINGGRADETEXTURE ) || defined( USE_RIMTEXTURE ) || defined( USE_EMISSIVEMAP ) || defined( USE_OUTLINEWIDTHTEXTURE ) || defined( USE_UVANIMMASKTEXTURE )\\n    uv = vUv;\\n\\n    float uvAnimMask = 1.0;\\n    #ifdef USE_UVANIMMASKTEXTURE\\n      uvAnimMask = texture2D( uvAnimMaskTexture, uv ).x;\\n    #endif\\n\\n    uv = uv + vec2( uvAnimOffsetX, uvAnimOffsetY ) * uvAnimMask;\\n    float uvRotCos = cos( uvAnimTheta * uvAnimMask );\\n    float uvRotSin = sin( uvAnimTheta * uvAnimMask );\\n    uv = mat2( uvRotCos, uvRotSin, -uvRotSin, uvRotCos ) * ( uv - 0.5 ) + 0.5;\\n  #endif\\n\\n  #ifdef DEBUG_UV\\n    gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\\n    #if defined( USE_MAP ) || defined( USE_SHADETEXTURE ) || defined( USE_NORMALMAP ) || defined( USE_RECEIVESHADOWTEXTURE ) || defined( USE_SHADINGGRADETEXTURE ) || defined( USE_RIMTEXTURE ) || defined( USE_EMISSIVEMAP ) || defined( USE_OUTLINEWIDTHTEXTURE ) || defined( USE_UVANIMMASKTEXTURE )\\n      gl_FragColor = vec4( uv, 0.0, 1.0 );\\n    #endif\\n    return;\\n  #endif\\n\\n  vec4 diffuseColor = vec4( color, colorAlpha );\\n  ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n  vec3 totalEmissiveRadiance = emissionColor;\\n\\n  #include <logdepthbuf_fragment>\\n\\n  // #include <map_fragment>\\n  #ifdef USE_MAP\\n    diffuseColor *= mapTexelToLinear( texture2D( map, uv ) );\\n  #endif\\n\\n  #include <color_fragment>\\n  // #include <alphamap_fragment>\\n\\n  // -- MToon: alpha -----------------------------------------------------------\\n  // #include <alphatest_fragment>\\n  #ifdef BLENDMODE_CUTOUT\\n    if ( diffuseColor.a <= cutoff ) { discard; }\\n    diffuseColor.a = 1.0;\\n  #endif\\n\\n  #ifdef BLENDMODE_OPAQUE\\n    diffuseColor.a = 1.0;\\n  #endif\\n\\n  #if defined( OUTLINE ) && defined( OUTLINE_COLOR_FIXED ) // omitting DebugMode\\n    gl_FragColor = vec4( outlineColor, diffuseColor.a );\\n    postCorrection();\\n    return;\\n  #endif\\n\\n  // #include <specularmap_fragment>\\n  #include <normal_fragment_begin>\\n\\n  #ifdef OUTLINE\\n    normal *= -1.0;\\n  #endif\\n\\n  // #include <normal_fragment_maps>\\n  #ifdef USE_NORMALMAP\\n    normal = perturbNormal2Arb( uv, -vViewPosition, normal );\\n  #endif\\n\\n  // #include <emissivemap_fragment>\\n  #ifdef USE_EMISSIVEMAP\\n    totalEmissiveRadiance *= emissiveMapTexelToLinear( texture2D( emissiveMap, uv ) ).rgb;\\n  #endif\\n\\n  #ifdef DEBUG_NORMAL\\n    gl_FragColor = vec4( 0.5 + 0.5 * normal, 1.0 );\\n    return;\\n  #endif\\n\\n  // -- MToon: lighting --------------------------------------------------------\\n  // accumulation\\n  // #include <lights_phong_fragment>\\n  // #include <lights_fragment_begin>\\n  vec3 lit = diffuseColor.rgb;\\n  vec3 shade = shadeColor;\\n  #ifdef USE_SHADETEXTURE\\n    shade *= shadeTextureTexelToLinear( texture2D( shadeTexture, uv ) ).rgb;\\n  #endif\\n\\n  GeometricContext geometry;\\n\\n  geometry.position = - vViewPosition;\\n  geometry.normal = normal;\\n  geometry.viewDir = normalize( vViewPosition );\\n\\n  vec3 lighting = calcDirectDiffuse( uv, diffuseColor.rgb, shade, geometry, reflectedLight );\\n\\n  vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\\n  #if ( NUM_HEMI_LIGHTS > 0 )\\n    #pragma unroll_loop\\n    for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\\n      irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\\n    }\\n  #endif\\n\\n  // #include <lights_fragment_maps>\\n  #ifdef USE_LIGHTMAP\\n    vec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).rgb * lightMapIntensity;\\n    #ifndef PHYSICALLY_CORRECT_LIGHTS\\n      lightMapIrradiance *= PI; // factor of PI should not be present; included here to prevent breakage\\n    #endif\\n    irradiance += lightMapIrradiance;\\n  #endif\\n\\n  // #include <lights_fragment_end>\\n  reflectedLight.indirectDiffuse += indirectLightIntensity * irradiance * BRDF_Diffuse_Lambert( lit );\\n\\n  // modulation\\n  #include <aomap_fragment>\\n\\n  vec3 col = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\\n\\n  #if defined( OUTLINE ) && defined( OUTLINE_COLOR_MIXED ) // omitting DebugMode\\n    gl_FragColor = vec4(\\n      outlineColor.rgb * mix( vec3( 1.0 ), col, outlineLightingMix ),\\n      diffuseColor.a\\n    );\\n    postCorrection();\\n    return;\\n  #endif\\n\\n  // -- MToon: parametric rim lighting -----------------------------------------\\n  vec3 viewDir = normalize( vViewPosition );\\n  vec3 rimMix = mix(vec3(1.0), lighting + indirectLightIntensity * irradiance, rimLightingMix);\\n  vec3 rim = rimColor * pow( saturate( 1.0 - dot( viewDir, normal ) + rimLift ), rimFresnelPower );\\n  #ifdef USE_RIMTEXTURE\\n    rim *= texture2D( rimTexture, uv ).rgb;\\n  #endif\\n  col += rim;\\n\\n  // -- MToon: additive matcap -------------------------------------------------\\n  #ifdef USE_SPHEREADD\\n    {\\n      vec3 x = normalize( vec3( viewDir.z, 0.0, -viewDir.x ) );\\n      vec3 y = cross( viewDir, x ); // guaranteed to be normalized\\n      vec2 sphereUv = 0.5 + 0.5 * vec2( dot( x, normal ), -dot( y, normal ) );\\n      vec3 matcap = sphereAddTexelToLinear( texture2D( sphereAdd, sphereUv ) ).xyz;\\n      col += matcap;\\n    }\\n  #endif\\n\\n  // -- MToon: Emission --------------------------------------------------------\\n  col += totalEmissiveRadiance;\\n\\n  // #include <envmap_fragment>\\n\\n  // -- Almost done! -----------------------------------------------------------\\n  gl_FragColor = vec4( col, diffuseColor.a );\\n  postCorrection();\\n}\"","export default \"// #define PHONG\\n\\nvarying vec3 vViewPosition;\\n\\n#ifndef FLAT_SHADED\\n  varying vec3 vNormal;\\n#endif\\n\\n#include <common>\\n\\n// #include <uv_pars_vertex>\\n#if defined( USE_MAP ) || defined( USE_SHADETEXTURE ) || defined( USE_NORMALMAP ) || defined( USE_RECEIVESHADOWTEXTURE ) || defined( USE_SHADINGGRADETEXTURE ) || defined( USE_RIMTEXTURE ) || defined( USE_EMISSIVEMAP ) || defined( USE_OUTLINEWIDTHTEXTURE ) || defined( USE_UVANIMMASKTEXTURE )\\n  varying vec2 vUv;\\n  uniform vec4 mainTex_ST;\\n#endif\\n\\n#include <uv2_pars_vertex>\\n// #include <displacementmap_pars_vertex>\\n// #include <envmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\n\\n#ifdef USE_OUTLINEWIDTHTEXTURE\\n  uniform sampler2D outlineWidthTexture;\\n#endif\\n\\nuniform float outlineWidth;\\nuniform float outlineScaledMaxDistance;\\n\\nvoid main() {\\n\\n  // #include <uv_vertex>\\n  #if defined( USE_MAP ) || defined( USE_SHADETEXTURE ) || defined( USE_NORMALMAP ) || defined( USE_RECEIVESHADOWTEXTURE ) || defined( USE_SHADINGGRADETEXTURE ) || defined( USE_RIMTEXTURE ) || defined( USE_EMISSIVEMAP ) || defined( USE_OUTLINEWIDTHTEXTURE ) || defined( USE_UVANIMMASKTEXTURE )\\n    vUv = vec2( mainTex_ST.p * uv.x + mainTex_ST.s, mainTex_ST.q * uv.y + mainTex_ST.t );\\n  #endif\\n\\n  #include <uv2_vertex>\\n  #include <color_vertex>\\n\\n  #include <beginnormal_vertex>\\n  #include <morphnormal_vertex>\\n  #include <skinbase_vertex>\\n  #include <skinnormal_vertex>\\n  #include <defaultnormal_vertex>\\n\\n  #ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED\\n    vNormal = normalize( transformedNormal );\\n  #endif\\n\\n  #include <begin_vertex>\\n\\n  #include <morphtarget_vertex>\\n  #include <skinning_vertex>\\n  // #include <displacementmap_vertex>\\n  #include <project_vertex>\\n  #include <logdepthbuf_vertex>\\n  #include <clipping_planes_vertex>\\n\\n  vViewPosition = - mvPosition.xyz;\\n\\n  float outlineTex = 1.0;\\n\\n  #ifdef OUTLINE\\n    #ifdef USE_OUTLINEWIDTHTEXTURE\\n      outlineTex = texture2D( outlineWidthTexture, vUv ).r;\\n    #endif\\n\\n    #ifdef OUTLINE_WIDTH_WORLD\\n      vec3 outlineOffset = 0.01 * outlineWidth * outlineTex * normalize( objectNormal );\\n      gl_Position += projectionMatrix * modelViewMatrix * vec4( outlineOffset, 0.0 );\\n    #endif\\n\\n    #ifdef OUTLINE_WIDTH_SCREEN\\n      vec3 clipNormal = ( projectionMatrix * modelViewMatrix * vec4( normalize( objectNormal ), 0.0 ) ).xyz;\\n      vec2 projectedNormal = normalize( clipNormal.xy );\\n      projectedNormal *= min( gl_Position.w, outlineScaledMaxDistance );\\n      projectedNormal.x *= projectionMatrix[ 0 ].x / projectionMatrix[ 1 ].y;\\n      gl_Position.xy += 0.01 * outlineWidth * outlineTex * projectedNormal.xy;\\n    #endif\\n\\n    gl_Position.z += 1E-6 * gl_Position.w; // anti-artifact magic\\n  #endif\\n\\n  #include <worldpos_vertex>\\n  // #include <envmap_vertex>\\n  #include <shadowmap_vertex>\\n  #include <fog_vertex>\\n\\n}\"","export default \"#ifdef RENDERTYPE_CUTOUT\\n  uniform float cutoff;\\n#endif\\n\\n#include <common>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n// #include <alphamap_pars_fragment>\\n// #include <aomap_pars_fragment>\\n// #include <lightmap_pars_fragment>\\n// #include <envmap_pars_fragment>\\n#include <fog_pars_fragment>\\n// #include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\n\\n// == main procedure ===========================================================\\nvoid main() {\\n  #include <clipping_planes_fragment>\\n\\n  vec4 diffuseColor = vec4( 1.0 );\\n\\n  #include <logdepthbuf_fragment>\\n\\n  // #include <map_fragment>\\n  #ifdef USE_MAP\\n    diffuseColor *= mapTexelToLinear( texture2D( map, vUv ) );\\n  #endif\\n\\n  #include <color_fragment>\\n  // #include <alphamap_fragment>\\n\\n  // MToon: alpha\\n  // #include <alphatest_fragment>\\n  #ifdef RENDERTYPE_CUTOUT\\n    if ( diffuseColor.a <= cutoff ) { discard; }\\n    diffuseColor.a = 1.0;\\n  #endif\\n\\n  #ifdef RENDERTYPE_OPAQUE\\n    diffuseColor.a = 1.0;\\n  #endif\\n\\n  // #include <specularmap_fragment>\\n\\n  ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\n  // accumulation (baked indirect lighting only)\\n  #ifdef USE_LIGHTMAP\\n    reflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\\n  #else\\n    reflectedLight.indirectDiffuse += vec3( 1.0 );\\n  #endif\\n\\n  // modulation\\n  // #include <aomap_fragment>\\n\\n  reflectedLight.indirectDiffuse *= diffuseColor.rgb;\\n  vec3 outgoingLight = reflectedLight.indirectDiffuse;\\n\\n  // #include <envmap_fragment>\\n\\n  gl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\n  #include <premultiplied_alpha_fragment>\\n  #include <tonemapping_fragment>\\n  #include <encodings_fragment>\\n  #include <fog_fragment>\\n}\"","export default \"#include <common>\\n\\n// #include <uv_pars_vertex>\\n#ifdef USE_MAP\\n  varying vec2 vUv;\\n  uniform vec4 mainTex_ST;\\n#endif\\n\\n#include <uv2_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\n\\nvoid main() {\\n\\n  // #include <uv_vertex>\\n  #ifdef USE_MAP\\n    vUv = vec2( mainTex_ST.p * uv.x + mainTex_ST.s, mainTex_ST.q * uv.y + mainTex_ST.t );\\n  #endif\\n\\n  #include <uv2_vertex>\\n  #include <color_vertex>\\n  #include <skinbase_vertex>\\n\\n  #ifdef USE_ENVMAP\\n\\n  #include <beginnormal_vertex>\\n  #include <morphnormal_vertex>\\n  #include <skinnormal_vertex>\\n  #include <defaultnormal_vertex>\\n\\n  #endif\\n\\n  #include <begin_vertex>\\n  #include <morphtarget_vertex>\\n  #include <skinning_vertex>\\n  #include <project_vertex>\\n  #include <logdepthbuf_vertex>\\n\\n  #include <worldpos_vertex>\\n  #include <clipping_planes_vertex>\\n  #include <envmap_vertex>\\n  #include <fog_vertex>\\n\\n}\"","import * as THREE from 'three';\n\nexport function reduceBones(root: THREE.Object3D): void {\n  // Traverse an entire tree\n  root.traverse((obj) => {\n    if (obj.type !== 'SkinnedMesh') {\n      return;\n    }\n\n    const mesh = obj as THREE.SkinnedMesh;\n    const geometry = (mesh.geometry as THREE.BufferGeometry).clone();\n    mesh.geometry = geometry;\n    const attribute = geometry.getAttribute('skinIndex');\n\n    // generate reduced bone list\n    const bones: THREE.Bone[] = []; // new list of bone\n    const boneInverses: THREE.Matrix4[] = []; // new list of boneInverse\n    const boneIndexMap: { [index: number]: number } = {}; // map of old bone index vs. new bone index\n    const array = (attribute.array as any).map((index: number) => {\n      // new skinIndex buffer\n      if (boneIndexMap[index] === undefined) {\n        boneIndexMap[index] = bones.length;\n        bones.push(mesh.skeleton.bones[index]);\n        boneInverses.push(mesh.skeleton.boneInverses[index]);\n      }\n      return boneIndexMap[index];\n    });\n\n    // attach new skinIndex buffer\n    geometry.removeAttribute('skinIndex');\n    geometry.addAttribute('skinIndex', new THREE.BufferAttribute(array, 4, false));\n    mesh.bind(new THREE.Skeleton(bones, boneInverses), new THREE.Matrix4());\n    //                                                 ^^^^^^^^^^^^^^^^^^^ transform of meshes should be ignored\n    // See: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins\n  });\n}\n","import * as THREE from 'three';\nimport { getWorldQuaternionLite } from '../utils/math';\n// based on\n// http://rocketjump.skr.jp/unity3d/109/\n// https://github.com/dwango/UniVRM/blob/master/Scripts/SpringBone/VRMSpringBone.cs\n\nexport const GIZMO_RENDER_ORDER = 10000;\nconst IDENTITY_MATRIX4 = Object.freeze(new THREE.Matrix4());\nconst IDENTITY_QUATERNION = Object.freeze(new THREE.Quaternion());\n\n// \nconst _v3A = new THREE.Vector3();\nconst _v3B = new THREE.Vector3();\nconst _v3C = new THREE.Vector3();\nconst _quatA = new THREE.Quaternion();\nconst _matA = new THREE.Matrix4();\nconst _matB = new THREE.Matrix4();\n\n/**\n * A class represents a single spring bone of a VRM.\n * It should be managed by a [[VRMSpringBoneManager]].\n */\nexport class VRMSpringBone {\n  /**\n   * Radius of the bone, will be used for collision.\n   */\n  public readonly radius: number;\n\n  /**\n   * Stiffness force of the bone. Increasing the value = faster convergence (feels \"harder\").\n   * On UniVRM, its range on GUI is between `0.0` and `4.0` .\n   */\n  public readonly stiffnessForce: number;\n\n  /**\n   * Power of the gravity against this bone.\n   * The \"power\" used in here is very far from scientific physics term...\n   */\n  public readonly gravityPower: number;\n\n  /**\n   * Direction of the gravity against this bone.\n   * Usually it should be normalized.\n   */\n  public readonly gravityDir: THREE.Vector3;\n\n  /**\n   * Drag force of the bone. Increasing the value = less oscillation (feels \"heavier\").\n   * On UniVRM, its range on GUI is between `0.0` and `1.0` .\n   */\n  public readonly dragForce: number;\n\n  /**\n   * An Object3D attached to this bone.\n   */\n  public readonly bone: THREE.Object3D;\n\n  /**\n   * Colliders (as `THREE.Mesh` ) attached to this bone.\n   */\n  public readonly colliders: THREE.Mesh[];\n\n  /**\n   * Current position of child tail, in world unit. Will be used for verlet integration.\n   */\n  protected _currentTail: THREE.Vector3;\n\n  /**\n   * Previous position of child tail, in world unit. Will be used for verlet integration.\n   */\n  protected _prevTail: THREE.Vector3;\n\n  /**\n   * Next position of child tail, in world unit. Will be used for verlet integration.\n   * Actually used only in [[update]] and it's kind of temporary variable.\n   */\n  protected _nextTail: THREE.Vector3;\n\n  /**\n   * Initial axis of the bone, in local unit.\n   */\n  protected _boneAxis: THREE.Vector3;\n\n  /**\n   * Length of the bone in **world unit**. Will be used for normalization in update loop.\n   * It's same as local unit length unless there are scale transformation in world matrix.\n   */\n  protected _worldBoneLength: number;\n\n  /**\n   * World position of this bone, kind of temporary variable.\n   */\n  protected _worldPosition: THREE.Vector3;\n\n  /**\n   * Rotation of parent bone, in world unit.\n   * We should update this constantly in [[update]].\n   */\n  private _parentWorldRotation: THREE.Quaternion;\n\n  /**\n   * Initial state of the local matrix of the bone.\n   */\n  private _initialLocalMatrix: THREE.Matrix4;\n\n  /**\n   * Initial state of the rotation of the bone.\n   */\n  private _initialLocalRotation: THREE.Quaternion;\n\n  /**\n   * Initial state of the position of its child.\n   */\n  private _initialLocalChildPosition: THREE.Vector3;\n\n  /**\n   * Create a new VRMSpringBone.\n   *\n   * @param bone An Object3D that will be attached to this bone\n   * @param radius Radius of the bone\n   * @param stiffness Stiffness force of the bone\n   * @param gravityDir Direction of the gravity against this bone\n   * @param gravityPower Power of the gravity against this bone\n   * @param dragForce Drag force of the bone\n   * @param colliders Colliders that will be attached to this bone\n   */\n  constructor(\n    bone: THREE.Object3D,\n    radius: number,\n    stiffiness: number,\n    gravityDir: THREE.Vector3,\n    gravityPower: number,\n    dragForce: number,\n    colliders: THREE.Mesh[] = [],\n  ) {\n    this.bone = bone; // uniVRM parent\n    this.bone.matrixAutoUpdate = false; // updatethree.js\n\n    this.radius = radius;\n    this.stiffnessForce = stiffiness;\n    this.gravityDir = gravityDir;\n    this.gravityPower = gravityPower;\n    this.dragForce = dragForce;\n    this.colliders = colliders;\n\n    this._worldPosition = new THREE.Vector3().setFromMatrixPosition(this.bone.matrixWorld);\n\n    this._parentWorldRotation = new THREE.Quaternion();\n\n    this._initialLocalMatrix = this.bone.matrix.clone();\n    this._initialLocalRotation = this.bone.quaternion.clone();\n    this._initialLocalChildPosition = ((): THREE.Vector3 => {\n      if (this.bone.children.length === 0) {\n        // \n        // https://github.com/dwango/UniVRM/blob/master/Assets/VRM/UniVRM/Scripts/SpringBone/VRMSpringBone.cs#L246\n        return this.bone.position\n          .clone()\n          .normalize()\n          .multiplyScalar(0.07); // magic number! derives from original source\n      } else {\n        const firstChild = this.bone.children[0];\n        return firstChild.position.clone();\n      }\n    })();\n\n    this._currentTail = this.bone.localToWorld(this._initialLocalChildPosition.clone());\n    this._prevTail = this._currentTail.clone();\n    this._nextTail = this._currentTail.clone();\n\n    this._boneAxis = this._initialLocalChildPosition.clone().normalize();\n    this._worldBoneLength = this.bone\n      .localToWorld(_v3A.copy(this._initialLocalChildPosition))\n      .sub(this._worldPosition)\n      .length();\n  }\n\n  /**\n   * Reset the state of this bone.\n   * You might want to call [[VRMSpringBoneManager.reset]] instead.\n   */\n  public reset(): void {\n    this.bone.matrix.copy(this._initialLocalMatrix);\n\n    this.bone.localToWorld(this._currentTail.copy(this._initialLocalChildPosition));\n    this._prevTail.copy(this._currentTail);\n    this._nextTail.copy(this._currentTail);\n\n    // matrixWorld\n    this.bone.updateMatrix();\n    this.bone.matrixWorld.multiplyMatrices(this._getParentMatrixWorld(), this.bone.matrix);\n    this._worldPosition.setFromMatrixPosition(this.bone.matrixWorld);\n  }\n\n  /**\n   * Update the state of this bone.\n   * You might want to call [[VRMSpringBoneManager.update]] instead.\n   *\n   * @param delta deltaTime\n   */\n  public update(delta: number): void {\n    if (delta <= 0) return;\n\n    // \n    // worldMatrix\n    this.bone.matrixWorld.multiplyMatrices(this._getParentMatrixWorld(), this.bone.matrix);\n\n    if (this.bone.parent) {\n      // SpringBone\n      // matrixWorldworldMatrixquaternion\n      // getWorldQuaternion\n      getWorldQuaternionLite(this.bone.parent, this._parentWorldRotation);\n    } else {\n      this._parentWorldRotation.copy(IDENTITY_QUATERNION);\n    }\n\n    // worldMatrixworldPosition\n    // `getWorldPosition()` \n    this._worldPosition.setFromMatrixPosition(this.bone.matrixWorld);\n    const stiffness = this.stiffnessForce * delta;\n    const external = _v3B.copy(this.gravityDir).multiplyScalar(this.gravityPower * delta);\n\n    // verlet\n    this._nextTail\n      .copy(this._currentTail)\n      .add(\n        _v3A\n          .copy(this._currentTail)\n          .sub(this._prevTail)\n          .multiplyScalar(1 - this.dragForce),\n      ) // ()\n      .add(\n        _v3A\n          .copy(this._boneAxis)\n          .applyMatrix4(this._initialLocalMatrix)\n          .applyMatrix4(this._getParentMatrixWorld())\n          .sub(this._worldPosition)\n          .normalize()\n          .multiplyScalar(stiffness),\n      ) // \n      .add(external); // \n\n    // normalize bone length\n    this._nextTail\n      .sub(this._worldPosition)\n      .normalize()\n      .multiplyScalar(this._worldBoneLength)\n      .add(this._worldPosition);\n\n    // Collision\n    this._collision(this._nextTail);\n\n    this._prevTail.copy(this._currentTail);\n    this._currentTail.copy(this._nextTail);\n\n    // Apply rotation, convert vector3 thing into actual quaternion\n    // Original UniVRM is doing world unit calculus at here but we're gonna do this on local unit\n    // since Three.js is not good at world coordination stuff\n    const initialWorldMatrixInv = _matA.getInverse(\n      _matB.copy(this._getParentMatrixWorld()).multiply(this._initialLocalMatrix),\n    );\n    const applyRotation = _quatA.setFromUnitVectors(\n      this._boneAxis,\n      _v3A\n        .copy(this._nextTail)\n        .applyMatrix4(initialWorldMatrixInv)\n        .normalize(),\n    );\n\n    this.bone.quaternion.copy(this._initialLocalRotation).multiply(applyRotation);\n\n    // We need to update its matrixWorld manually, since we tweaked the bone by our hand\n    this.bone.updateMatrix();\n    this.bone.matrixWorld.multiplyMatrices(this._getParentMatrixWorld(), this.bone.matrix);\n  }\n\n  /**\n   * Do collision math against every colliders attached to this bone.\n   *\n   * @param tail The tail you want to process\n   */\n  private _collision(tail: THREE.Vector3): void {\n    this.colliders.forEach((collider) => {\n      const colliderWorldPosition = _v3A.setFromMatrixPosition(collider.matrixWorld);\n      const colliderRadius = collider.geometry.boundingSphere.radius;\n      const r = this.radius + colliderRadius;\n\n      if (tail.distanceToSquared(colliderWorldPosition) <= r * r) {\n        // Collider\n        const normal = _v3B.subVectors(tail, colliderWorldPosition).normalize();\n        const posFromCollider = _v3C.addVectors(colliderWorldPosition, normal.multiplyScalar(r));\n\n        // normalize bone length\n        tail.copy(\n          posFromCollider\n            .sub(this._worldPosition)\n            .normalize()\n            .multiplyScalar(this._worldBoneLength)\n            .add(this._worldPosition),\n        );\n      }\n    });\n  }\n\n  /**\n   * Returns the world matrix of its parent object.\n   */\n  private _getParentMatrixWorld(): THREE.Matrix4 {\n    return this.bone.parent ? this.bone.parent.matrixWorld : IDENTITY_MATRIX4;\n  }\n}\n","import * as THREE from 'three';\nimport { GLTFNode, VRMSchema } from '../types';\nimport { GIZMO_RENDER_ORDER, VRMSpringBone } from './VRMSpringBone';\nimport { VRMSpringBoneColliderGroup, VRMSpringBoneColliderMesh } from './VRMSpringBoneColliderGroup';\nimport { VRMSpringBoneGroup, VRMSpringBoneManager } from './VRMSpringBoneManager';\n\n/**\n * An importer that imports a [[VRMSpringBoneManager]] from a VRM extension of a GLTF.\n */\nexport class VRMSpringBoneImporter {\n  /**\n   * Import a [[VRMLookAtHead]] from a VRM.\n   *\n   * @param gltf A parsed result of GLTF taken from GLTFLoader\n   */\n  public async import(gltf: THREE.GLTF): Promise<VRMSpringBoneManager | null> {\n    if (\n      !gltf.parser.json.extensions ||\n      !gltf.parser.json.extensions.VRM ||\n      !gltf.parser.json.extensions.VRM.secondaryAnimation\n    ) {\n      return null;\n    }\n\n    // \n    const colliderGroups = await this._getColliderMeshGroups(gltf);\n    colliderGroups.forEach((group) => gltf.scene.add(...group.colliders));\n\n    // stiffinessdragForceboneGroup\n    // \n    const springBoneGroupList = await this._getSpringBoneGroupList(gltf, colliderGroups);\n\n    return new VRMSpringBoneManager(springBoneGroupList);\n  }\n\n  protected get _isColiderMeshVisible(): boolean {\n    return false;\n  }\n\n  protected _createSpringBone(\n    gltf: THREE.GLTF,\n    bone: THREE.Object3D,\n    hitRadius: number,\n    stiffiness: number,\n    gravityDir: THREE.Vector3,\n    gravityPower: number,\n    dragForce: number,\n    colliders: THREE.Mesh[] = [],\n  ): VRMSpringBone {\n    return new VRMSpringBone(bone, hitRadius, stiffiness, gravityDir, gravityPower, dragForce, colliders);\n  }\n\n  private async _getSpringBoneGroupList(\n    gltf: THREE.GLTF,\n    colliderGroups: VRMSpringBoneColliderGroup[],\n  ): Promise<VRMSpringBoneGroup[]> {\n    const springBoneGroups: VRMSchema.SecondaryAnimationSpring[] = gltf.parser.json.extensions!.VRM!.secondaryAnimation!\n      .boneGroups;\n\n    const springBoneGroupList: VRMSpringBoneGroup[] = [];\n\n    springBoneGroups.forEach((vrmBoneGroup) => {\n      if (\n        vrmBoneGroup.stiffiness === undefined ||\n        vrmBoneGroup.gravityDir === undefined ||\n        vrmBoneGroup.gravityDir.x === undefined ||\n        vrmBoneGroup.gravityDir.y === undefined ||\n        vrmBoneGroup.gravityDir.z === undefined ||\n        vrmBoneGroup.gravityPower === undefined ||\n        vrmBoneGroup.dragForce === undefined ||\n        vrmBoneGroup.hitRadius === undefined ||\n        vrmBoneGroup.colliderGroups === undefined ||\n        vrmBoneGroup.bones === undefined\n      ) {\n        return;\n      }\n\n      const stiffiness = vrmBoneGroup.stiffiness;\n      const gravityDir = new THREE.Vector3(\n        vrmBoneGroup.gravityDir.x,\n        vrmBoneGroup.gravityDir.y,\n        vrmBoneGroup.gravityDir.z,\n      );\n      const gravityPower = vrmBoneGroup.gravityPower;\n      const dragForce = vrmBoneGroup.dragForce;\n      const hitRadius = vrmBoneGroup.hitRadius;\n\n      const colliders: VRMSpringBoneColliderMesh[] = [];\n      vrmBoneGroup.colliderGroups.forEach((colliderIndex) => {\n        colliders.push(...colliderGroups[colliderIndex].colliders);\n      });\n\n      const springBoneGroup: VRMSpringBoneGroup = [];\n      vrmBoneGroup.bones.forEach(async (nodeIndex) => {\n        // VRM\n        const springRootBone: GLTFNode = await gltf.parser.getDependency('node', nodeIndex);\n\n        // it's weird but there might be cases we can't find the root bone\n        if (!springRootBone) {\n          return;\n        }\n\n        springRootBone.traverse((bone) => {\n          const springBone = this._createSpringBone(\n            gltf,\n            bone,\n            hitRadius,\n            stiffiness,\n            gravityDir,\n            gravityPower,\n            dragForce,\n            colliders,\n          );\n          springBoneGroup.push(springBone);\n        });\n      });\n\n      springBoneGroupList.push(springBoneGroup);\n    });\n\n    return springBoneGroupList;\n  }\n\n  /**\n   * Create an array of [[VRMSpringBoneColliderGroup]].\n   */\n  private async _getColliderMeshGroups(gltf: THREE.GLTF): Promise<VRMSpringBoneColliderGroup[]> {\n    const vrmExt: VRMSchema.VRM | undefined = gltf.parser.json.extensions && gltf.parser.json.extensions.VRM;\n    if (vrmExt === undefined) {\n      return [];\n    }\n    const secondaryAnimation = vrmExt.secondaryAnimation;\n    if (secondaryAnimation === undefined) {\n      return [];\n    }\n    const vrmColliderGroups = secondaryAnimation.colliderGroups;\n    if (vrmColliderGroups === undefined) {\n      return [];\n    }\n\n    const colliderGroups: VRMSpringBoneColliderGroup[] = [];\n    vrmColliderGroups.forEach(async (colliderGroup) => {\n      if (colliderGroup.node === undefined || colliderGroup.colliders === undefined) {\n        return;\n      }\n\n      const bone = await gltf.parser.getDependency('node', colliderGroup.node);\n      const colliders: VRMSpringBoneColliderMesh[] = [];\n      colliderGroup.colliders.forEach((collider) => {\n        if (\n          collider.offset === undefined ||\n          collider.offset.x === undefined ||\n          collider.offset.y === undefined ||\n          collider.offset.z === undefined ||\n          collider.radius === undefined\n        ) {\n          return;\n        }\n\n        const offsetMatrix = new THREE.Matrix4().makeTranslation(\n          collider.offset.x,\n          collider.offset.y,\n          -collider.offset.z, // this is pretty weird. See: https://github.com/dwango/UniVRM/issues/65\n        );\n        const visible = this._isColiderMeshVisible;\n        const colliderMesh = new THREE.Mesh(\n          new THREE.SphereBufferGeometry(collider.radius, 8, 4),\n          new THREE.MeshBasicMaterial({\n            color: 0xff00ff,\n            visible,\n            wireframe: true,\n            transparent: true,\n            depthTest: false,\n          }),\n        );\n        (colliderMesh.material as any).renderOrder = GIZMO_RENDER_ORDER;\n\n        // the name have to be this in order to exclude colliders from bounding box\n        // (See Viewer.ts, search for child.name === 'vrmColliderSphere')\n        colliderMesh.name = 'vrmColliderSphere';\n\n        // We will use the radius of the sphere for collision vs bones.\n        // `boundingSphere` must be created to compute the radius.\n        colliderMesh.geometry.computeBoundingSphere();\n\n        // The colliderMesh must sync with the bone.\n        // Attaching bone's matrix to the colliderMesh at every update.\n        // (colliderMesh will move automecicallty)\n        colliderMesh.updateMatrixWorld = (): void => {\n          colliderMesh.matrixWorld.copy(bone.matrixWorld).multiply(offsetMatrix);\n        };\n        colliders.push(colliderMesh);\n      });\n\n      const colliderMeshGroup = {\n        node: colliderGroup.node,\n        colliders,\n      };\n      colliderGroups.push(colliderMeshGroup);\n    });\n\n    return colliderGroups;\n  }\n}\n","import { VRMSpringBone } from './VRMSpringBone';\n\n/**\n * Represents a single spring bone group of a VRM.\n */\nexport type VRMSpringBoneGroup = VRMSpringBone[];\n\n/**\n * A class manages every spring bones on a VRM.\n */\nexport class VRMSpringBoneManager {\n  public readonly springBoneGroupList: VRMSpringBoneGroup[] = [];\n\n  /**\n   * Create a new [[VRMSpringBoneManager]]\n   *\n   * @param springBoneGroupList An array of [[VRMSpringBoneGroup]]\n   */\n  public constructor(springBoneGroupList: VRMSpringBoneGroup[]) {\n    this.springBoneGroupList = springBoneGroupList;\n  }\n\n  /**\n   * Update every spring bone attached to this manager.\n   *\n   * @param delta deltaTime\n   */\n  public lateUpdate(delta: number): void {\n    this.springBoneGroupList.forEach((springBoneGroup) => {\n      springBoneGroup.forEach((springBone) => {\n        springBone.update(delta);\n      });\n    });\n  }\n\n  /**\n   * Reset every spring bone attached to this manager.\n   */\n  public reset(): void {\n    this.springBoneGroupList.forEach((springBoneGroup) => {\n      springBoneGroup.forEach((springBone) => {\n        springBone.reset();\n      });\n    });\n  }\n}\n","export * from './VRMSpringBone';\nexport * from './VRMSpringBoneColliderGroup';\nexport * from './VRMSpringBoneImporter';\nexport * from './VRMSpringBoneManager';\n","// Typedoc does not support export declarations yet\n// then we have to use `namespace` instead of export declarations for now.\n// See: https://github.com/TypeStrong/typedoc/pull/801\n\n// eslint-disable-next-line @typescript-eslint/no-namespace\nexport namespace VRMSchema {\n  /**\n   * VRM extension is for 3d humanoid avatars (and models) in VR applications.\n   */\n  export interface VRM {\n    blendShapeMaster?: BlendShape;\n    /**\n     * Version of exporter that vrm created. UniVRM-0.53.0\n     */\n    exporterVersion?: string;\n    firstPerson?: FirstPerson;\n    humanoid?: Humanoid;\n    materialProperties?: Material[];\n    meta?: Meta;\n    secondaryAnimation?: SecondaryAnimation;\n    /**\n     * Version of VRM specification. 0.0\n     */\n    specVersion?: string;\n  }\n\n  /**\n   * BlendShapeAvatar of UniVRM\n   */\n  export interface BlendShape {\n    blendShapeGroups?: BlendShapeGroup[];\n  }\n\n  export interface BlendShapeGroup {\n    /**\n     * Low level blendshape references.\n     */\n    binds?: BlendShapeBind[];\n    /**\n     * 0 or 1. Do not allow an intermediate value. Value should rounded\n     */\n    isBinary?: boolean;\n    /**\n     * Material animation references.\n     */\n    materialValues?: BlendShapeMaterialbind[];\n    /**\n     * Expression name\n     */\n    name?: string;\n    /**\n     * Predefined Expression name\n     */\n    presetName?: BlendShapePresetName;\n  }\n\n  export interface BlendShapeBind {\n    index?: number;\n    mesh?: number;\n    /**\n     * SkinnedMeshRenderer.SetBlendShapeWeight\n     */\n    weight?: number;\n  }\n\n  export interface BlendShapeMaterialbind {\n    materialName?: string;\n    propertyName?: string;\n    targetValue?: number[];\n  }\n\n  /**\n   * Predefined Expression name\n   */\n  export enum BlendShapePresetName {\n    A = 'a',\n    Angry = 'angry',\n    Blink = 'blink',\n    BlinkL = 'blink_l',\n    BlinkR = 'blink_r',\n    E = 'e',\n    Fun = 'fun',\n    I = 'i',\n    Joy = 'joy',\n    Lookdown = 'lookdown',\n    Lookleft = 'lookleft',\n    Lookright = 'lookright',\n    Lookup = 'lookup',\n    Neutral = 'neutral',\n    O = 'o',\n    Sorrow = 'sorrow',\n    U = 'u',\n    Unknown = 'unknown',\n  }\n\n  export interface FirstPerson {\n    /**\n     * The bone whose rendering should be turned off in first-person view. Usually Head is\n     * specified.\n     */\n    firstPersonBone?: number;\n    /**\n     * The target position of the VR headset in first-person view. It is assumed that an offset\n     * from the head bone to the VR headset is added.\n     */\n    firstPersonBoneOffset?: Vector3;\n    lookAtHorizontalInner?: FirstPersonDegreeMap;\n    lookAtHorizontalOuter?: FirstPersonDegreeMap;\n    /**\n     * Eye controller mode.\n     */\n    lookAtTypeName?: FirstPersonLookAtTypeName;\n    lookAtVerticalDown?: FirstPersonDegreeMap;\n    lookAtVerticalUp?: FirstPersonDegreeMap;\n    /**\n     * Switch display / undisplay for each mesh in first-person view or the others.\n     */\n    meshAnnotations?: FirstPersonMeshannotation[];\n  }\n\n  /**\n   * Eye controller setting.\n   */\n  export interface FirstPersonDegreeMap {\n    /**\n     * None linear mapping params. time, value, inTangent, outTangent\n     */\n    curve?: number[];\n    /**\n     * Look at input clamp range degree.\n     */\n    xRange?: number;\n    /**\n     * Look at map range degree from xRange.\n     */\n    yRange?: number;\n  }\n\n  /**\n   * Eye controller mode.\n   */\n  export enum FirstPersonLookAtTypeName {\n    BlendShape = 'BlendShape',\n    Bone = 'Bone',\n  }\n\n  export interface FirstPersonMeshannotation {\n    firstPersonFlag?: string;\n    mesh?: number;\n  }\n\n  export interface Humanoid {\n    /**\n     * Unity's HumanDescription.armStretch\n     */\n    armStretch?: number;\n    /**\n     * Unity's HumanDescription.feetSpacing\n     */\n    feetSpacing?: number;\n    /**\n     * Unity's HumanDescription.hasTranslationDoF\n     */\n    hasTranslationDoF?: boolean;\n    humanBones?: HumanoidBone[];\n    /**\n     * Unity's HumanDescription.legStretch\n     */\n    legStretch?: number;\n    /**\n     * Unity's HumanDescription.lowerArmTwist\n     */\n    lowerArmTwist?: number;\n    /**\n     * Unity's HumanDescription.lowerLegTwist\n     */\n    lowerLegTwist?: number;\n    /**\n     * Unity's HumanDescription.upperArmTwist\n     */\n    upperArmTwist?: number;\n    /**\n     * Unity's HumanDescription.upperLegTwist\n     */\n    upperLegTwist?: number;\n  }\n\n  export interface HumanoidBone {\n    /**\n     * Unity's HumanLimit.axisLength\n     */\n    axisLength?: number;\n    /**\n     * Human bone name.\n     */\n    bone?: HumanoidBoneName;\n    /**\n     * Unity's HumanLimit.center\n     */\n    center?: Vector3;\n    /**\n     * Unity's HumanLimit.max\n     */\n    max?: Vector3;\n    /**\n     * Unity's HumanLimit.min\n     */\n    min?: Vector3;\n    /**\n     * Reference node index\n     */\n    node?: number;\n    /**\n     * Unity's HumanLimit.useDefaultValues\n     */\n    useDefaultValues?: boolean;\n  }\n\n  /**\n   * Human bone name.\n   */\n  export enum HumanoidBoneName {\n    Chest = 'chest',\n    Head = 'head',\n    Hips = 'hips',\n    Jaw = 'jaw',\n    LeftEye = 'leftEye',\n    LeftFoot = 'leftFoot',\n    LeftHand = 'leftHand',\n    LeftIndexDistal = 'leftIndexDistal',\n    LeftIndexIntermediate = 'leftIndexIntermediate',\n    LeftIndexProximal = 'leftIndexProximal',\n    LeftLittleDistal = 'leftLittleDistal',\n    LeftLittleIntermediate = 'leftLittleIntermediate',\n    LeftLittleProximal = 'leftLittleProximal',\n    LeftLowerArm = 'leftLowerArm',\n    LeftLowerLeg = 'leftLowerLeg',\n    LeftMiddleDistal = 'leftMiddleDistal',\n    LeftMiddleIntermediate = 'leftMiddleIntermediate',\n    LeftMiddleProximal = 'leftMiddleProximal',\n    LeftRingDistal = 'leftRingDistal',\n    LeftRingIntermediate = 'leftRingIntermediate',\n    LeftRingProximal = 'leftRingProximal',\n    LeftShoulder = 'leftShoulder',\n    LeftThumbDistal = 'leftThumbDistal',\n    LeftThumbIntermediate = 'leftThumbIntermediate',\n    LeftThumbProximal = 'leftThumbProximal',\n    LeftToes = 'leftToes',\n    LeftUpperArm = 'leftUpperArm',\n    LeftUpperLeg = 'leftUpperLeg',\n    Neck = 'neck',\n    RightEye = 'rightEye',\n    RightFoot = 'rightFoot',\n    RightHand = 'rightHand',\n    RightIndexDistal = 'rightIndexDistal',\n    RightIndexIntermediate = 'rightIndexIntermediate',\n    RightIndexProximal = 'rightIndexProximal',\n    RightLittleDistal = 'rightLittleDistal',\n    RightLittleIntermediate = 'rightLittleIntermediate',\n    RightLittleProximal = 'rightLittleProximal',\n    RightLowerArm = 'rightLowerArm',\n    RightLowerLeg = 'rightLowerLeg',\n    RightMiddleDistal = 'rightMiddleDistal',\n    RightMiddleIntermediate = 'rightMiddleIntermediate',\n    RightMiddleProximal = 'rightMiddleProximal',\n    RightRingDistal = 'rightRingDistal',\n    RightRingIntermediate = 'rightRingIntermediate',\n    RightRingProximal = 'rightRingProximal',\n    RightShoulder = 'rightShoulder',\n    RightThumbDistal = 'rightThumbDistal',\n    RightThumbIntermediate = 'rightThumbIntermediate',\n    RightThumbProximal = 'rightThumbProximal',\n    RightToes = 'rightToes',\n    RightUpperArm = 'rightUpperArm',\n    RightUpperLeg = 'rightUpperLeg',\n    Spine = 'spine',\n    UpperChest = 'upperChest',\n  }\n\n  export interface Material {\n    floatProperties?: { [key: string]: any };\n    keywordMap?: { [key: string]: any };\n    name?: string;\n    renderQueue?: number;\n    shader?: string;\n    tagMap?: { [key: string]: any };\n    textureProperties?: { [key: string]: any };\n    vectorProperties?: { [key: string]: any };\n  }\n\n  export interface Meta {\n    /**\n     * A person who can perform with this avatar\n     */\n    allowedUserName?: MetaAllowedUserName;\n    /**\n     * Author of VRM model\n     */\n    author?: string;\n    /**\n     * For commercial use\n     */\n    commercialUssageName?: MetaUssageName;\n    /**\n     * Contact Information of VRM model author\n     */\n    contactInformation?: string;\n    /**\n     * License type\n     */\n    licenseName?: MetaLicenseName;\n    /**\n     * If Other is selected, put the URL link of the license document here.\n     */\n    otherLicenseUrl?: string;\n    /**\n     * If there are any conditions not mentioned above, put the URL link of the license document\n     * here.\n     */\n    otherPermissionUrl?: string;\n    /**\n     * Reference of VRM model\n     */\n    reference?: string;\n    /**\n     * Permission to perform sexual acts with this avatar\n     */\n    sexualUssageName?: MetaUssageName;\n    /**\n     * Thumbnail of VRM model\n     */\n    texture?: number;\n    /**\n     * Title of VRM model\n     */\n    title?: string;\n    /**\n     * Version of VRM model\n     */\n    version?: string;\n    /**\n     * Permission to perform violent acts with this avatar\n     */\n    violentUssageName?: MetaUssageName;\n  }\n\n  /**\n   * A person who can perform with this avatar\n   */\n  export enum MetaAllowedUserName {\n    Everyone = 'Everyone',\n    ExplicitlyLicensedPerson = 'ExplicitlyLicensedPerson',\n    OnlyAuthor = 'OnlyAuthor',\n  }\n\n  /**\n   * For commercial use\n   *\n   * Permission to perform sexual acts with this avatar\n   *\n   * Permission to perform violent acts with this avatar\n   */\n  export enum MetaUssageName {\n    Allow = 'Allow',\n    Disallow = 'Disallow',\n  }\n\n  /**\n   * License type\n   */\n  export enum MetaLicenseName {\n    Cc0 = 'CC0',\n    CcBy = 'CC_BY',\n    CcByNc = 'CC_BY_NC',\n    CcByNcNd = 'CC_BY_NC_ND',\n    CcByNcSa = 'CC_BY_NC_SA',\n    CcByNd = 'CC_BY_ND',\n    CcBySa = 'CC_BY_SA',\n    Other = 'Other',\n    RedistributionProhibited = 'Redistribution_Prohibited',\n  }\n\n  /**\n   * The setting of automatic animation of string-like objects such as tails and hairs.\n   */\n  export interface SecondaryAnimation {\n    boneGroups?: SecondaryAnimationSpring[];\n    colliderGroups?: SecondaryAnimationCollidergroup[];\n  }\n\n  export interface SecondaryAnimationSpring {\n    /**\n     * Specify the node index of the root bone of the swaying object.\n     */\n    bones?: number[];\n    /**\n     * The reference point of a swaying object can be set at any location except the origin.\n     * When implementing UI moving with warp, the parent node to move with warp can be specified\n     * if you don't want to make the object swaying with warp movement.\n     */\n    center?: number;\n    /**\n     * Specify the index of the collider group for collisions with swaying objects.\n     */\n    colliderGroups?: number[];\n    /**\n     * Annotation comment\n     */\n    comment?: string;\n    /**\n     * The resistance (deceleration) of automatic animation.\n     */\n    dragForce?: number;\n    /**\n     * The direction of gravity. Set (0, -1, 0) for simulating the gravity. Set (1, 0, 0) for\n     * simulating the wind.\n     */\n    gravityDir?: Vector3;\n    /**\n     * The strength of gravity.\n     */\n    gravityPower?: number;\n    /**\n     * The radius of the sphere used for the collision detection with colliders.\n     */\n    hitRadius?: number;\n    /**\n     * The resilience of the swaying object (the power of returning to the initial pose).\n     */\n    stiffiness?: number;\n  }\n\n  export interface SecondaryAnimationCollidergroup {\n    colliders?: SecondaryAnimationCollider[];\n    /**\n     * The node of the collider group for setting up collision detections.\n     */\n    node?: number;\n  }\n\n  export interface SecondaryAnimationCollider {\n    /**\n     * The local coordinate from the node of the collider group.\n     */\n    offset?: Vector3;\n    /**\n     * The radius of the collider.\n     */\n    radius?: number;\n  }\n\n  export interface Vector3 {\n    x?: number;\n    y?: number;\n    z?: number;\n  }\n}\n","// Typedoc does not support export declarations yet\n// then we have to use `namespace` instead of export declarations for now.\n// See: https://github.com/TypeStrong/typedoc/pull/801\n\n// import * as GLTFSchema from './GLTFSchema';\n// import * as VRMSchema from './VRMSchema';\n\n// export { GLTFSchema, VRMSchema };\n\nexport * from './GLTFSchema';\nexport * from './VRMSchema';\n\nexport * from './types';\n","import * as THREE from 'three';\n\nfunction disposeMaterial(material: any): void {\n  Object.keys(material).forEach((propertyName) => {\n    if (!!material[propertyName] && typeof material[propertyName].dispose === 'function') {\n      material[propertyName].dispose();\n    }\n  });\n\n  material.dispose();\n  material = undefined;\n}\n\nfunction dispose(object3D: any): void {\n  if (object3D.geometry) {\n    object3D.geometry.dispose();\n    object3D.geometry = undefined;\n  }\n\n  if (!!object3D.material && Array.isArray(object3D.material)) {\n    object3D.material.forEach((material: THREE.Material) => disposeMaterial(material));\n  } else if (object3D.material) {\n    disposeMaterial(object3D.material);\n  }\n}\n\nexport function deepDispose(object3D: THREE.Object3D): void {\n  object3D.traverse(dispose);\n}\n","import * as THREE from 'three';\n\n/**\n * Clamp an input number within [ `0.0` - `1.0` ].\n *\n * @param value The input value\n */\nexport function saturate(value: number): number {\n  return Math.max(Math.min(value, 1.0), 0.0);\n}\n\n/**\n * Map the range of an input value from [ `min` - `max` ] to [ `0.0` - `1.0` ].\n * If input value is less than `min` , it returns `0.0`.\n * If input value is greater than `max` , it returns `1.0`.\n *\n * See also: https://threejs.org/docs/#api/en/math/Math.smoothstep\n *\n * @param x The value that will be mapped into the specified range\n * @param min Minimum value of the range\n * @param max Maximum value of the range\n */\nexport function linstep(x: number, min: number, max: number): number {\n  if (x <= min) return 0;\n  if (x >= max) return 1;\n\n  return (x - min) / (max - min);\n}\n\nconst _position = new THREE.Vector3();\nconst _scale = new THREE.Vector3();\nconst _rotation = new THREE.Quaternion();\n\n/**\n * Extract world position of an object from its world space matrix, in cheaper way.\n *\n * @param object The object\n * @param out Target vector\n */\nexport function getWorldPositionLite(object: THREE.Object3D, out: THREE.Vector3): THREE.Vector3 {\n  object.matrixWorld.decompose(out, _rotation, _scale);\n  return out;\n}\n\n/**\n * Extract world scale of an object from its world space matrix, in cheaper way.\n *\n * @param object The object\n * @param out Target vector\n */\nexport function getWorldScaleLite(object: THREE.Object3D, out: THREE.Vector3): THREE.Vector3 {\n  object.matrixWorld.decompose(_position, _rotation, out);\n  return out;\n}\n\n/**\n * Extract world rotation of an object from its world space matrix, in cheaper way.\n *\n * @param object The object\n * @param out Target vector\n */\nexport function getWorldQuaternionLite(object: THREE.Object3D, out: THREE.Quaternion): THREE.Quaternion {\n  object.matrixWorld.decompose(_position, out, _scale);\n  return out;\n}\n","export function renameMaterialProperty(name: string): string {\n  if (name[0] !== '_') {\n    console.warn(`renameMaterialProperty: Given property name \"${name}\" might be invalid`);\n    return name;\n  }\n  name = name.substring(1);\n\n  if (!/[A-Z]/.test(name[0])) {\n    console.warn(`renameMaterialProperty: Given property name \"${name}\" might be invalid`);\n    return name;\n  }\n  return name[0].toLowerCase() + name.substring(1);\n}\n","module.exports = THREE;"],"sourceRoot":""},"metadata":{},"sourceType":"module"}