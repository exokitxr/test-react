{"ast":null,"code":"import { Helpers } from './Unity.js';\nimport THREE from 'three.js';\nconst rightVector = new THREE.Vector3(1, 0, 0);\nconst z180Quaternion = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), Math.PI);\nconst localVector = new THREE.Vector3();\nconst localVector2 = new THREE.Vector3();\nconst localVector3 = new THREE.Vector3();\nconst localVector4 = new THREE.Vector3();\nconst localQuaternion = new THREE.Quaternion();\nconst localQuaternion2 = new THREE.Quaternion();\nconst localQuaternion3 = new THREE.Quaternion();\nconst localEuler = new THREE.Euler();\nconst localEuler2 = new THREE.Euler();\n\nclass ShoulderPoser {\n  constructor(rig, shoulder) {\n    this.rig = rig;\n    this.shoulder = shoulder;\n    this.poseManager = rig.poseManager;\n    this.vrTransforms = this.poseManager.vrTransforms; // this.headNeckDirectionVector = new Vector3(1.0894440904962721e-10, -0.06860782711996793, -0.0006757629250115499).normalize();\n    // this.headNeckDistance = 0.06861115505261682;\n    // this.neckShoulderDistance = new Vector3(3.122724301363178e-10, -0.1953215129534993, 0.02834002902116923);\n    // this.maxDeltaHeadRotation = 80;\n    // this.distinctShoulderRotationLimitForward = 33;\n    // this.distinctShoulderRotationLimitBackward = 0;\n    // this.distinctShoulderRotationLimitUpward = 33;\n    // this.distinctShoulderRotationMultiplier = 30;\n    // this.rightRotationStartHeight = 0;\n    // this.rightRotationHeightFactor = 142;\n    // this.rightRotationHeadRotationFactor = 0.3;\n    // this.rightRotationHeadRotationOffset = -20;\n    // this.startShoulderDislocationBefore = 0.005;\n    // this.ignoreYPos = true;\n    // this.autoDetectHandsBehindHead = true;\n    // this.clampRotationToHead = true;\n    // this.enableDistinctShoulderRotation = true;\n    // this.enableShoulderDislocation = true;\n    // this.handsBehindHead = false;\n    // this.clampingHeadRotation = false;\n    // this.shoulderDislocated = false;\n    // this.shoulderRightRotation;\n    // this.lastAngle = Vector3.zero;\n    // this.leftShoulderAnkerStartLocalPosition = new Vector3();\n    // this.rightShoulderAnkerStartLocalPosition = new Vector3();\n  }\n  /* Start() {\n  \tthis.leftShoulderAnkerStartLocalPosition = this.shoulder.leftShoulderAnchor.localPosition.clone();\n  \tthis.rightShoulderAnkerStartLocalPosition = this.shoulder.rightShoulderAnchor.position.clone();\n  } */\n\n  /* onCalibrate()\n  {\n  \tthis.shoulder.leftArm.setArmLength((avatarTrackingReferences.leftHand.position - this.shoulder.leftShoulderAnchor.position)\n  \t\t.magnitude);\n  \tthis.shoulder.rightArm.setArmLength((avatarTrackingReferences.rightHand.position - this.shoulder.rightShoulderAnchor.position)\n  \t\t.magnitude);\n  } */\n\n\n  Update() {\n    this.shoulder.proneFactor = this.getProneFactor();\n    this.shoulder.prone = this.shoulder.proneFactor > 0;\n\n    if (this.shoulder.prone) {\n      this.shoulder.lastProneTimestamp = Date.now();\n    } else {\n      this.shoulder.lastStandTimestamp = Date.now();\n    }\n\n    this.updateHips(); // this.shoulder.transform.rotation = Quaternion.identity;\n    // this.positionShoulder();\n\n    this.rotateShoulderBase();\n    /* if (this.enableDistinctShoulderRotation)\n    {\n    \tthis.rotateLeftShoulder(rotation);\n    \tthis.rotateRightShoulder(rotation);\n    } */\n\n    /* if (this.enableShoulderDislocation)\n    {\n    \tthis.clampShoulderHandDistance();\n    }\n    else\n    {\n    \tthis.shoulder.leftArm.transform.localPosition = Vector3.zero;\n    \tthis.shoulder.rightArm.transform.localPosition = Vector3.zero;\n    } */\n\n    this.updateNeck(); // Debug.DrawRay(this.shoulder.transform.position, this.shoulder.transform.forward);\n  }\n  /* updateHips() {\n    const hmdRotation = localQuaternion.copy(this.vrTransforms.head.quaternion)\n        .multiply(z180Quaternion);\n      const hmdEuler = localEuler.setFromQuaternion(hmdRotation, 'YXZ');\n      hmdEuler.x = 0;\n      hmdEuler.z = 0;\n      const hmdFlatRotation = localQuaternion2.setFromEuler(hmdEuler);\n       const headPosition = localVector.copy(this.vrTransforms.head.position)\n        .add(localVector2.copy(this.shoulder.eyes.position).multiplyScalar(-1).applyQuaternion(hmdRotation));\n    const neckPosition = headPosition.add(localVector2.copy(this.shoulder.head.position).multiplyScalar(-1).applyQuaternion(hmdRotation));\n    const chestPosition = neckPosition.add(localVector2.copy(this.shoulder.neck.position).multiplyScalar(-1).applyQuaternion(hmdFlatRotation));\n    const spinePosition = chestPosition.add(localVector2.copy(this.shoulder.transform.position).multiplyScalar(-1).applyQuaternion(hmdFlatRotation));\n    const hipsPosition = spinePosition.add(localVector2.copy(this.shoulder.spine.position).multiplyScalar(-1).applyQuaternion(hmdFlatRotation));\n       this.shoulder.hips.position.copy(hipsPosition);\n      this.shoulder.hips.quaternion.copy(hmdFlatRotation);\n      Helpers.updateMatrix(this.shoulder.hips);\n      this.shoulder.hips.matrixWorld.copy(this.shoulder.hips.matrix);\n      Helpers.updateMatrixWorld(this.shoulder.spine);\n      Helpers.updateMatrixWorld(this.shoulder.transform);\n  } */\n\n\n  updateHips() {\n    const hmdRotation = localQuaternion.copy(this.vrTransforms.head.quaternion).multiply(z180Quaternion);\n    /* const hmdXYRotation = localQuaternion2.setFromRotationMatrix(localMatrix.lookAt(\n    \tnew THREE.Vector3(),\n    \tnew THREE.Vector3(0, 0, -1).applyQuaternion(hmdRotation),\n    \tnew THREE.Vector3(0, 1, 0).applyQuaternion(hmdRotation)\n    )); */\n\n    const hmdEuler = localEuler.setFromQuaternion(hmdRotation, 'YXZ');\n    hmdEuler.x = 0;\n    hmdEuler.z = 0;\n    const hmdXYRotation = localQuaternion2.setFromEuler(hmdEuler);\n    hmdXYRotation.multiply(localQuaternion3.setFromAxisAngle(rightVector, this.shoulder.proneFactor * Math.PI / 2));\n\n    if (!this.rig.legsManager.leftLeg.standing && !this.rig.legsManager.rightLeg.standing) {\n      const jumpFactor = 1 - Math.min(this.rig.legsManager.leftLeg.standFactor, this.rig.legsManager.rightLeg.standFactor);\n      hmdXYRotation.multiply(localQuaternion3.setFromAxisAngle(rightVector, jumpFactor * Math.PI / 4));\n    } else {\n      const standFactor = Math.min(this.rig.legsManager.leftLeg.standFactor, this.rig.legsManager.rightLeg.standFactor);\n      hmdXYRotation.multiply(localQuaternion3.setFromAxisAngle(rightVector, (1 - standFactor) * Math.PI / 4));\n    }\n\n    const headPosition = localVector.copy(this.vrTransforms.head.position).sub(localVector2.copy(this.shoulder.eyes.position).applyQuaternion(hmdRotation));\n    const neckPosition = headPosition.sub(localVector2.copy(this.shoulder.head.position).applyQuaternion(hmdRotation));\n    const chestPosition = neckPosition.sub(localVector2.copy(this.shoulder.neck.position).applyQuaternion(hmdXYRotation));\n    const spinePosition = chestPosition.sub(localVector2.copy(this.shoulder.transform.position).applyQuaternion(hmdXYRotation));\n    const hipsPosition = spinePosition.sub(localVector2.copy(this.shoulder.spine.position).applyQuaternion(hmdXYRotation));\n    this.shoulder.hips.position.copy(hipsPosition);\n    this.shoulder.hips.quaternion.copy(hmdXYRotation);\n    Helpers.updateMatrix(this.shoulder.hips);\n    this.shoulder.hips.matrixWorld.copy(this.shoulder.hips.matrix);\n    Helpers.updateMatrixWorld(this.shoulder.spine);\n    Helpers.updateMatrixWorld(this.shoulder.transform);\n  }\n  /* updateNeck() {\n  \tconst hmdRotation = localQuaternion.copy(this.vrTransforms.head.quaternion)\n      .multiply(z180Quaternion);\n      const hmdFlatEuler = localEuler.setFromQuaternion(hmdRotation, 'YXZ');\n      hmdFlatEuler.x = 0;\n      hmdFlatEuler.z = 0;\n      const hmdUpEuler = localEuler2.setFromQuaternion(hmdRotation, 'YXZ');\n      hmdUpEuler.y = 0;\n       this.shoulder.neck.quaternion.setFromEuler(hmdFlatEuler)\n        .premultiply(Helpers.getWorldQuaternion(this.shoulder.neck.parent, localQuaternion).inverse());\n      Helpers.updateMatrixMatrixWorld(this.shoulder.neck);\n       this.shoulder.head.quaternion.setFromEuler(hmdUpEuler);\n      Helpers.updateMatrixMatrixWorld(this.shoulder.head);\n       Helpers.updateMatrixWorld(this.shoulder.eyes);\n  } */\n\n\n  updateNeck() {\n    const hmdRotation = localQuaternion.copy(this.vrTransforms.head.quaternion).multiply(z180Quaternion);\n    /* const hmdXYRotation = localQuaternion2.setFromRotationMatrix(localMatrix.lookAt(\n      \tnew THREE.Vector3(),\n      \tnew THREE.Vector3(0, 0, -1).applyQuaternion(hmdRotation),\n      \tnew THREE.Vector3(0, 1, 0).applyQuaternion(hmdRotation)\n      )); */\n\n    const hmdEuler = localEuler.setFromQuaternion(hmdRotation, 'YXZ');\n    hmdEuler.x = 0;\n    hmdEuler.z = 0;\n    const hmdXYRotation = localQuaternion2.setFromEuler(hmdEuler);\n    this.shoulder.neck.quaternion.copy(hmdXYRotation).premultiply(Helpers.getWorldQuaternion(this.shoulder.neck.parent, localQuaternion3).inverse());\n    Helpers.updateMatrixMatrixWorld(this.shoulder.neck);\n    this.shoulder.head.quaternion.copy(hmdRotation).premultiply(Helpers.getWorldQuaternion(this.shoulder.head.parent, localQuaternion3).inverse());\n    Helpers.updateMatrixMatrixWorld(this.shoulder.head);\n    Helpers.updateMatrixWorld(this.shoulder.eyes);\n  }\n  /* rotateLeftShoulder(shoulderRotation)\n  {\n  \tthis.rotateShoulderUp(this.shoulder.leftShoulder, this.shoulder.leftArm, this.avatarTrackingReferences.leftHand, this.leftShoulderAnkerStartLocalPosition, 1, shoulderRotation);\n  }\n  \trotateRightShoulder(shoulderRotation)\n  {\n  \tthis.rotateShoulderUp(this.shoulder.rightShoulder, this.shoulder.rightArm, this.avatarTrackingReferences.rightHand, this.rightShoulderAnkerStartLocalPosition, -1, shoulderRotation);\n  }\n  \trotateShoulderUp(shoulderSide, arm, targetHand, initialShoulderLocalPos, angleSign, shoulderRotation)\n  {\n  \tconst initialShoulderPos = initialShoulderLocalPos.clone().applyMatrix4(this.shoulder.transform.matrixWorld);\n  \tconst handShoulderOffset = new Vector3().subVectors(targetHand.position, initialShoulderPos);\n  \tconst armLength = arm.armLength;\n  \t\tconst targetAngle = Vector3.zero;\n  \t  const forwardDistanceRatio = Vector3.Dot(handShoulderOffset, Vector3.forward.applyQuaternion(shoulderRotation)) / armLength;\n  \tconst upwardDistanceRatio = Vector3.Dot(handShoulderOffset, Vector3.up.applyQuaternion(shoulderRotation)) / armLength;\n  \tif (forwardDistanceRatio > 0)\n  \t{\n  \t\ttargetAngle.y = Mathf.Clamp((forwardDistanceRatio - 0.5) * this.distinctShoulderRotationMultiplier, 0, this.distinctShoulderRotationLimitForward);\n  \t}\n  \telse\n  \t{\n  \t\ttargetAngle.y = Mathf.Clamp(-(forwardDistanceRatio + 0.08) * this.distinctShoulderRotationMultiplier * 10, -this.distinctShoulderRotationLimitBackward, 0);\n  \t}\n  \t\ttargetAngle.z = Mathf.Clamp(-(upwardDistanceRatio - 0.5) * this.distinctShoulderRotationMultiplier, -this.distinctShoulderRotationLimitUpward, 0);\n       targetAngle.multiplyScalar(angleSign);\n       shoulderSide.localRotation = new THREE.Quaternion().setFromEuler(new THREE.Euler(targetAngle.x * Mathf.Deg2Rad, targetAngle.y * Mathf.Deg2Rad, targetAngle.z * Mathf.Deg2Rad, Mathf.Order));\n  }\n  \tpositionShoulder()\n  {\n  \tconst headNeckOffset = this.headNeckDirectionVector.clone().applyQuaternion(this.avatarTrackingReferences.head.rotation);\n  \tconst targetPosition = new Vector3().addVectors(this.avatarTrackingReferences.head.position, headNeckOffset.clone().multiplyScalar(this.headNeckDistance));\n  \tthis.shoulder.transform.localPosition =\n  \t\tnew Vector3().addVectors(targetPosition, this.neckShoulderDistance);\n  } */\n\n\n  rotateShoulderBase() {\n    const angleY = this.getCombinedDirectionAngleUp(); // const targetRotation = new Vector3(0, angle, 0);\n\n    /* if (this.autoDetectHandsBehindHead)\n    {\n    \tthis.detectHandsBehindHead(targetRotation);\n    } */\n\n    /* if (this.clampRotationToHead)\n    { */\n    // angleY = this.clampHeadRotationDeltaUp(angleY);\n    // }\n\n    this.shoulder.transform.quaternion.setFromEuler(localEuler.set(0, angleY, 0, 'YXZ')).premultiply(localQuaternion.copy(this.shoulder.hips.quaternion).multiply(z180Quaternion));\n    /* this.shoulder.transform.quaternion.multiply(localQuaternion3.setFromAxisAngle(rightVector, this.shoulder.proneFactor * Math.PI/2));\n    if (!this.rig.legsManager.leftLeg.standing && !this.rig.legsManager.rightLeg.standing) {\n         const jumpFactor = 1-Math.min(this.rig.legsManager.leftLeg.standFactor, this.rig.legsManager.rightLeg.standFactor);\n         this.shoulder.transform.quaternion.multiply(localQuaternion3.setFromAxisAngle(rightVector, jumpFactor * Math.PI/4));\n       } else {\n       \tconst standFactor = Math.min(this.rig.legsManager.leftLeg.standFactor, this.rig.legsManager.rightLeg.standFactor);\n       \tthis.shoulder.transform.quaternion.multiply(localQuaternion3.setFromAxisAngle(rightVector, (1-standFactor) * Math.PI/4));\n       } */\n\n    this.shoulder.transform.quaternion.premultiply(Helpers.getWorldQuaternion(this.shoulder.transform.parent, localQuaternion).inverse());\n    Helpers.updateMatrixMatrixWorld(this.shoulder.transform);\n    Helpers.updateMatrixWorld(this.shoulder.leftShoulderAnchor);\n    Helpers.updateMatrixWorld(this.shoulder.rightShoulderAnchor);\n  }\n  /* rotateShoulderRightBase(rotation)\n  {\n  \t\tconst heightDiff = this.vrTransforms.head.position.y - this.poseManager.vrSystemOffsetHeight;\n  \tconst relativeHeightDiff = -heightDiff / this.poseManager.playerHeightHmd;\n       const hmdRotation = this.vrTransforms.head.rotation;\n      hmdRotation.multiply(z180Quaternion);\n  \tconst headRightRotation = VectorHelpers.getAngleBetween(this.shoulder.transform.forward,\n  \t\t\t\t\t\t\t\t  new Vector3(0, 0, 1).applyQuaternion(hmdRotation),\n  \t\t\t\t\t\t\t\t  Vector3.up, this.shoulder.transform.right) + this.rightRotationHeadRotationOffset;\n  \tconst heightFactor = Mathf.Clamp(relativeHeightDiff - this.rightRotationStartHeight, 0, 1);\n  \tthis.shoulderRightRotation = heightFactor * this.rightRotationHeightFactor;\n  \tthis.shoulderRightRotation += Mathf.Clamp(headRightRotation * this.rightRotationHeadRotationFactor * heightFactor, 0, 50);\n             this.shoulderRightRotation = Mathf.Clamp(this.shoulderRightRotation, 0, 50);\n  \t\tconst deltaRot = Quaternion.AngleAxis(this.shoulderRightRotation, this.shoulder.transform.right);\n  \t\t\t// this.shoulder.transform.rotation = new Quaternion().multiplyQuaternions(deltaRot,  this.shoulder.transform.rotation);\n  \treturn new Quaternion().multiplyQuaternions(deltaRot, rotation);\n  \t// this.positionShoulderRelative();\n  }\n  \tpositionShoulderRelative()\n  {\n  \tconst deltaRot = Quaternion.AngleAxis(this.shoulderRightRotation, this.shoulder.transform.right);\n  \tconst shoulderHeadDiff = new Vector3().subVectors(this.shoulder.transform.position, this.avatarTrackingReferences.head.position);\n    // this.shoulder.transform.position = new Vector3().addVectors(shoulderHeadDiff.clone().applyQuaternion(deltaRot), this.avatarTrackingReferences.head.position);\n  } */\n\n\n  getCombinedDirectionAngleUp() {\n    const hipsRotation = localQuaternion.copy(this.shoulder.hips.quaternion).multiply(z180Quaternion);\n    const hipsRotationInverse = localQuaternion2.copy(hipsRotation).inverse();\n    const distanceLeftHand = localVector.copy(this.vrTransforms.leftHand.position).sub(this.vrTransforms.head.position).applyQuaternion(hipsRotationInverse);\n    const distanceRightHand = localVector2.copy(this.vrTransforms.rightHand.position).sub(this.vrTransforms.head.position).applyQuaternion(hipsRotationInverse);\n    distanceLeftHand.y = 0;\n    distanceRightHand.y = 0;\n    const leftBehind = distanceLeftHand.z > 0;\n    const rightBehind = distanceRightHand.z > 0;\n\n    if (leftBehind) {\n      distanceLeftHand.z *= rightBehind ? -2 : -1;\n    }\n\n    if (rightBehind) {\n      distanceRightHand.z *= leftBehind ? -2 : -1;\n    }\n\n    const combinedDirection = localVector.addVectors(distanceLeftHand.normalize(), distanceRightHand.normalize());\n    return Math.atan2(combinedDirection.x, combinedDirection.z);\n  }\n\n  getProneFactor() {\n    return 1 - Math.min(Math.max((this.vrTransforms.head.position.y - this.rig.height * 0.3) / (this.rig.height * 0.3), 0), 1);\n  }\n  /* detectHandsBehindHead(targetRotation)\n  {\n  \tconst delta = Mathf.Abs(targetRotation.y - this.lastAngle.y + 360) % 360;\n  \tif (delta > 150 && delta < 210 && this.lastAngle.magnitude > 0.000001 && !this.clampingHeadRotation)\n  \t{\n  \t\tthis.handsBehindHead = !this.handsBehindHead;\n  \t}\n  \t\tthis.lastAngle = targetRotation;\n  \t\tif (this.handsBehindHead)\n  \t{\n  \t\ttargetRotation.y += 180;\n  \t}\n  }\n  \tclampHeadRotationDeltaUp(angleY)\n  {\n  \tconst hmdRotation = localQuaternion.copy(this.vrTransforms.head.quaternion)\n  \t  .multiply(z180Quaternion);\n  \t\tconst headUpRotation = (localEuler.setFromQuaternion(hmdRotation, 'YXZ').y + Math.PI*2) % (Math.PI*2);\n  \tconst targetUpRotation = (angleY + Math.PI*2) % (Math.PI*2);\n  \t\tconst delta = headUpRotation - targetUpRotation;\n  \t\tif (delta > this.maxDeltaHeadRotation && delta < Math.PI || delta < -Math.PI && delta >= -Math.PI*2 + this.maxDeltaHeadRotation)\n  \t{\n  \t\tangleY = headUpRotation - this.maxDeltaHeadRotation;\n  \t\t// this.clampingHeadRotation = true;\n  \t}\n  \telse if (delta < -this.maxDeltaHeadRotation && delta > -Math.PI || delta > Math.PI && delta < Math.PI*2 - this.maxDeltaHeadRotation)\n  \t{\n  \t\tangleY = headUpRotation + this.maxDeltaHeadRotation;\n  \t\t// this.clampingHeadRotation = true;\n  \t}\n  \t// else\n  \t// {\n  \t\t// this.clampingHeadRotation = false;\n  \t// }\n  \treturn angleY;\n  }\n  \tclampShoulderHandDistance()\n  {\n  \tconst leftHandVector = new Vector3().subVectors(this.avatarTrackingReferences.leftHand.position, this.shoulder.leftShoulderAnchor.position);\n  \tconst rightHandVector = new Vector3().subVectors(this.avatarTrackingReferences.rightHand.position, this.shoulder.rightShoulderAnchor.position);\n  \tconst leftShoulderHandDistance = leftHandVector.magnitude;\n      const rightShoulderHandDistance = rightHandVector.magnitude;\n  \tthis.shoulderDislocated = false;\n  \t  const startBeforeFactor = (1 - this.startShoulderDislocationBefore);\n  \t\tif (leftShoulderHandDistance > this.shoulder.leftArm.armLength * startBeforeFactor)\n  \t{\n  \t\tthis.shoulderDislocated = true;\n  \t\tthis.shoulder.leftArm.transform.position = new Vector3().addVectors(this.shoulder.leftShoulderAnchor.position,\n  \t\t\t\t\t\t\t\t\t\t\t  leftHandVector.normalized.multiplyScalar(leftShoulderHandDistance - this.shoulder.leftArm.armLength * startBeforeFactor));\n  \t}\n  \telse\n  \t{\n  \t\tthis.shoulder.leftArm.transform.localPosition = Vector3.zero;\n  \t}\n  \t\tif (rightShoulderHandDistance > this.shoulder.rightArm.armLength * startBeforeFactor)\n  \t{\n  \t\tthis.shoulderDislocated = true;\n  \t\tthis.shoulder.rightArm.transform.position = new Vector3().addVectors(this.shoulder.rightShoulderAnchor.position,\n  \t\t\t\t\t\t\t\t\t\t\t   rightHandVector.normalized.multiplyScalar(rightShoulderHandDistance - this.shoulder.rightArm.armLength * startBeforeFactor));\n  \t}\n  \telse\n  \t{\n  \t\tthis.shoulder.rightArm.transform.localPosition = Vector3.zero;\n  \t}\n  } */\n\n\n}\n\nexport default ShoulderPoser;","map":{"version":3,"sources":["/Users/chris/Documents/Github/test-react/src/WebXRApps/vrarmik/ShoulderPoser.js"],"names":["Helpers","THREE","rightVector","Vector3","z180Quaternion","Quaternion","setFromAxisAngle","Math","PI","localVector","localVector2","localVector3","localVector4","localQuaternion","localQuaternion2","localQuaternion3","localEuler","Euler","localEuler2","ShoulderPoser","constructor","rig","shoulder","poseManager","vrTransforms","Update","proneFactor","getProneFactor","prone","lastProneTimestamp","Date","now","lastStandTimestamp","updateHips","rotateShoulderBase","updateNeck","hmdRotation","copy","head","quaternion","multiply","hmdEuler","setFromQuaternion","x","z","hmdXYRotation","setFromEuler","legsManager","leftLeg","standing","rightLeg","jumpFactor","min","standFactor","headPosition","position","sub","eyes","applyQuaternion","neckPosition","chestPosition","neck","spinePosition","transform","hipsPosition","spine","hips","updateMatrix","matrixWorld","matrix","updateMatrixWorld","premultiply","getWorldQuaternion","parent","inverse","updateMatrixMatrixWorld","angleY","getCombinedDirectionAngleUp","set","leftShoulderAnchor","rightShoulderAnchor","hipsRotation","hipsRotationInverse","distanceLeftHand","leftHand","distanceRightHand","rightHand","y","leftBehind","rightBehind","combinedDirection","addVectors","normalize","atan2","max","height"],"mappings":"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","sourcesContent":["import {Helpers} from './Unity.js';\nimport THREE from 'three.js'\n\nconst rightVector = new THREE.Vector3(1, 0, 0);\nconst z180Quaternion = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), Math.PI);\n\nconst localVector = new THREE.Vector3();\nconst localVector2 = new THREE.Vector3();\nconst localVector3 = new THREE.Vector3();\nconst localVector4 = new THREE.Vector3();\nconst localQuaternion = new THREE.Quaternion();\nconst localQuaternion2 = new THREE.Quaternion();\nconst localQuaternion3 = new THREE.Quaternion();\nconst localEuler = new THREE.Euler();\nconst localEuler2 = new THREE.Euler();\n\nclass ShoulderPoser\n\t{\n\t\tconstructor(rig, shoulder) {\n\t\t\tthis.rig = rig;\n\t\t\tthis.shoulder = shoulder;\n\t\t\tthis.poseManager = rig.poseManager;\n\t\t\tthis.vrTransforms = this.poseManager.vrTransforms;\n\n      // this.headNeckDirectionVector = new Vector3(1.0894440904962721e-10, -0.06860782711996793, -0.0006757629250115499).normalize();\n\t\t\t// this.headNeckDistance = 0.06861115505261682;\n\t\t\t// this.neckShoulderDistance = new Vector3(3.122724301363178e-10, -0.1953215129534993, 0.02834002902116923);\n\n\t\t\t// this.maxDeltaHeadRotation = 80;\n\n\t\t\t// this.distinctShoulderRotationLimitForward = 33;\n\n\t\t\t// this.distinctShoulderRotationLimitBackward = 0;\n\n\t\t\t// this.distinctShoulderRotationLimitUpward = 33;\n\t\t\t// this.distinctShoulderRotationMultiplier = 30;\n\n\t  \t// this.rightRotationStartHeight = 0;\n\t\t\t// this.rightRotationHeightFactor = 142;\n\t\t\t// this.rightRotationHeadRotationFactor = 0.3;\n\t\t\t// this.rightRotationHeadRotationOffset = -20;\n\n\t\t\t// this.startShoulderDislocationBefore = 0.005;\n\n\t\t\t// this.ignoreYPos = true;\n\t\t  // this.autoDetectHandsBehindHead = true;\n\t\t\t// this.clampRotationToHead = true;\n\t\t  // this.enableDistinctShoulderRotation = true;\n\t\t\t// this.enableShoulderDislocation = true;\n\n\n\t\t\t// this.handsBehindHead = false;\n\n\t\t\t// this.clampingHeadRotation = false;\n\t\t\t// this.shoulderDislocated = false;\n\t\t\t// this.shoulderRightRotation;\n\n\t\t\t// this.lastAngle = Vector3.zero;\n\n\t\t\t// this.leftShoulderAnkerStartLocalPosition = new Vector3();\n\t\t\t// this.rightShoulderAnkerStartLocalPosition = new Vector3();\n\t\t}\n\n\t\t/* Start() {\n\t\t\tthis.leftShoulderAnkerStartLocalPosition = this.shoulder.leftShoulderAnchor.localPosition.clone();\n\t\t\tthis.rightShoulderAnkerStartLocalPosition = this.shoulder.rightShoulderAnchor.position.clone();\n\t\t} */\n\n\t\t/* onCalibrate()\n\t\t{\n\t\t\tthis.shoulder.leftArm.setArmLength((avatarTrackingReferences.leftHand.position - this.shoulder.leftShoulderAnchor.position)\n\t\t\t\t.magnitude);\n\t\t\tthis.shoulder.rightArm.setArmLength((avatarTrackingReferences.rightHand.position - this.shoulder.rightShoulderAnchor.position)\n\t\t\t\t.magnitude);\n\t\t} */\n\n\t\tUpdate()\n\t\t{\n      this.shoulder.proneFactor = this.getProneFactor();\n      this.shoulder.prone = this.shoulder.proneFactor > 0;\n      if (this.shoulder.prone) {\n        this.shoulder.lastProneTimestamp = Date.now();\n      } else {\n        this.shoulder.lastStandTimestamp = Date.now();\n      }\n\n      this.updateHips();\n\n\t\t\t// this.shoulder.transform.rotation = Quaternion.identity;\n\t\t\t// this.positionShoulder();\n\t\t\tthis.rotateShoulderBase();\n\n\t\t\t/* if (this.enableDistinctShoulderRotation)\n\t\t\t{\n\t\t\t\tthis.rotateLeftShoulder(rotation);\n\t\t\t\tthis.rotateRightShoulder(rotation);\n\t\t\t} */\n\n\t\t\t/* if (this.enableShoulderDislocation)\n\t\t\t{\n\t\t\t\tthis.clampShoulderHandDistance();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.shoulder.leftArm.transform.localPosition = Vector3.zero;\n\t\t\t\tthis.shoulder.rightArm.transform.localPosition = Vector3.zero;\n\t\t\t} */\n\n\t\t\tthis.updateNeck();\n\n\t\t\t// Debug.DrawRay(this.shoulder.transform.position, this.shoulder.transform.forward);\n\t\t}\n\n\t\t/* updateHips() {\n\t\t  const hmdRotation = localQuaternion.copy(this.vrTransforms.head.quaternion)\n        .multiply(z180Quaternion);\n      const hmdEuler = localEuler.setFromQuaternion(hmdRotation, 'YXZ');\n      hmdEuler.x = 0;\n      hmdEuler.z = 0;\n      const hmdFlatRotation = localQuaternion2.setFromEuler(hmdEuler);\n\n      const headPosition = localVector.copy(this.vrTransforms.head.position)\n        .add(localVector2.copy(this.shoulder.eyes.position).multiplyScalar(-1).applyQuaternion(hmdRotation));\n\t\t  const neckPosition = headPosition.add(localVector2.copy(this.shoulder.head.position).multiplyScalar(-1).applyQuaternion(hmdRotation));\n\t\t  const chestPosition = neckPosition.add(localVector2.copy(this.shoulder.neck.position).multiplyScalar(-1).applyQuaternion(hmdFlatRotation));\n\t\t  const spinePosition = chestPosition.add(localVector2.copy(this.shoulder.transform.position).multiplyScalar(-1).applyQuaternion(hmdFlatRotation));\n\t\t  const hipsPosition = spinePosition.add(localVector2.copy(this.shoulder.spine.position).multiplyScalar(-1).applyQuaternion(hmdFlatRotation));\n\n      this.shoulder.hips.position.copy(hipsPosition);\n      this.shoulder.hips.quaternion.copy(hmdFlatRotation);\n      Helpers.updateMatrix(this.shoulder.hips);\n      this.shoulder.hips.matrixWorld.copy(this.shoulder.hips.matrix);\n      Helpers.updateMatrixWorld(this.shoulder.spine);\n      Helpers.updateMatrixWorld(this.shoulder.transform);\n\t\t} */\n\n\t\tupdateHips() {\n\t\t  const hmdRotation = localQuaternion.copy(this.vrTransforms.head.quaternion)\n        .multiply(z180Quaternion);\n      /* const hmdXYRotation = localQuaternion2.setFromRotationMatrix(localMatrix.lookAt(\n      \tnew THREE.Vector3(),\n      \tnew THREE.Vector3(0, 0, -1).applyQuaternion(hmdRotation),\n      \tnew THREE.Vector3(0, 1, 0).applyQuaternion(hmdRotation)\n      )); */\n      const hmdEuler = localEuler.setFromQuaternion(hmdRotation, 'YXZ');\n      hmdEuler.x = 0;\n      hmdEuler.z = 0;\n      const hmdXYRotation = localQuaternion2.setFromEuler(hmdEuler);\n      hmdXYRotation.multiply(localQuaternion3.setFromAxisAngle(rightVector, this.shoulder.proneFactor * Math.PI/2));\n      if (!this.rig.legsManager.leftLeg.standing && !this.rig.legsManager.rightLeg.standing) {\n        const jumpFactor = 1-Math.min(this.rig.legsManager.leftLeg.standFactor, this.rig.legsManager.rightLeg.standFactor);\n        hmdXYRotation.multiply(localQuaternion3.setFromAxisAngle(rightVector, jumpFactor * Math.PI/4));\n      } else {\n      \tconst standFactor = Math.min(this.rig.legsManager.leftLeg.standFactor, this.rig.legsManager.rightLeg.standFactor);\n      \thmdXYRotation.multiply(localQuaternion3.setFromAxisAngle(rightVector, (1-standFactor) * Math.PI/4));\n      }\n\n      const headPosition = localVector.copy(this.vrTransforms.head.position)\n        .sub(localVector2.copy(this.shoulder.eyes.position).applyQuaternion(hmdRotation));\n\t\t  const neckPosition = headPosition.sub(localVector2.copy(this.shoulder.head.position).applyQuaternion(hmdRotation));\n\t\t  const chestPosition = neckPosition.sub(localVector2.copy(this.shoulder.neck.position).applyQuaternion(hmdXYRotation));\n\t\t  const spinePosition = chestPosition.sub(localVector2.copy(this.shoulder.transform.position).applyQuaternion(hmdXYRotation));\n\t\t  const hipsPosition = spinePosition.sub(localVector2.copy(this.shoulder.spine.position).applyQuaternion(hmdXYRotation));\n\n      this.shoulder.hips.position.copy(hipsPosition);\n      this.shoulder.hips.quaternion.copy(hmdXYRotation);\n      Helpers.updateMatrix(this.shoulder.hips);\n      this.shoulder.hips.matrixWorld.copy(this.shoulder.hips.matrix);\n      Helpers.updateMatrixWorld(this.shoulder.spine);\n      Helpers.updateMatrixWorld(this.shoulder.transform);\n\t\t}\n\n\t\t/* updateNeck() {\n\t\t\tconst hmdRotation = localQuaternion.copy(this.vrTransforms.head.quaternion)\n\t\t    .multiply(z180Quaternion);\n      const hmdFlatEuler = localEuler.setFromQuaternion(hmdRotation, 'YXZ');\n      hmdFlatEuler.x = 0;\n      hmdFlatEuler.z = 0;\n      const hmdUpEuler = localEuler2.setFromQuaternion(hmdRotation, 'YXZ');\n      hmdUpEuler.y = 0;\n\n      this.shoulder.neck.quaternion.setFromEuler(hmdFlatEuler)\n        .premultiply(Helpers.getWorldQuaternion(this.shoulder.neck.parent, localQuaternion).inverse());\n      Helpers.updateMatrixMatrixWorld(this.shoulder.neck);\n\n      this.shoulder.head.quaternion.setFromEuler(hmdUpEuler);\n      Helpers.updateMatrixMatrixWorld(this.shoulder.head);\n\n      Helpers.updateMatrixWorld(this.shoulder.eyes);\n\t\t} */\n\n\t\tupdateNeck() {\n\t\t\tconst hmdRotation = localQuaternion.copy(this.vrTransforms.head.quaternion)\n\t\t    .multiply(z180Quaternion);\n\t\t  /* const hmdXYRotation = localQuaternion2.setFromRotationMatrix(localMatrix.lookAt(\n      \tnew THREE.Vector3(),\n      \tnew THREE.Vector3(0, 0, -1).applyQuaternion(hmdRotation),\n      \tnew THREE.Vector3(0, 1, 0).applyQuaternion(hmdRotation)\n      )); */\n      const hmdEuler = localEuler.setFromQuaternion(hmdRotation, 'YXZ');\n      hmdEuler.x = 0;\n      hmdEuler.z = 0;\n      const hmdXYRotation = localQuaternion2.setFromEuler(hmdEuler);\n\n      this.shoulder.neck.quaternion.copy(hmdXYRotation)\n        .premultiply(Helpers.getWorldQuaternion(this.shoulder.neck.parent, localQuaternion3).inverse());\n      Helpers.updateMatrixMatrixWorld(this.shoulder.neck);\n\n      this.shoulder.head.quaternion.copy(hmdRotation)\n        .premultiply(Helpers.getWorldQuaternion(this.shoulder.head.parent, localQuaternion3).inverse());\n      Helpers.updateMatrixMatrixWorld(this.shoulder.head);\n\n      Helpers.updateMatrixWorld(this.shoulder.eyes);\n\t\t}\n\n\t\t/* rotateLeftShoulder(shoulderRotation)\n\t\t{\n\t\t\tthis.rotateShoulderUp(this.shoulder.leftShoulder, this.shoulder.leftArm, this.avatarTrackingReferences.leftHand, this.leftShoulderAnkerStartLocalPosition, 1, shoulderRotation);\n\t\t}\n\n\t\trotateRightShoulder(shoulderRotation)\n\t\t{\n\t\t\tthis.rotateShoulderUp(this.shoulder.rightShoulder, this.shoulder.rightArm, this.avatarTrackingReferences.rightHand, this.rightShoulderAnkerStartLocalPosition, -1, shoulderRotation);\n\t\t}\n\n\t\trotateShoulderUp(shoulderSide, arm, targetHand, initialShoulderLocalPos, angleSign, shoulderRotation)\n\t\t{\n\t\t\tconst initialShoulderPos = initialShoulderLocalPos.clone().applyMatrix4(this.shoulder.transform.matrixWorld);\n\t\t\tconst handShoulderOffset = new Vector3().subVectors(targetHand.position, initialShoulderPos);\n\t\t\tconst armLength = arm.armLength;\n\n\t\t\tconst targetAngle = Vector3.zero;\n\n\t\t  const forwardDistanceRatio = Vector3.Dot(handShoulderOffset, Vector3.forward.applyQuaternion(shoulderRotation)) / armLength;\n\t\t\tconst upwardDistanceRatio = Vector3.Dot(handShoulderOffset, Vector3.up.applyQuaternion(shoulderRotation)) / armLength;\n\t\t\tif (forwardDistanceRatio > 0)\n\t\t\t{\n\t\t\t\ttargetAngle.y = Mathf.Clamp((forwardDistanceRatio - 0.5) * this.distinctShoulderRotationMultiplier, 0, this.distinctShoulderRotationLimitForward);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttargetAngle.y = Mathf.Clamp(-(forwardDistanceRatio + 0.08) * this.distinctShoulderRotationMultiplier * 10, -this.distinctShoulderRotationLimitBackward, 0);\n\t\t\t}\n\n\t\t\ttargetAngle.z = Mathf.Clamp(-(upwardDistanceRatio - 0.5) * this.distinctShoulderRotationMultiplier, -this.distinctShoulderRotationLimitUpward, 0);\n\n      targetAngle.multiplyScalar(angleSign);\n\n      shoulderSide.localRotation = new THREE.Quaternion().setFromEuler(new THREE.Euler(targetAngle.x * Mathf.Deg2Rad, targetAngle.y * Mathf.Deg2Rad, targetAngle.z * Mathf.Deg2Rad, Mathf.Order));\n\t\t}\n\n\t\tpositionShoulder()\n\t\t{\n\t\t\tconst headNeckOffset = this.headNeckDirectionVector.clone().applyQuaternion(this.avatarTrackingReferences.head.rotation);\n\t\t\tconst targetPosition = new Vector3().addVectors(this.avatarTrackingReferences.head.position, headNeckOffset.clone().multiplyScalar(this.headNeckDistance));\n\t\t\tthis.shoulder.transform.localPosition =\n\t\t\t\tnew Vector3().addVectors(targetPosition, this.neckShoulderDistance);\n\t\t} */\n\n\t\trotateShoulderBase()\n\t\t{\n\t\t\tconst angleY = this.getCombinedDirectionAngleUp();\n\n\t\t\t// const targetRotation = new Vector3(0, angle, 0);\n\n\t\t\t/* if (this.autoDetectHandsBehindHead)\n\t\t\t{\n\t\t\t\tthis.detectHandsBehindHead(targetRotation);\n\t\t\t} */\n\n\t\t\t/* if (this.clampRotationToHead)\n\t\t\t{ */\n\t\t\t\t// angleY = this.clampHeadRotationDeltaUp(angleY);\n\t\t\t// }\n\n\t\t\tthis.shoulder.transform.quaternion.setFromEuler(localEuler.set(0, angleY, 0, 'YXZ'))\n\t\t\t  .premultiply(\n\t\t\t  \tlocalQuaternion.copy(this.shoulder.hips.quaternion)\n\t\t\t      .multiply(z180Quaternion)\n\t\t\t  );\n\t\t\t/* this.shoulder.transform.quaternion.multiply(localQuaternion3.setFromAxisAngle(rightVector, this.shoulder.proneFactor * Math.PI/2));\n\t\t\tif (!this.rig.legsManager.leftLeg.standing && !this.rig.legsManager.rightLeg.standing) {\n        const jumpFactor = 1-Math.min(this.rig.legsManager.leftLeg.standFactor, this.rig.legsManager.rightLeg.standFactor);\n        this.shoulder.transform.quaternion.multiply(localQuaternion3.setFromAxisAngle(rightVector, jumpFactor * Math.PI/4));\n      } else {\n      \tconst standFactor = Math.min(this.rig.legsManager.leftLeg.standFactor, this.rig.legsManager.rightLeg.standFactor);\n      \tthis.shoulder.transform.quaternion.multiply(localQuaternion3.setFromAxisAngle(rightVector, (1-standFactor) * Math.PI/4));\n      } */\n      this.shoulder.transform.quaternion\n\t\t\t  .premultiply(Helpers.getWorldQuaternion(this.shoulder.transform.parent, localQuaternion).inverse());\n\t\t\tHelpers.updateMatrixMatrixWorld(this.shoulder.transform);\n      Helpers.updateMatrixWorld(this.shoulder.leftShoulderAnchor);\n      Helpers.updateMatrixWorld(this.shoulder.rightShoulderAnchor);\n\t\t}\n\n\t\t/* rotateShoulderRightBase(rotation)\n\t\t{\n\n\t\t\tconst heightDiff = this.vrTransforms.head.position.y - this.poseManager.vrSystemOffsetHeight;\n\t\t\tconst relativeHeightDiff = -heightDiff / this.poseManager.playerHeightHmd;\n\n      const hmdRotation = this.vrTransforms.head.rotation;\n      hmdRotation.multiply(z180Quaternion);\n\t\t\tconst headRightRotation = VectorHelpers.getAngleBetween(this.shoulder.transform.forward,\n\t\t\t\t\t\t\t\t\t\t  new Vector3(0, 0, 1).applyQuaternion(hmdRotation),\n\t\t\t\t\t\t\t\t\t\t  Vector3.up, this.shoulder.transform.right) + this.rightRotationHeadRotationOffset;\n\t\t\tconst heightFactor = Mathf.Clamp(relativeHeightDiff - this.rightRotationStartHeight, 0, 1);\n\t\t\tthis.shoulderRightRotation = heightFactor * this.rightRotationHeightFactor;\n\t\t\tthis.shoulderRightRotation += Mathf.Clamp(headRightRotation * this.rightRotationHeadRotationFactor * heightFactor, 0, 50);\n\n            this.shoulderRightRotation = Mathf.Clamp(this.shoulderRightRotation, 0, 50);\n\n\t\t\tconst deltaRot = Quaternion.AngleAxis(this.shoulderRightRotation, this.shoulder.transform.right);\n\n\n\t\t\t// this.shoulder.transform.rotation = new Quaternion().multiplyQuaternions(deltaRot,  this.shoulder.transform.rotation);\n\t\t\treturn new Quaternion().multiplyQuaternions(deltaRot, rotation);\n\t\t\t// this.positionShoulderRelative();\n\t\t}\n\n\t\tpositionShoulderRelative()\n\t\t{\n\t\t\tconst deltaRot = Quaternion.AngleAxis(this.shoulderRightRotation, this.shoulder.transform.right);\n\t\t\tconst shoulderHeadDiff = new Vector3().subVectors(this.shoulder.transform.position, this.avatarTrackingReferences.head.position);\n\t\t  // this.shoulder.transform.position = new Vector3().addVectors(shoulderHeadDiff.clone().applyQuaternion(deltaRot), this.avatarTrackingReferences.head.position);\n\t\t} */\n\n\t\tgetCombinedDirectionAngleUp()\n\t\t{\n\t\t\tconst hipsRotation = localQuaternion.copy(this.shoulder.hips.quaternion)\n        .multiply(z180Quaternion);\n\t\t\tconst hipsRotationInverse = localQuaternion2.copy(hipsRotation)\n\t\t\t  .inverse();\n\n\t\t\tconst distanceLeftHand = localVector.copy(this.vrTransforms.leftHand.position)\n\t\t\t  .sub(this.vrTransforms.head.position)\n\t\t\t  .applyQuaternion(hipsRotationInverse);\n\t\t\tconst distanceRightHand = localVector2.copy(this.vrTransforms.rightHand.position)\n\t\t\t  .sub(this.vrTransforms.head.position)\n\t\t\t  .applyQuaternion(hipsRotationInverse);\n\n\t\t\tdistanceLeftHand.y = 0;\n\t\t\tdistanceRightHand.y = 0;\n\n\t\t\tconst leftBehind = distanceLeftHand.z > 0;\n\t\t\tconst rightBehind = distanceRightHand.z > 0;\n\t\t\tif (leftBehind) {\n\t\t\t\tdistanceLeftHand.z *= rightBehind ? -2 : -1;\n\t\t\t}\n\t\t\tif (rightBehind) {\n\t\t\t\tdistanceRightHand.z *= leftBehind ? -2 : -1;\n\t\t\t}\n\n\t\t\tconst combinedDirection = localVector.addVectors(distanceLeftHand.normalize(), distanceRightHand.normalize());\n\t\t\treturn Math.atan2(combinedDirection.x, combinedDirection.z);\n\t\t}\n\n\t\tgetProneFactor() {\n      return 1 - Math.min(Math.max((this.vrTransforms.head.position.y - this.rig.height*0.3)/(this.rig.height*0.3), 0), 1);\n\t\t}\n\n\t\t/* detectHandsBehindHead(targetRotation)\n\t\t{\n\t\t\tconst delta = Mathf.Abs(targetRotation.y - this.lastAngle.y + 360) % 360;\n\t\t\tif (delta > 150 && delta < 210 && this.lastAngle.magnitude > 0.000001 && !this.clampingHeadRotation)\n\t\t\t{\n\t\t\t\tthis.handsBehindHead = !this.handsBehindHead;\n\t\t\t}\n\n\t\t\tthis.lastAngle = targetRotation;\n\n\t\t\tif (this.handsBehindHead)\n\t\t\t{\n\t\t\t\ttargetRotation.y += 180;\n\t\t\t}\n\t\t}\n\n\t\tclampHeadRotationDeltaUp(angleY)\n\t\t{\n\t\t\tconst hmdRotation = localQuaternion.copy(this.vrTransforms.head.quaternion)\n\t\t\t  .multiply(z180Quaternion);\n\n\t\t\tconst headUpRotation = (localEuler.setFromQuaternion(hmdRotation, 'YXZ').y + Math.PI*2) % (Math.PI*2);\n\t\t\tconst targetUpRotation = (angleY + Math.PI*2) % (Math.PI*2);\n\n\t\t\tconst delta = headUpRotation - targetUpRotation;\n\n\t\t\tif (delta > this.maxDeltaHeadRotation && delta < Math.PI || delta < -Math.PI && delta >= -Math.PI*2 + this.maxDeltaHeadRotation)\n\t\t\t{\n\t\t\t\tangleY = headUpRotation - this.maxDeltaHeadRotation;\n\t\t\t\t// this.clampingHeadRotation = true;\n\t\t\t}\n\t\t\telse if (delta < -this.maxDeltaHeadRotation && delta > -Math.PI || delta > Math.PI && delta < Math.PI*2 - this.maxDeltaHeadRotation)\n\t\t\t{\n\t\t\t\tangleY = headUpRotation + this.maxDeltaHeadRotation;\n\t\t\t\t// this.clampingHeadRotation = true;\n\t\t\t}\n\t\t\t// else\n\t\t\t// {\n\t\t\t\t// this.clampingHeadRotation = false;\n\t\t\t// }\n\t\t\treturn angleY;\n\t\t}\n\n\t\tclampShoulderHandDistance()\n\t\t{\n\t\t\tconst leftHandVector = new Vector3().subVectors(this.avatarTrackingReferences.leftHand.position, this.shoulder.leftShoulderAnchor.position);\n\t\t\tconst rightHandVector = new Vector3().subVectors(this.avatarTrackingReferences.rightHand.position, this.shoulder.rightShoulderAnchor.position);\n\t\t\tconst leftShoulderHandDistance = leftHandVector.magnitude;\n      const rightShoulderHandDistance = rightHandVector.magnitude;\n\t\t\tthis.shoulderDislocated = false;\n\n\t\t  const startBeforeFactor = (1 - this.startShoulderDislocationBefore);\n\n\t\t\tif (leftShoulderHandDistance > this.shoulder.leftArm.armLength * startBeforeFactor)\n\t\t\t{\n\t\t\t\tthis.shoulderDislocated = true;\n\t\t\t\tthis.shoulder.leftArm.transform.position = new Vector3().addVectors(this.shoulder.leftShoulderAnchor.position,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  leftHandVector.normalized.multiplyScalar(leftShoulderHandDistance - this.shoulder.leftArm.armLength * startBeforeFactor));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.shoulder.leftArm.transform.localPosition = Vector3.zero;\n\t\t\t}\n\n\t\t\tif (rightShoulderHandDistance > this.shoulder.rightArm.armLength * startBeforeFactor)\n\t\t\t{\n\t\t\t\tthis.shoulderDislocated = true;\n\t\t\t\tthis.shoulder.rightArm.transform.position = new Vector3().addVectors(this.shoulder.rightShoulderAnchor.position,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   rightHandVector.normalized.multiplyScalar(rightShoulderHandDistance - this.shoulder.rightArm.armLength * startBeforeFactor));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.shoulder.rightArm.transform.localPosition = Vector3.zero;\n\t\t\t}\n\t\t} */\n\t}\n\nexport default ShoulderPoser;\n"]},"metadata":{},"sourceType":"module"}