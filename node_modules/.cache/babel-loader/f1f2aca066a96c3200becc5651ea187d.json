{"ast":null,"code":"import * as THREE from 'three';\n/**\n * @author Slayvin / http://slayvin.net\n */\n\nReflector.prototype = Object.create(THREE.Mesh.prototype);\nReflector.prototype.constructor = Reflector;\nReflector.ReflectorShader = {\n  uniforms: {\n    'color': {\n      value: null\n    },\n    'tDiffuse': {\n      value: null\n    },\n    'textureMatrix': {\n      value: null\n    }\n  },\n  vertexShader: ['uniform mat4 textureMatrix;', 'varying vec4 vUv;', 'void main() {', '\tvUv = textureMatrix * vec4( position, 1.0 );', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n  fragmentShader: ['uniform vec3 color;', 'uniform sampler2D tDiffuse;', 'varying vec4 vUv;', 'float blendOverlay( float base, float blend ) {', '\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );', '}', 'vec3 blendOverlay( vec3 base, vec3 blend ) {', '\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );', '}', 'void main() {', '\tvec4 base = texture2DProj( tDiffuse, vUv );', '\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );', '}'].join('\\n')\n};\nexport default Reflector = function (geometry, options) {\n  THREE.Mesh.call(this, geometry);\n  this.type = 'Reflector';\n  var scope = this;\n  options = options || {};\n  var color = options.color !== undefined ? new THREE.Color(options.color) : new THREE.Color(0x7F7F7F);\n  var textureWidth = options.textureWidth || 512;\n  var textureHeight = options.textureHeight || 512;\n  var clipBias = options.clipBias || 0;\n  var shader = options.shader || Reflector.ReflectorShader;\n  var recursion = options.recursion !== undefined ? options.recursion : 0; //\n\n  var reflectorPlane = new THREE.Plane();\n  var normal = new THREE.Vector3();\n  var reflectorWorldPosition = new THREE.Vector3();\n  var cameraWorldPosition = new THREE.Vector3();\n  var rotationMatrix = new THREE.Matrix4();\n  var lookAtPosition = new THREE.Vector3(0, 0, -1);\n  var clipPlane = new THREE.Vector4();\n  var view = new THREE.Vector3();\n  var target = new THREE.Vector3();\n  var q = new THREE.Vector4();\n  var textureMatrix = new THREE.Matrix4();\n  var virtualCamera = new THREE.PerspectiveCamera();\n  var parameters = {\n    minFilter: THREE.LinearFilter,\n    magFilter: THREE.LinearFilter,\n    format: THREE.RGBFormat,\n    stencilBuffer: false\n  };\n  var renderTarget = new THREE.WebGLRenderTarget(textureWidth, textureHeight, parameters);\n\n  if (!THREE.Math.isPowerOfTwo(textureWidth) || !THREE.Math.isPowerOfTwo(textureHeight)) {\n    renderTarget.texture.generateMipmaps = false;\n  }\n\n  var material = new THREE.ShaderMaterial({\n    uniforms: THREE.UniformsUtils.clone(shader.uniforms),\n    fragmentShader: shader.fragmentShader,\n    vertexShader: shader.vertexShader,\n    transparent: options.transparent\n  });\n  material.uniforms[\"tDiffuse\"].value = renderTarget.texture;\n  material.uniforms[\"color\"].value = color;\n  material.uniforms[\"textureMatrix\"].value = textureMatrix;\n  this.material = material;\n\n  this.onBeforeRender = function (renderer, scene, camera) {\n    this.onBeforeRender2 && this.onBeforeRender2(renderer, scene, camera);\n\n    if ('recursion' in camera.userData) {\n      if (camera.userData.recursion === recursion) return;\n      camera.userData.recursion++;\n    }\n\n    reflectorWorldPosition.setFromMatrixPosition(scope.matrixWorld);\n    cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);\n    rotationMatrix.extractRotation(scope.matrixWorld);\n    normal.set(0, 0, 1);\n    normal.applyMatrix4(rotationMatrix);\n    view.subVectors(reflectorWorldPosition, cameraWorldPosition); // Avoid rendering when reflector is facing away\n\n    if (view.dot(normal) > 0) return;\n    view.reflect(normal).negate();\n    view.add(reflectorWorldPosition);\n    rotationMatrix.extractRotation(camera.matrixWorld);\n    lookAtPosition.set(0, 0, -1);\n    lookAtPosition.applyMatrix4(rotationMatrix);\n    lookAtPosition.add(cameraWorldPosition);\n    target.subVectors(reflectorWorldPosition, lookAtPosition);\n    target.reflect(normal).negate();\n    target.add(reflectorWorldPosition);\n    virtualCamera.position.copy(view);\n    virtualCamera.up.set(0, 1, 0);\n    virtualCamera.up.applyMatrix4(rotationMatrix);\n    virtualCamera.up.reflect(normal);\n    virtualCamera.lookAt(target);\n    virtualCamera.far = camera.far; // Used in WebGLBackground\n\n    virtualCamera.updateMatrixWorld();\n    virtualCamera.projectionMatrix.copy(camera.projectionMatrix);\n    virtualCamera.userData.recursion = 0; // Update the texture matrix\n\n    textureMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);\n    textureMatrix.multiply(virtualCamera.projectionMatrix);\n    textureMatrix.multiply(virtualCamera.matrixWorldInverse);\n    textureMatrix.multiply(scope.matrixWorld); // Now update projection matrix with new clip plane, implementing code from: http://www.terathon.com/code/oblique.html\n    // Paper explaining this technique: http://www.terathon.com/lengyel/Lengyel-Oblique.pdf\n\n    reflectorPlane.setFromNormalAndCoplanarPoint(normal, reflectorWorldPosition);\n    reflectorPlane.applyMatrix4(virtualCamera.matrixWorldInverse);\n    clipPlane.set(reflectorPlane.normal.x, reflectorPlane.normal.y, reflectorPlane.normal.z, reflectorPlane.constant);\n    var projectionMatrix = virtualCamera.projectionMatrix;\n    q.x = (Math.sign(clipPlane.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0];\n    q.y = (Math.sign(clipPlane.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5];\n    q.z = -1.0;\n    q.w = (1.0 + projectionMatrix.elements[10]) / projectionMatrix.elements[14]; // Calculate the scaled plane vector\n\n    clipPlane.multiplyScalar(2.0 / clipPlane.dot(q)); // Replacing the third row of the projection matrix\n\n    projectionMatrix.elements[2] = clipPlane.x;\n    projectionMatrix.elements[6] = clipPlane.y;\n    projectionMatrix.elements[10] = clipPlane.z + 1.0 - clipBias;\n    projectionMatrix.elements[14] = clipPlane.w; // Render\n\n    scope.visible = false;\n    var currentRenderTarget = renderer.getRenderTarget();\n    var currentVrEnabled = renderer.vr.enabled;\n    var currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\n    renderer.vr.enabled = false; // Avoid camera modification and recursion\n\n    renderer.shadowMap.autoUpdate = false; // Avoid re-computing shadows\n\n    renderer.setRenderTarget(renderTarget);\n    renderer.clear();\n    renderer.render(scene, virtualCamera);\n    renderer.vr.enabled = currentVrEnabled;\n    renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\n    renderer.setRenderTarget(currentRenderTarget); // Restore viewport\n\n    var viewport = camera.viewport;\n\n    if (viewport !== undefined) {\n      renderer.state.viewport(viewport);\n    }\n\n    scope.visible = true;\n  };\n\n  this.onAfterRender = (renderer, scene, camera) => {\n    this.onAfterRender2 && this.onAfterRender2(renderer, scene, camera);\n  };\n\n  this.getRenderTarget = function () {\n    return renderTarget;\n  };\n};","map":{"version":3,"sources":["/Users/chris/Documents/Github/test-react/src/WebXRApps/Avatars/Reflector.js"],"names":["THREE","Reflector","prototype","Object","create","Mesh","constructor","ReflectorShader","uniforms","value","vertexShader","join","fragmentShader","geometry","options","call","type","scope","color","undefined","Color","textureWidth","textureHeight","clipBias","shader","recursion","reflectorPlane","Plane","normal","Vector3","reflectorWorldPosition","cameraWorldPosition","rotationMatrix","Matrix4","lookAtPosition","clipPlane","Vector4","view","target","q","textureMatrix","virtualCamera","PerspectiveCamera","parameters","minFilter","LinearFilter","magFilter","format","RGBFormat","stencilBuffer","renderTarget","WebGLRenderTarget","Math","isPowerOfTwo","texture","generateMipmaps","material","ShaderMaterial","UniformsUtils","clone","transparent","onBeforeRender","renderer","scene","camera","onBeforeRender2","userData","setFromMatrixPosition","matrixWorld","extractRotation","set","applyMatrix4","subVectors","dot","reflect","negate","add","position","copy","up","lookAt","far","updateMatrixWorld","projectionMatrix","multiply","matrixWorldInverse","setFromNormalAndCoplanarPoint","x","y","z","constant","sign","elements","w","multiplyScalar","visible","currentRenderTarget","getRenderTarget","currentVrEnabled","vr","enabled","currentShadowAutoUpdate","shadowMap","autoUpdate","setRenderTarget","clear","render","viewport","state","onAfterRender","onAfterRender2"],"mappings":"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","sourcesContent":["import * as THREE from 'three';\n\n/**\n * @author Slayvin / http://slayvin.net\n */\n\nReflector.prototype = Object.create( THREE.Mesh.prototype );\nReflector.prototype.constructor = Reflector;\n\nReflector.ReflectorShader = {\n\n\tuniforms: {\n\n\t\t'color': {\n\t\t\tvalue: null\n\t\t},\n\n\t\t'tDiffuse': {\n\t\t\tvalue: null\n\t\t},\n\n\t\t'textureMatrix': {\n\t\t\tvalue: null\n\t\t}\n\n\t},\n\n\tvertexShader: [\n\t\t'uniform mat4 textureMatrix;',\n\t\t'varying vec4 vUv;',\n\n\t\t'void main() {',\n\n\t\t'\tvUv = textureMatrix * vec4( position, 1.0 );',\n\n\t\t'\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',\n\n\t\t'}'\n\t].join( '\\n' ),\n\n\tfragmentShader: [\n\t\t'uniform vec3 color;',\n\t\t'uniform sampler2D tDiffuse;',\n\t\t'varying vec4 vUv;',\n\n\t\t'float blendOverlay( float base, float blend ) {',\n\n\t\t'\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );',\n\n\t\t'}',\n\n\t\t'vec3 blendOverlay( vec3 base, vec3 blend ) {',\n\n\t\t'\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );',\n\n\t\t'}',\n\n\t\t'void main() {',\n\n\t\t'\tvec4 base = texture2DProj( tDiffuse, vUv );',\n\t\t'\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );',\n\n\t\t'}'\n\t].join( '\\n' )\n};\n\nexport default Reflector = function ( geometry, options ) {\n\n\tTHREE.Mesh.call( this, geometry );\n\n\tthis.type = 'Reflector';\n\n\tvar scope = this;\n\n\toptions = options || {};\n\n\tvar color = ( options.color !== undefined ) ? new THREE.Color( options.color ) : new THREE.Color( 0x7F7F7F );\n\tvar textureWidth = options.textureWidth || 512;\n\tvar textureHeight = options.textureHeight || 512;\n\tvar clipBias = options.clipBias || 0;\n\tvar shader = options.shader || Reflector.ReflectorShader;\n\tvar recursion = options.recursion !== undefined ? options.recursion : 0;\n\n\t//\n\n\tvar reflectorPlane = new THREE.Plane();\n\tvar normal = new THREE.Vector3();\n\tvar reflectorWorldPosition = new THREE.Vector3();\n\tvar cameraWorldPosition = new THREE.Vector3();\n\tvar rotationMatrix = new THREE.Matrix4();\n\tvar lookAtPosition = new THREE.Vector3( 0, 0, - 1 );\n\tvar clipPlane = new THREE.Vector4();\n\n\tvar view = new THREE.Vector3();\n\tvar target = new THREE.Vector3();\n\tvar q = new THREE.Vector4();\n\n\tvar textureMatrix = new THREE.Matrix4();\n\tvar virtualCamera = new THREE.PerspectiveCamera();\n\n\tvar parameters = {\n\t\tminFilter: THREE.LinearFilter,\n\t\tmagFilter: THREE.LinearFilter,\n\t\tformat: THREE.RGBFormat,\n\t\tstencilBuffer: false\n\t};\n\n\tvar renderTarget = new THREE.WebGLRenderTarget( textureWidth, textureHeight, parameters );\n\n\tif ( ! THREE.Math.isPowerOfTwo( textureWidth ) || ! THREE.Math.isPowerOfTwo( textureHeight ) ) {\n\n\t\trenderTarget.texture.generateMipmaps = false;\n\n\t}\n\n\tvar material = new THREE.ShaderMaterial( {\n\t\tuniforms: THREE.UniformsUtils.clone( shader.uniforms ),\n\t\tfragmentShader: shader.fragmentShader,\n\t\tvertexShader: shader.vertexShader,\n\t\ttransparent: options.transparent,\n\t} );\n\n\tmaterial.uniforms[ \"tDiffuse\" ].value = renderTarget.texture;\n\tmaterial.uniforms[ \"color\" ].value = color;\n\tmaterial.uniforms[ \"textureMatrix\" ].value = textureMatrix;\n\n\tthis.material = material;\n\n\tthis.onBeforeRender = function ( renderer, scene, camera ) {\n\t\tthis.onBeforeRender2 && this.onBeforeRender2(renderer, scene, camera);\n\n\t\tif ( 'recursion' in camera.userData ) {\n\n\t\t\tif ( camera.userData.recursion === recursion ) return;\n\n\t\t\tcamera.userData.recursion ++;\n\n\t\t}\n\n\t\treflectorWorldPosition.setFromMatrixPosition( scope.matrixWorld );\n\t\tcameraWorldPosition.setFromMatrixPosition( camera.matrixWorld );\n\n\t\trotationMatrix.extractRotation( scope.matrixWorld );\n\n\t\tnormal.set( 0, 0, 1 );\n\t\tnormal.applyMatrix4( rotationMatrix );\n\n\t\tview.subVectors( reflectorWorldPosition, cameraWorldPosition );\n\n\t\t// Avoid rendering when reflector is facing away\n\n\t\tif ( view.dot( normal ) > 0 ) return;\n\n\t\tview.reflect( normal ).negate();\n\t\tview.add( reflectorWorldPosition );\n\n\t\trotationMatrix.extractRotation( camera.matrixWorld );\n\n\t\tlookAtPosition.set( 0, 0, - 1 );\n\t\tlookAtPosition.applyMatrix4( rotationMatrix );\n\t\tlookAtPosition.add( cameraWorldPosition );\n\n\t\ttarget.subVectors( reflectorWorldPosition, lookAtPosition );\n\t\ttarget.reflect( normal ).negate();\n\t\ttarget.add( reflectorWorldPosition );\n\n\t\tvirtualCamera.position.copy( view );\n\t\tvirtualCamera.up.set( 0, 1, 0 );\n\t\tvirtualCamera.up.applyMatrix4( rotationMatrix );\n\t\tvirtualCamera.up.reflect( normal );\n\t\tvirtualCamera.lookAt( target );\n\n\t\tvirtualCamera.far = camera.far; // Used in WebGLBackground\n\n\t\tvirtualCamera.updateMatrixWorld();\n\t\tvirtualCamera.projectionMatrix.copy( camera.projectionMatrix );\n\n\t\tvirtualCamera.userData.recursion = 0;\n\n\t\t// Update the texture matrix\n\t\ttextureMatrix.set(\n\t\t\t0.5, 0.0, 0.0, 0.5,\n\t\t\t0.0, 0.5, 0.0, 0.5,\n\t\t\t0.0, 0.0, 0.5, 0.5,\n\t\t\t0.0, 0.0, 0.0, 1.0\n\t\t);\n\t\ttextureMatrix.multiply( virtualCamera.projectionMatrix );\n\t\ttextureMatrix.multiply( virtualCamera.matrixWorldInverse );\n\t\ttextureMatrix.multiply( scope.matrixWorld );\n\n\t\t// Now update projection matrix with new clip plane, implementing code from: http://www.terathon.com/code/oblique.html\n\t\t// Paper explaining this technique: http://www.terathon.com/lengyel/Lengyel-Oblique.pdf\n\t\treflectorPlane.setFromNormalAndCoplanarPoint( normal, reflectorWorldPosition );\n\t\treflectorPlane.applyMatrix4( virtualCamera.matrixWorldInverse );\n\n\t\tclipPlane.set( reflectorPlane.normal.x, reflectorPlane.normal.y, reflectorPlane.normal.z, reflectorPlane.constant );\n\n\t\tvar projectionMatrix = virtualCamera.projectionMatrix;\n\n\t\tq.x = ( Math.sign( clipPlane.x ) + projectionMatrix.elements[ 8 ] ) / projectionMatrix.elements[ 0 ];\n\t\tq.y = ( Math.sign( clipPlane.y ) + projectionMatrix.elements[ 9 ] ) / projectionMatrix.elements[ 5 ];\n\t\tq.z = - 1.0;\n\t\tq.w = ( 1.0 + projectionMatrix.elements[ 10 ] ) / projectionMatrix.elements[ 14 ];\n\n\t\t// Calculate the scaled plane vector\n\t\tclipPlane.multiplyScalar( 2.0 / clipPlane.dot( q ) );\n\n\t\t// Replacing the third row of the projection matrix\n\t\tprojectionMatrix.elements[ 2 ] = clipPlane.x;\n\t\tprojectionMatrix.elements[ 6 ] = clipPlane.y;\n\t\tprojectionMatrix.elements[ 10 ] = clipPlane.z + 1.0 - clipBias;\n\t\tprojectionMatrix.elements[ 14 ] = clipPlane.w;\n\n\t\t// Render\n\n\t\tscope.visible = false;\n\n\t\tvar currentRenderTarget = renderer.getRenderTarget();\n\n\t\tvar currentVrEnabled = renderer.vr.enabled;\n\t\tvar currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\n\n\t\trenderer.vr.enabled = false; // Avoid camera modification and recursion\n\t\trenderer.shadowMap.autoUpdate = false; // Avoid re-computing shadows\n\n\t\trenderer.setRenderTarget( renderTarget );\n\t\trenderer.clear();\n\t\trenderer.render( scene, virtualCamera );\n\n\t\trenderer.vr.enabled = currentVrEnabled;\n\t\trenderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\n\n\t\trenderer.setRenderTarget( currentRenderTarget );\n\n\t\t// Restore viewport\n\n\t\tvar viewport = camera.viewport;\n\n\t\tif ( viewport !== undefined ) {\n\n\t\t\trenderer.state.viewport( viewport );\n\n\t\t}\n\n\t\tscope.visible = true;\n\n\t};\n\tthis.onAfterRender = (renderer, scene, camera) => {\n    this.onAfterRender2 && this.onAfterRender2(renderer, scene, camera);\n\t};\n\n\tthis.getRenderTarget = function () {\n\n\t\treturn renderTarget;\n\n\t};\n\n};\n\n"]},"metadata":{},"sourceType":"module"}