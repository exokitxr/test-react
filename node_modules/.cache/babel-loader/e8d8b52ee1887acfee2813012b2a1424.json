{"ast":null,"code":"import * as THREE from 'three';\n/**\n * @author Slayvin / http://slayvin.net\n */\n\nTHREE.Reflector = function (geometry, options) {\n  THREE.Mesh.call(this, geometry);\n  this.type = 'Reflector';\n  var scope = this;\n  options = options || {};\n  var color = options.color !== undefined ? new THREE.Color(options.color) : new THREE.Color(0x7F7F7F);\n  var textureWidth = options.textureWidth || 512;\n  var textureHeight = options.textureHeight || 512;\n  var clipBias = options.clipBias || 0;\n  var shader = options.shader || THREE.Reflector.ReflectorShader;\n  var recursion = options.recursion !== undefined ? options.recursion : 0; //\n\n  var reflectorPlane = new THREE.Plane();\n  var normal = new THREE.Vector3();\n  var reflectorWorldPosition = new THREE.Vector3();\n  var cameraWorldPosition = new THREE.Vector3();\n  var rotationMatrix = new THREE.Matrix4();\n  var lookAtPosition = new THREE.Vector3(0, 0, -1);\n  var clipPlane = new THREE.Vector4();\n  var view = new THREE.Vector3();\n  var target = new THREE.Vector3();\n  var q = new THREE.Vector4();\n  var textureMatrix = new THREE.Matrix4();\n  var virtualCamera = new THREE.PerspectiveCamera();\n  var parameters = {\n    minFilter: THREE.LinearFilter,\n    magFilter: THREE.LinearFilter,\n    format: THREE.RGBFormat,\n    stencilBuffer: false\n  };\n  var renderTarget = new THREE.WebGLRenderTarget(textureWidth, textureHeight, parameters);\n\n  if (!THREE.Math.isPowerOfTwo(textureWidth) || !THREE.Math.isPowerOfTwo(textureHeight)) {\n    renderTarget.texture.generateMipmaps = false;\n  }\n\n  var material = new THREE.ShaderMaterial({\n    uniforms: THREE.UniformsUtils.clone(shader.uniforms),\n    fragmentShader: shader.fragmentShader,\n    vertexShader: shader.vertexShader,\n    transparent: options.transparent\n  });\n  material.uniforms[\"tDiffuse\"].value = renderTarget.texture;\n  material.uniforms[\"color\"].value = color;\n  material.uniforms[\"textureMatrix\"].value = textureMatrix;\n  this.material = material;\n\n  this.onBeforeRender = function (renderer, scene, camera) {\n    this.onBeforeRender2 && this.onBeforeRender2(renderer, scene, camera);\n\n    if ('recursion' in camera.userData) {\n      if (camera.userData.recursion === recursion) return;\n      camera.userData.recursion++;\n    }\n\n    reflectorWorldPosition.setFromMatrixPosition(scope.matrixWorld);\n    cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);\n    rotationMatrix.extractRotation(scope.matrixWorld);\n    normal.set(0, 0, 1);\n    normal.applyMatrix4(rotationMatrix);\n    view.subVectors(reflectorWorldPosition, cameraWorldPosition); // Avoid rendering when reflector is facing away\n\n    if (view.dot(normal) > 0) return;\n    view.reflect(normal).negate();\n    view.add(reflectorWorldPosition);\n    rotationMatrix.extractRotation(camera.matrixWorld);\n    lookAtPosition.set(0, 0, -1);\n    lookAtPosition.applyMatrix4(rotationMatrix);\n    lookAtPosition.add(cameraWorldPosition);\n    target.subVectors(reflectorWorldPosition, lookAtPosition);\n    target.reflect(normal).negate();\n    target.add(reflectorWorldPosition);\n    virtualCamera.position.copy(view);\n    virtualCamera.up.set(0, 1, 0);\n    virtualCamera.up.applyMatrix4(rotationMatrix);\n    virtualCamera.up.reflect(normal);\n    virtualCamera.lookAt(target);\n    virtualCamera.far = camera.far; // Used in WebGLBackground\n\n    virtualCamera.updateMatrixWorld();\n    virtualCamera.projectionMatrix.copy(camera.projectionMatrix);\n    virtualCamera.userData.recursion = 0; // Update the texture matrix\n\n    textureMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);\n    textureMatrix.multiply(virtualCamera.projectionMatrix);\n    textureMatrix.multiply(virtualCamera.matrixWorldInverse);\n    textureMatrix.multiply(scope.matrixWorld); // Now update projection matrix with new clip plane, implementing code from: http://www.terathon.com/code/oblique.html\n    // Paper explaining this technique: http://www.terathon.com/lengyel/Lengyel-Oblique.pdf\n\n    reflectorPlane.setFromNormalAndCoplanarPoint(normal, reflectorWorldPosition);\n    reflectorPlane.applyMatrix4(virtualCamera.matrixWorldInverse);\n    clipPlane.set(reflectorPlane.normal.x, reflectorPlane.normal.y, reflectorPlane.normal.z, reflectorPlane.constant);\n    var projectionMatrix = virtualCamera.projectionMatrix;\n    q.x = (Math.sign(clipPlane.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0];\n    q.y = (Math.sign(clipPlane.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5];\n    q.z = -1.0;\n    q.w = (1.0 + projectionMatrix.elements[10]) / projectionMatrix.elements[14]; // Calculate the scaled plane vector\n\n    clipPlane.multiplyScalar(2.0 / clipPlane.dot(q)); // Replacing the third row of the projection matrix\n\n    projectionMatrix.elements[2] = clipPlane.x;\n    projectionMatrix.elements[6] = clipPlane.y;\n    projectionMatrix.elements[10] = clipPlane.z + 1.0 - clipBias;\n    projectionMatrix.elements[14] = clipPlane.w; // Render\n\n    scope.visible = false;\n    var currentRenderTarget = renderer.getRenderTarget();\n    var currentVrEnabled = renderer.vr.enabled;\n    var currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\n    renderer.vr.enabled = false; // Avoid camera modification and recursion\n\n    renderer.shadowMap.autoUpdate = false; // Avoid re-computing shadows\n\n    renderer.setRenderTarget(renderTarget);\n    renderer.clear();\n    renderer.render(scene, virtualCamera);\n    renderer.vr.enabled = currentVrEnabled;\n    renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\n    renderer.setRenderTarget(currentRenderTarget); // Restore viewport\n\n    var viewport = camera.viewport;\n\n    if (viewport !== undefined) {\n      renderer.state.viewport(viewport);\n    }\n\n    scope.visible = true;\n  };\n\n  this.onAfterRender = (renderer, scene, camera) => {\n    this.onAfterRender2 && this.onAfterRender2(renderer, scene, camera);\n  };\n\n  this.getRenderTarget = function () {\n    return renderTarget;\n  };\n};\n\nTHREE.Reflector.prototype = Object.create(THREE.Mesh.prototype);\nTHREE.Reflector.prototype.constructor = THREE.Reflector;\nTHREE.Reflector.ReflectorShader = {\n  uniforms: {\n    'color': {\n      value: null\n    },\n    'tDiffuse': {\n      value: null\n    },\n    'textureMatrix': {\n      value: null\n    }\n  },\n  vertexShader: ['uniform mat4 textureMatrix;', 'varying vec4 vUv;', 'void main() {', '\tvUv = textureMatrix * vec4( position, 1.0 );', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n  fragmentShader: ['uniform vec3 color;', 'uniform sampler2D tDiffuse;', 'varying vec4 vUv;', 'float blendOverlay( float base, float blend ) {', '\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );', '}', 'vec3 blendOverlay( vec3 base, vec3 blend ) {', '\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );', '}', 'void main() {', '\tvec4 base = texture2DProj( tDiffuse, vUv );', '\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );', '}'].join('\\n')\n};","map":{"version":3,"sources":["/Users/chris/Documents/Github/test-react/src/WebXRApps/Avatars/Reflector.js"],"names":["THREE","Reflector","geometry","options","Mesh","call","type","scope","color","undefined","Color","textureWidth","textureHeight","clipBias","shader","ReflectorShader","recursion","reflectorPlane","Plane","normal","Vector3","reflectorWorldPosition","cameraWorldPosition","rotationMatrix","Matrix4","lookAtPosition","clipPlane","Vector4","view","target","q","textureMatrix","virtualCamera","PerspectiveCamera","parameters","minFilter","LinearFilter","magFilter","format","RGBFormat","stencilBuffer","renderTarget","WebGLRenderTarget","Math","isPowerOfTwo","texture","generateMipmaps","material","ShaderMaterial","uniforms","UniformsUtils","clone","fragmentShader","vertexShader","transparent","value","onBeforeRender","renderer","scene","camera","onBeforeRender2","userData","setFromMatrixPosition","matrixWorld","extractRotation","set","applyMatrix4","subVectors","dot","reflect","negate","add","position","copy","up","lookAt","far","updateMatrixWorld","projectionMatrix","multiply","matrixWorldInverse","setFromNormalAndCoplanarPoint","x","y","z","constant","sign","elements","w","multiplyScalar","visible","currentRenderTarget","getRenderTarget","currentVrEnabled","vr","enabled","currentShadowAutoUpdate","shadowMap","autoUpdate","setRenderTarget","clear","render","viewport","state","onAfterRender","onAfterRender2","prototype","Object","create","constructor","join"],"mappings":"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","sourcesContent":["import * as THREE from 'three';\n\n/**\n * @author Slayvin / http://slayvin.net\n */\n\nTHREE.Reflector = function ( geometry, options ) {\n\n\tTHREE.Mesh.call( this, geometry );\n\n\tthis.type = 'Reflector';\n\n\tvar scope = this;\n\n\toptions = options || {};\n\n\tvar color = ( options.color !== undefined ) ? new THREE.Color( options.color ) : new THREE.Color( 0x7F7F7F );\n\tvar textureWidth = options.textureWidth || 512;\n\tvar textureHeight = options.textureHeight || 512;\n\tvar clipBias = options.clipBias || 0;\n\tvar shader = options.shader || THREE.Reflector.ReflectorShader;\n\tvar recursion = options.recursion !== undefined ? options.recursion : 0;\n\n\t//\n\n\tvar reflectorPlane = new THREE.Plane();\n\tvar normal = new THREE.Vector3();\n\tvar reflectorWorldPosition = new THREE.Vector3();\n\tvar cameraWorldPosition = new THREE.Vector3();\n\tvar rotationMatrix = new THREE.Matrix4();\n\tvar lookAtPosition = new THREE.Vector3( 0, 0, - 1 );\n\tvar clipPlane = new THREE.Vector4();\n\n\tvar view = new THREE.Vector3();\n\tvar target = new THREE.Vector3();\n\tvar q = new THREE.Vector4();\n\n\tvar textureMatrix = new THREE.Matrix4();\n\tvar virtualCamera = new THREE.PerspectiveCamera();\n\n\tvar parameters = {\n\t\tminFilter: THREE.LinearFilter,\n\t\tmagFilter: THREE.LinearFilter,\n\t\tformat: THREE.RGBFormat,\n\t\tstencilBuffer: false\n\t};\n\n\tvar renderTarget = new THREE.WebGLRenderTarget( textureWidth, textureHeight, parameters );\n\n\tif ( ! THREE.Math.isPowerOfTwo( textureWidth ) || ! THREE.Math.isPowerOfTwo( textureHeight ) ) {\n\n\t\trenderTarget.texture.generateMipmaps = false;\n\n\t}\n\n\tvar material = new THREE.ShaderMaterial( {\n\t\tuniforms: THREE.UniformsUtils.clone( shader.uniforms ),\n\t\tfragmentShader: shader.fragmentShader,\n\t\tvertexShader: shader.vertexShader,\n\t\ttransparent: options.transparent,\n\t} );\n\n\tmaterial.uniforms[ \"tDiffuse\" ].value = renderTarget.texture;\n\tmaterial.uniforms[ \"color\" ].value = color;\n\tmaterial.uniforms[ \"textureMatrix\" ].value = textureMatrix;\n\n\tthis.material = material;\n\n\tthis.onBeforeRender = function ( renderer, scene, camera ) {\n\t\tthis.onBeforeRender2 && this.onBeforeRender2(renderer, scene, camera);\n\n\t\tif ( 'recursion' in camera.userData ) {\n\n\t\t\tif ( camera.userData.recursion === recursion ) return;\n\n\t\t\tcamera.userData.recursion ++;\n\n\t\t}\n\n\t\treflectorWorldPosition.setFromMatrixPosition( scope.matrixWorld );\n\t\tcameraWorldPosition.setFromMatrixPosition( camera.matrixWorld );\n\n\t\trotationMatrix.extractRotation( scope.matrixWorld );\n\n\t\tnormal.set( 0, 0, 1 );\n\t\tnormal.applyMatrix4( rotationMatrix );\n\n\t\tview.subVectors( reflectorWorldPosition, cameraWorldPosition );\n\n\t\t// Avoid rendering when reflector is facing away\n\n\t\tif ( view.dot( normal ) > 0 ) return;\n\n\t\tview.reflect( normal ).negate();\n\t\tview.add( reflectorWorldPosition );\n\n\t\trotationMatrix.extractRotation( camera.matrixWorld );\n\n\t\tlookAtPosition.set( 0, 0, - 1 );\n\t\tlookAtPosition.applyMatrix4( rotationMatrix );\n\t\tlookAtPosition.add( cameraWorldPosition );\n\n\t\ttarget.subVectors( reflectorWorldPosition, lookAtPosition );\n\t\ttarget.reflect( normal ).negate();\n\t\ttarget.add( reflectorWorldPosition );\n\n\t\tvirtualCamera.position.copy( view );\n\t\tvirtualCamera.up.set( 0, 1, 0 );\n\t\tvirtualCamera.up.applyMatrix4( rotationMatrix );\n\t\tvirtualCamera.up.reflect( normal );\n\t\tvirtualCamera.lookAt( target );\n\n\t\tvirtualCamera.far = camera.far; // Used in WebGLBackground\n\n\t\tvirtualCamera.updateMatrixWorld();\n\t\tvirtualCamera.projectionMatrix.copy( camera.projectionMatrix );\n\n\t\tvirtualCamera.userData.recursion = 0;\n\n\t\t// Update the texture matrix\n\t\ttextureMatrix.set(\n\t\t\t0.5, 0.0, 0.0, 0.5,\n\t\t\t0.0, 0.5, 0.0, 0.5,\n\t\t\t0.0, 0.0, 0.5, 0.5,\n\t\t\t0.0, 0.0, 0.0, 1.0\n\t\t);\n\t\ttextureMatrix.multiply( virtualCamera.projectionMatrix );\n\t\ttextureMatrix.multiply( virtualCamera.matrixWorldInverse );\n\t\ttextureMatrix.multiply( scope.matrixWorld );\n\n\t\t// Now update projection matrix with new clip plane, implementing code from: http://www.terathon.com/code/oblique.html\n\t\t// Paper explaining this technique: http://www.terathon.com/lengyel/Lengyel-Oblique.pdf\n\t\treflectorPlane.setFromNormalAndCoplanarPoint( normal, reflectorWorldPosition );\n\t\treflectorPlane.applyMatrix4( virtualCamera.matrixWorldInverse );\n\n\t\tclipPlane.set( reflectorPlane.normal.x, reflectorPlane.normal.y, reflectorPlane.normal.z, reflectorPlane.constant );\n\n\t\tvar projectionMatrix = virtualCamera.projectionMatrix;\n\n\t\tq.x = ( Math.sign( clipPlane.x ) + projectionMatrix.elements[ 8 ] ) / projectionMatrix.elements[ 0 ];\n\t\tq.y = ( Math.sign( clipPlane.y ) + projectionMatrix.elements[ 9 ] ) / projectionMatrix.elements[ 5 ];\n\t\tq.z = - 1.0;\n\t\tq.w = ( 1.0 + projectionMatrix.elements[ 10 ] ) / projectionMatrix.elements[ 14 ];\n\n\t\t// Calculate the scaled plane vector\n\t\tclipPlane.multiplyScalar( 2.0 / clipPlane.dot( q ) );\n\n\t\t// Replacing the third row of the projection matrix\n\t\tprojectionMatrix.elements[ 2 ] = clipPlane.x;\n\t\tprojectionMatrix.elements[ 6 ] = clipPlane.y;\n\t\tprojectionMatrix.elements[ 10 ] = clipPlane.z + 1.0 - clipBias;\n\t\tprojectionMatrix.elements[ 14 ] = clipPlane.w;\n\n\t\t// Render\n\n\t\tscope.visible = false;\n\n\t\tvar currentRenderTarget = renderer.getRenderTarget();\n\n\t\tvar currentVrEnabled = renderer.vr.enabled;\n\t\tvar currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\n\n\t\trenderer.vr.enabled = false; // Avoid camera modification and recursion\n\t\trenderer.shadowMap.autoUpdate = false; // Avoid re-computing shadows\n\n\t\trenderer.setRenderTarget( renderTarget );\n\t\trenderer.clear();\n\t\trenderer.render( scene, virtualCamera );\n\n\t\trenderer.vr.enabled = currentVrEnabled;\n\t\trenderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\n\n\t\trenderer.setRenderTarget( currentRenderTarget );\n\n\t\t// Restore viewport\n\n\t\tvar viewport = camera.viewport;\n\n\t\tif ( viewport !== undefined ) {\n\n\t\t\trenderer.state.viewport( viewport );\n\n\t\t}\n\n\t\tscope.visible = true;\n\n\t};\n\tthis.onAfterRender = (renderer, scene, camera) => {\n    this.onAfterRender2 && this.onAfterRender2(renderer, scene, camera);\n\t};\n\n\tthis.getRenderTarget = function () {\n\n\t\treturn renderTarget;\n\n\t};\n\n};\n\nTHREE.Reflector.prototype = Object.create( THREE.Mesh.prototype );\nTHREE.Reflector.prototype.constructor = THREE.Reflector;\n\nTHREE.Reflector.ReflectorShader = {\n\n\tuniforms: {\n\n\t\t'color': {\n\t\t\tvalue: null\n\t\t},\n\n\t\t'tDiffuse': {\n\t\t\tvalue: null\n\t\t},\n\n\t\t'textureMatrix': {\n\t\t\tvalue: null\n\t\t}\n\n\t},\n\n\tvertexShader: [\n\t\t'uniform mat4 textureMatrix;',\n\t\t'varying vec4 vUv;',\n\n\t\t'void main() {',\n\n\t\t'\tvUv = textureMatrix * vec4( position, 1.0 );',\n\n\t\t'\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',\n\n\t\t'}'\n\t].join( '\\n' ),\n\n\tfragmentShader: [\n\t\t'uniform vec3 color;',\n\t\t'uniform sampler2D tDiffuse;',\n\t\t'varying vec4 vUv;',\n\n\t\t'float blendOverlay( float base, float blend ) {',\n\n\t\t'\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );',\n\n\t\t'}',\n\n\t\t'vec3 blendOverlay( vec3 base, vec3 blend ) {',\n\n\t\t'\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );',\n\n\t\t'}',\n\n\t\t'void main() {',\n\n\t\t'\tvec4 base = texture2DProj( tDiffuse, vUv );',\n\t\t'\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );',\n\n\t\t'}'\n\t].join( '\\n' )\n};\n"]},"metadata":{},"sourceType":"module"}