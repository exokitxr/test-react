{"ast":null,"code":"\"use strict\";\n\nvar _createClass = require(\"/Users/chris/Documents/Github/test-react/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"/Users/chris/Documents/Github/test-react/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/Users/chris/Documents/Github/test-react/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/Users/chris/Documents/Github/test-react/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _classCallCheck = require(\"/Users/chris/Documents/Github/test-react/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar he_1 = require(\"he\");\n\nvar NodeType;\n\n(function (NodeType) {\n  NodeType[NodeType[\"ELEMENT_NODE\"] = 1] = \"ELEMENT_NODE\";\n  NodeType[NodeType[\"TEXT_NODE\"] = 3] = \"TEXT_NODE\";\n})(NodeType = exports.NodeType || (exports.NodeType = {}));\n/**\n * Node Class as base class for TextNode and HTMLElement.\n */\n\n\nvar Node = function Node() {\n  _classCallCheck(this, Node);\n\n  this.childNodes = [];\n};\n\nexports.Node = Node;\n/**\n * TextNode to contain a text element in DOM tree.\n * @param {string} value [description]\n */\n\nvar TextNode =\n/*#__PURE__*/\nfunction (_Node) {\n  _inherits(TextNode, _Node);\n\n  function TextNode(value) {\n    var _this;\n\n    _classCallCheck(this, TextNode);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(TextNode).call(this));\n    /**\n     * Node Type declaration.\n     * @type {Number}\n     */\n\n    _this.nodeType = NodeType.TEXT_NODE;\n    _this.rawText = value;\n    return _this;\n  }\n  /**\n   * Get unescaped text value of current node and its children.\n   * @return {string} text content\n   */\n\n\n  _createClass(TextNode, [{\n    key: \"toString\",\n    value: function toString() {\n      return this.text;\n    }\n  }, {\n    key: \"text\",\n    get: function get() {\n      return he_1.decode(this.rawText);\n    }\n    /**\n     * Detect if the node contains only white space.\n     * @return {bool}\n     */\n\n  }, {\n    key: \"isWhitespace\",\n    get: function get() {\n      return /^(\\s|&nbsp;)*$/.test(this.rawText);\n    }\n  }]);\n\n  return TextNode;\n}(Node);\n\nexports.TextNode = TextNode;\nvar kBlockElements = {\n  div: true,\n  p: true,\n  // ul: true,\n  // ol: true,\n  li: true,\n  // table: true,\n  // tr: true,\n  td: true,\n  section: true,\n  br: true\n};\n\nfunction arr_back(arr) {\n  return arr[arr.length - 1];\n}\n/**\n * HTMLElement, which contains a set of children.\n *\n * Note: this is a minimalist implementation, no complete tree\n *   structure provided (no parentNode, nextSibling,\n *   previousSibling etc).\n * @class HTMLElement\n * @extends {Node}\n */\n\n\nvar HTMLElement =\n/*#__PURE__*/\nfunction (_Node2) {\n  _inherits(HTMLElement, _Node2);\n\n  /**\n   * Creates an instance of HTMLElement.\n   * @param keyAttrs\tid and class attribute\n   * @param [rawAttrs]\tattributes in string\n   *\n   * @memberof HTMLElement\n   */\n  function HTMLElement(tagName, keyAttrs) {\n    var _this2;\n\n    var rawAttrs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n    var parentNode = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n\n    _classCallCheck(this, HTMLElement);\n\n    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(HTMLElement).call(this));\n    _this2.tagName = tagName;\n    _this2.rawAttrs = rawAttrs;\n    _this2.parentNode = parentNode;\n    _this2.classNames = [];\n    /**\n     * Node Type declaration.\n     */\n\n    _this2.nodeType = NodeType.ELEMENT_NODE;\n    _this2.rawAttrs = rawAttrs || '';\n    _this2.parentNode = parentNode || null;\n    _this2.childNodes = [];\n\n    if (keyAttrs.id) {\n      _this2.id = keyAttrs.id;\n    }\n\n    if (keyAttrs.class) {\n      _this2.classNames = keyAttrs.class.split(/\\s+/);\n    }\n\n    return _this2;\n  }\n  /**\n   * Remove Child element from childNodes array\n   * @param {HTMLElement} node     node to remove\n   */\n\n\n  _createClass(HTMLElement, [{\n    key: \"removeChild\",\n    value: function removeChild(node) {\n      this.childNodes = this.childNodes.filter(function (child) {\n        return child !== node;\n      });\n    }\n    /**\n     * Exchanges given child with new child\n     * @param {HTMLElement} oldNode     node to exchange\n     * @param {HTMLElement} newNode     new node\n     */\n\n  }, {\n    key: \"exchangeChild\",\n    value: function exchangeChild(oldNode, newNode) {\n      var idx = -1;\n\n      for (var i = 0; i < this.childNodes.length; i++) {\n        if (this.childNodes[i] === oldNode) {\n          idx = i;\n          break;\n        }\n      }\n\n      this.childNodes[idx] = newNode;\n    }\n    /**\n     * Get escpaed (as-it) text value of current node and its children.\n     * @return {string} text content\n     */\n\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var tag = this.tagName;\n\n      if (tag) {\n        var is_un_closed = /^meta$/i.test(tag);\n        var is_self_closed = /^(img|br|hr|area|base|input|doctype|link)$/i.test(tag);\n        var attrs = this.rawAttrs ? ' ' + this.rawAttrs : '';\n\n        if (is_un_closed) {\n          return \"<\".concat(tag).concat(attrs, \">\");\n        } else if (is_self_closed) {\n          return \"<\".concat(tag).concat(attrs, \" />\");\n        } else {\n          return \"<\".concat(tag).concat(attrs, \">\").concat(this.innerHTML, \"</\").concat(tag, \">\");\n        }\n      } else {\n        return this.innerHTML;\n      }\n    }\n  }, {\n    key: \"set_content\",\n    value: function set_content(content) {\n      if (content instanceof Node) {\n        content = [content];\n      } else if (typeof content == 'string') {\n        var r = parse(content);\n        content = r.childNodes.length ? r.childNodes : [new TextNode(content)];\n      }\n\n      this.childNodes = content;\n    }\n  }, {\n    key: \"trimRight\",\n\n    /**\n     * Trim element from right (in block) after seeing pattern in a TextNode.\n     * @param  {RegExp} pattern pattern to find\n     * @return {HTMLElement}    reference to current node\n     */\n    value: function trimRight(pattern) {\n      for (var i = 0; i < this.childNodes.length; i++) {\n        var childNode = this.childNodes[i];\n\n        if (childNode.nodeType === NodeType.ELEMENT_NODE) {\n          childNode.trimRight(pattern);\n        } else {\n          var index = childNode.rawText.search(pattern);\n\n          if (index > -1) {\n            childNode.rawText = childNode.rawText.substr(0, index); // trim all following nodes.\n\n            this.childNodes.length = i + 1;\n          }\n        }\n      }\n\n      return this;\n    }\n    /**\n     * Get DOM structure\n     * @return {string} strucutre\n     */\n\n  }, {\n    key: \"removeWhitespace\",\n\n    /**\n     * Remove whitespaces in this sub tree.\n     * @return {HTMLElement} pointer to this\n     */\n    value: function removeWhitespace() {\n      var o = 0;\n\n      for (var i = 0; i < this.childNodes.length; i++) {\n        var node = this.childNodes[i];\n\n        if (node.nodeType === NodeType.TEXT_NODE) {\n          if (node.isWhitespace) continue;\n          node.rawText = node.rawText.trim();\n        } else if (node.nodeType === NodeType.ELEMENT_NODE) {\n          node.removeWhitespace();\n        }\n\n        this.childNodes[o++] = node;\n      }\n\n      this.childNodes.length = o;\n      return this;\n    }\n    /**\n     * Query CSS selector to find matching nodes.\n     * @param  {string}         selector Simplified CSS selector\n     * @param  {Matcher}        selector A Matcher instance\n     * @return {HTMLElement[]}  matching elements\n     */\n\n  }, {\n    key: \"querySelectorAll\",\n    value: function querySelectorAll(selector) {\n      var matcher;\n\n      if (selector instanceof Matcher) {\n        matcher = selector;\n        matcher.reset();\n      } else {\n        matcher = new Matcher(selector);\n      }\n\n      var res = [];\n      var stack = [];\n\n      for (var i = 0; i < this.childNodes.length; i++) {\n        stack.push([this.childNodes[i], 0, false]);\n\n        while (stack.length) {\n          var state = arr_back(stack);\n          var el = state[0];\n\n          if (state[1] === 0) {\n            // Seen for first time.\n            if (el.nodeType !== NodeType.ELEMENT_NODE) {\n              stack.pop();\n              continue;\n            }\n\n            if (state[2] = matcher.advance(el)) {\n              if (matcher.matched) {\n                res.push(el); // no need to go further.\n\n                matcher.rewind();\n                stack.pop();\n                continue;\n              }\n            }\n          }\n\n          if (state[1] < el.childNodes.length) {\n            stack.push([el.childNodes[state[1]++], 0, false]);\n          } else {\n            if (state[2]) matcher.rewind();\n            stack.pop();\n          }\n        }\n      }\n\n      return res;\n    }\n    /**\n     * Query CSS Selector to find matching node.\n     * @param  {string}         selector Simplified CSS selector\n     * @param  {Matcher}        selector A Matcher instance\n     * @return {HTMLElement}    matching node\n     */\n\n  }, {\n    key: \"querySelector\",\n    value: function querySelector(selector) {\n      var matcher;\n\n      if (selector instanceof Matcher) {\n        matcher = selector;\n        matcher.reset();\n      } else {\n        matcher = new Matcher(selector);\n      }\n\n      var stack = [];\n\n      for (var i = 0; i < this.childNodes.length; i++) {\n        stack.push([this.childNodes[i], 0, false]);\n\n        while (stack.length) {\n          var state = arr_back(stack);\n          var el = state[0];\n\n          if (state[1] === 0) {\n            // Seen for first time.\n            if (el.nodeType !== NodeType.ELEMENT_NODE) {\n              stack.pop();\n              continue;\n            }\n\n            if (state[2] = matcher.advance(el)) {\n              if (matcher.matched) {\n                return el;\n              }\n            }\n          }\n\n          if (state[1] < el.childNodes.length) {\n            stack.push([el.childNodes[state[1]++], 0, false]);\n          } else {\n            if (state[2]) matcher.rewind();\n            stack.pop();\n          }\n        }\n      }\n\n      return null;\n    }\n    /**\n     * Append a child node to childNodes\n     * @param  {Node} node node to append\n     * @return {Node}      node appended\n     */\n\n  }, {\n    key: \"appendChild\",\n    value: function appendChild(node) {\n      // node.parentNode = this;\n      this.childNodes.push(node);\n\n      if (node instanceof HTMLElement) {\n        node.parentNode = this;\n      }\n\n      return node;\n    }\n    /**\n     * Get first child node\n     * @return {Node} first child node\n     */\n\n  }, {\n    key: \"rawText\",\n    get: function get() {\n      var res = '';\n\n      for (var i = 0; i < this.childNodes.length; i++) {\n        res += this.childNodes[i].rawText;\n      }\n\n      return res;\n    }\n    /**\n     * Get unescaped text value of current node and its children.\n     * @return {string} text content\n     */\n\n  }, {\n    key: \"text\",\n    get: function get() {\n      return he_1.decode(this.rawText);\n    }\n    /**\n     * Get structured Text (with '\\n' etc.)\n     * @return {string} structured text\n     */\n\n  }, {\n    key: \"structuredText\",\n    get: function get() {\n      var currentBlock = [];\n      var blocks = [currentBlock];\n\n      function dfs(node) {\n        if (node.nodeType === NodeType.ELEMENT_NODE) {\n          if (kBlockElements[node.tagName]) {\n            if (currentBlock.length > 0) {\n              blocks.push(currentBlock = []);\n            }\n\n            node.childNodes.forEach(dfs);\n\n            if (currentBlock.length > 0) {\n              blocks.push(currentBlock = []);\n            }\n          } else {\n            node.childNodes.forEach(dfs);\n          }\n        } else if (node.nodeType === NodeType.TEXT_NODE) {\n          if (node.isWhitespace) {\n            // Whitespace node, postponed output\n            currentBlock.prependWhitespace = true;\n          } else {\n            var text = node.text;\n\n            if (currentBlock.prependWhitespace) {\n              text = ' ' + text;\n              currentBlock.prependWhitespace = false;\n            }\n\n            currentBlock.push(text);\n          }\n        }\n      }\n\n      dfs(this);\n      return blocks.map(function (block) {\n        // Normalize each line's whitespace\n        return block.join('').trim().replace(/\\s{2,}/g, ' ');\n      }).join('\\n').replace(/\\s+$/, ''); // trimRight;\n    }\n  }, {\n    key: \"innerHTML\",\n    get: function get() {\n      return this.childNodes.map(function (child) {\n        return child.toString();\n      }).join('');\n    }\n  }, {\n    key: \"outerHTML\",\n    get: function get() {\n      return this.toString();\n    }\n  }, {\n    key: \"structure\",\n    get: function get() {\n      var res = [];\n      var indention = 0;\n\n      function write(str) {\n        res.push('  '.repeat(indention) + str);\n      }\n\n      function dfs(node) {\n        var idStr = node.id ? '#' + node.id : '';\n        var classStr = node.classNames.length ? '.' + node.classNames.join('.') : '';\n        write(node.tagName + idStr + classStr);\n        indention++;\n\n        for (var i = 0; i < node.childNodes.length; i++) {\n          var childNode = node.childNodes[i];\n\n          if (childNode.nodeType === NodeType.ELEMENT_NODE) {\n            dfs(childNode);\n          } else if (childNode.nodeType === NodeType.TEXT_NODE) {\n            if (!childNode.isWhitespace) write('#text');\n          }\n        }\n\n        indention--;\n      }\n\n      dfs(this);\n      return res.join('\\n');\n    }\n  }, {\n    key: \"firstChild\",\n    get: function get() {\n      return this.childNodes[0];\n    }\n    /**\n     * Get last child node\n     * @return {Node} last child node\n     */\n\n  }, {\n    key: \"lastChild\",\n    get: function get() {\n      return arr_back(this.childNodes);\n    }\n    /**\n     * Get attributes\n     * @return {Object} parsed and unescaped attributes\n     */\n\n  }, {\n    key: \"attributes\",\n    get: function get() {\n      if (this._attrs) return this._attrs;\n      this._attrs = {};\n      var attrs = this.rawAttributes;\n\n      for (var key in attrs) {\n        this._attrs[key] = he_1.decode(attrs[key]);\n      }\n\n      return this._attrs;\n    }\n    /**\n     * Get escaped (as-it) attributes\n     * @return {Object} parsed attributes\n     */\n\n  }, {\n    key: \"rawAttributes\",\n    get: function get() {\n      if (this._rawAttrs) return this._rawAttrs;\n      var attrs = {};\n\n      if (this.rawAttrs) {\n        var re = /\\b([a-z][a-z0-9\\-]*)(?:\\s*=\\s*(?:\"([^\"]*)\"|'([^']*)'|(\\S+)))?/ig;\n        var match;\n\n        while (match = re.exec(this.rawAttrs)) {\n          attrs[match[1]] = match[2] || match[3] || match[4] || \"\";\n        }\n      }\n\n      this._rawAttrs = attrs;\n      return attrs;\n    }\n  }]);\n\n  return HTMLElement;\n}(Node);\n\nexports.HTMLElement = HTMLElement;\n/**\n * Cache to store generated match functions\n * @type {Object}\n */\n\nvar pMatchFunctionCache = {};\n/**\n * Function cache\n */\n\nvar functionCache = {\n  \"f145\": function f145(el, tagName, classes, attr_key, value) {\n    \"use strict\";\n\n    tagName = tagName || \"\";\n    classes = classes || [];\n    attr_key = attr_key || \"\";\n    value = value || \"\";\n    if (el.id != tagName.substr(1)) return false;\n\n    for (var cls = classes, i = 0; i < cls.length; i++) {\n      if (el.classNames.indexOf(cls[i]) === -1) return false;\n    }\n\n    return true;\n  },\n  \"f45\": function f45(el, tagName, classes, attr_key, value) {\n    \"use strict\";\n\n    tagName = tagName || \"\";\n    classes = classes || [];\n    attr_key = attr_key || \"\";\n    value = value || \"\";\n\n    for (var cls = classes, i = 0; i < cls.length; i++) {\n      if (el.classNames.indexOf(cls[i]) === -1) return false;\n    }\n\n    return true;\n  },\n  \"f15\": function f15(el, tagName, classes, attr_key, value) {\n    \"use strict\";\n\n    tagName = tagName || \"\";\n    classes = classes || [];\n    attr_key = attr_key || \"\";\n    value = value || \"\";\n    if (el.id != tagName.substr(1)) return false;\n    return true;\n  },\n  \"f1\": function f1(el, tagName, classes, attr_key, value) {\n    \"use strict\";\n\n    tagName = tagName || \"\";\n    classes = classes || [];\n    attr_key = attr_key || \"\";\n    value = value || \"\";\n    if (el.id != tagName.substr(1)) return false;\n  },\n  \"f5\": function f5(el, tagName, classes, attr_key, value) {\n    \"use strict\";\n\n    el = el || {};\n    tagName = tagName || \"\";\n    classes = classes || [];\n    attr_key = attr_key || \"\";\n    value = value || \"\";\n    return true;\n  },\n  \"f245\": function f245(el, tagName, classes, attr_key, value) {\n    \"use strict\";\n\n    tagName = tagName || \"\";\n    classes = classes || [];\n    attr_key = attr_key || \"\";\n    value = value || \"\";\n    var attrs = el.attributes;\n\n    for (var key in attrs) {\n      var val = attrs[key];\n\n      if (key == attr_key && val == value) {\n        return true;\n      }\n    }\n\n    return false; // for (let cls = classes, i = 0; i < cls.length; i++) {if (el.classNames.indexOf(cls[i]) === -1){ return false;}}\n    // return true;\n  },\n  \"f25\": function f25(el, tagName, classes, attr_key, value) {\n    \"use strict\";\n\n    tagName = tagName || \"\";\n    classes = classes || [];\n    attr_key = attr_key || \"\";\n    value = value || \"\";\n    var attrs = el.attributes;\n\n    for (var key in attrs) {\n      var val = attrs[key];\n\n      if (key == attr_key && val == value) {\n        return true;\n      }\n    }\n\n    return false; //return true;\n  },\n  \"f2\": function f2(el, tagName, classes, attr_key, value) {\n    \"use strict\";\n\n    tagName = tagName || \"\";\n    classes = classes || [];\n    attr_key = attr_key || \"\";\n    value = value || \"\";\n    var attrs = el.attributes;\n\n    for (var key in attrs) {\n      var val = attrs[key];\n\n      if (key == attr_key && val == value) {\n        return true;\n      }\n    }\n\n    return false;\n  },\n  \"f345\": function f345(el, tagName, classes, attr_key, value) {\n    \"use strict\";\n\n    tagName = tagName || \"\";\n    classes = classes || [];\n    attr_key = attr_key || \"\";\n    value = value || \"\";\n    if (el.tagName != tagName) return false;\n\n    for (var cls = classes, i = 0; i < cls.length; i++) {\n      if (el.classNames.indexOf(cls[i]) === -1) return false;\n    }\n\n    return true;\n  },\n  \"f35\": function f35(el, tagName, classes, attr_key, value) {\n    \"use strict\";\n\n    tagName = tagName || \"\";\n    classes = classes || [];\n    attr_key = attr_key || \"\";\n    value = value || \"\";\n    if (el.tagName != tagName) return false;\n    return true;\n  },\n  \"f3\": function f3(el, tagName, classes, attr_key, value) {\n    \"use strict\";\n\n    tagName = tagName || \"\";\n    classes = classes || [];\n    attr_key = attr_key || \"\";\n    value = value || \"\";\n    if (el.tagName != tagName) return false;\n  }\n};\n/**\n * Matcher class to make CSS match\n *\n * @class Matcher\n */\n\nvar Matcher =\n/*#__PURE__*/\nfunction () {\n  /**\n   * Creates an instance of Matcher.\n   * @param {string} selector\n   *\n   * @memberof Matcher\n   */\n  function Matcher(selector) {\n    _classCallCheck(this, Matcher);\n\n    this.nextMatch = 0;\n    functionCache[\"f5\"] = functionCache[\"f5\"];\n    this.matchers = selector.split(' ').map(function (matcher) {\n      if (pMatchFunctionCache[matcher]) return pMatchFunctionCache[matcher];\n      var parts = matcher.split('.');\n      var tagName = parts[0];\n      var classes = parts.slice(1).sort();\n      var source = '\"use strict\";';\n      var function_name = 'f';\n      var attr_key = \"\";\n      var value = \"\";\n\n      if (tagName && tagName != '*') {\n        var _matcher;\n\n        if (tagName[0] == '#') {\n          source += 'if (el.id != ' + JSON.stringify(tagName.substr(1)) + ') return false;'; //1\n\n          function_name += '1';\n        } else if (_matcher = tagName.match(/^\\[\\s*(\\S+)\\s*(=|!=)\\s*(((([\"'])([^\\6]*)\\6))|(\\S*?))\\]\\s*/)) {\n          attr_key = _matcher[1];\n          var method = _matcher[2];\n\n          if (method !== '=' && method !== '!=') {\n            throw new Error('Selector not supported, Expect [key${op}value].op must be =,!=');\n          }\n\n          if (method === '=') {\n            method = '==';\n          }\n\n          value = _matcher[7] || _matcher[8];\n          source += \"let attrs = el.attributes;for (let key in attrs){const val = attrs[key]; if (key == \\\"\".concat(attr_key, \"\\\" && val == \\\"\").concat(value, \"\\\"){return true;}} return false;\"); //2\n\n          function_name += '2';\n        } else {\n          source += 'if (el.tagName != ' + JSON.stringify(tagName) + ') return false;'; //3\n\n          function_name += '3';\n        }\n      }\n\n      if (classes.length > 0) {\n        source += 'for (let cls = ' + JSON.stringify(classes) + ', i = 0; i < cls.length; i++) if (el.classNames.indexOf(cls[i]) === -1) return false;'; //4\n\n        function_name += '4';\n      }\n\n      source += 'return true;'; //5\n\n      function_name += '5';\n      var obj = {\n        func: functionCache[function_name],\n        tagName: tagName || \"\",\n        classes: classes || \"\",\n        attr_key: attr_key || \"\",\n        value: value || \"\"\n      };\n      source = source || \"\";\n      return pMatchFunctionCache[matcher] = obj;\n    });\n  }\n  /**\n   * Trying to advance match pointer\n   * @param  {HTMLElement} el element to make the match\n   * @return {bool}           true when pointer advanced.\n   */\n\n\n  _createClass(Matcher, [{\n    key: \"advance\",\n    value: function advance(el) {\n      if (this.nextMatch < this.matchers.length && this.matchers[this.nextMatch].func(el, this.matchers[this.nextMatch].tagName, this.matchers[this.nextMatch].classes, this.matchers[this.nextMatch].attr_key, this.matchers[this.nextMatch].value)) {\n        this.nextMatch++;\n        return true;\n      }\n\n      return false;\n    }\n    /**\n     * Rewind the match pointer\n     */\n\n  }, {\n    key: \"rewind\",\n    value: function rewind() {\n      this.nextMatch--;\n    }\n    /**\n     * Trying to determine if match made.\n     * @return {bool} true when the match is made\n     */\n\n  }, {\n    key: \"reset\",\n\n    /**\n     * Rest match pointer.\n     * @return {[type]} [description]\n     */\n    value: function reset() {\n      this.nextMatch = 0;\n    }\n    /**\n     * flush cache to free memory\n     */\n\n  }, {\n    key: \"flushCache\",\n    value: function flushCache() {\n      pMatchFunctionCache = {};\n    }\n  }, {\n    key: \"matched\",\n    get: function get() {\n      return this.nextMatch == this.matchers.length;\n    }\n  }]);\n\n  return Matcher;\n}();\n\nexports.Matcher = Matcher; // https://html.spec.whatwg.org/multipage/custom-elements.html#valid-custom-element-name\n\nvar kMarkupPattern = /<!--[^]*?(?=-->)-->|<(\\/?)([a-z][-.0-9_a-z]*)\\s*([^>]*?)(\\/?)>/ig;\nvar kAttributePattern = /(^|\\s)(id|class)\\s*=\\s*(\"([^\"]+)\"|'([^']+)'|(\\S+))/ig;\nvar kSelfClosingElements = {\n  area: true,\n  base: true,\n  br: true,\n  col: true,\n  hr: true,\n  img: true,\n  input: true,\n  link: true,\n  meta: true,\n  source: true\n};\nvar kElementsClosedByOpening = {\n  li: {\n    li: true\n  },\n  p: {\n    p: true,\n    div: true\n  },\n  b: {\n    div: true\n  },\n  td: {\n    td: true,\n    th: true\n  },\n  th: {\n    td: true,\n    th: true\n  },\n  h1: {\n    h1: true\n  },\n  h2: {\n    h2: true\n  },\n  h3: {\n    h3: true\n  },\n  h4: {\n    h4: true\n  },\n  h5: {\n    h5: true\n  },\n  h6: {\n    h6: true\n  }\n};\nvar kElementsClosedByClosing = {\n  li: {\n    ul: true,\n    ol: true\n  },\n  a: {\n    div: true\n  },\n  b: {\n    div: true\n  },\n  i: {\n    div: true\n  },\n  p: {\n    div: true\n  },\n  td: {\n    tr: true,\n    table: true\n  },\n  th: {\n    tr: true,\n    table: true\n  }\n};\nvar kBlockTextElements = {\n  script: true,\n  noscript: true,\n  style: true,\n  pre: true\n};\n/**\n * Parses HTML and returns a root element\n * Parse a chuck of HTML source.\n * @param  {string} data      html\n * @return {HTMLElement}      root element\n */\n\nfunction parse(data, options) {\n  var root = new HTMLElement(null, {});\n  var currentParent = root;\n  var stack = [root];\n  var lastTextPos = -1;\n  options = options || {};\n  var match;\n\n  while (match = kMarkupPattern.exec(data)) {\n    if (lastTextPos > -1) {\n      if (lastTextPos + match[0].length < kMarkupPattern.lastIndex) {\n        // if has content\n        var text = data.substring(lastTextPos, kMarkupPattern.lastIndex - match[0].length);\n        currentParent.appendChild(new TextNode(text));\n      }\n    }\n\n    lastTextPos = kMarkupPattern.lastIndex;\n\n    if (match[0][1] == '!') {\n      // this is a comment\n      continue;\n    }\n\n    if (options.lowerCaseTagName) match[2] = match[2].toLowerCase();\n\n    if (!match[1]) {\n      // not </ tags\n      var attrs = {};\n\n      for (var attMatch; attMatch = kAttributePattern.exec(match[3]);) {\n        attrs[attMatch[2]] = attMatch[4] || attMatch[5] || attMatch[6];\n      }\n\n      if (!match[4] && kElementsClosedByOpening[currentParent.tagName]) {\n        if (kElementsClosedByOpening[currentParent.tagName][match[2]]) {\n          stack.pop();\n          currentParent = arr_back(stack);\n        }\n      }\n\n      currentParent = currentParent.appendChild(new HTMLElement(match[2], attrs, match[3]));\n      stack.push(currentParent);\n\n      if (kBlockTextElements[match[2]]) {\n        // a little test to find next </script> or </style> ...\n        var closeMarkup = '</' + match[2] + '>';\n        var index = data.indexOf(closeMarkup, kMarkupPattern.lastIndex);\n\n        if (options[match[2]]) {\n          var _text = void 0;\n\n          if (index == -1) {\n            // there is no matching ending for the text element.\n            _text = data.substr(kMarkupPattern.lastIndex);\n          } else {\n            _text = data.substring(kMarkupPattern.lastIndex, index);\n          }\n\n          if (_text.length > 0) {\n            currentParent.appendChild(new TextNode(_text));\n          }\n        }\n\n        if (index == -1) {\n          lastTextPos = kMarkupPattern.lastIndex = data.length + 1;\n        } else {\n          lastTextPos = kMarkupPattern.lastIndex = index + closeMarkup.length;\n          match[1] = 'true';\n        }\n      }\n    }\n\n    if (match[1] || match[4] || kSelfClosingElements[match[2]]) {\n      // </ or /> or <br> etc.\n      while (true) {\n        if (currentParent.tagName == match[2]) {\n          stack.pop();\n          currentParent = arr_back(stack);\n          break;\n        } else {\n          // Trying to close current tag, and move on\n          if (kElementsClosedByClosing[currentParent.tagName]) {\n            if (kElementsClosedByClosing[currentParent.tagName][match[2]]) {\n              stack.pop();\n              currentParent = arr_back(stack);\n              continue;\n            }\n          } // Use aggressive strategy to handle unmatching markups.\n\n\n          break;\n        }\n      }\n    }\n  }\n\n  var valid = !!(stack.length === 1);\n\n  if (!options.noFix) {\n    var response = root;\n    response.valid = valid;\n\n    var _loop = function _loop() {\n      // Handle each error elements.\n      var last = stack.pop();\n      var oneBefore = arr_back(stack);\n\n      if (last.parentNode && last.parentNode.parentNode) {\n        if (last.parentNode === oneBefore && last.tagName === oneBefore.tagName) {\n          // Pair error case <h3> <h3> handle : Fixes to <h3> </h3>\n          oneBefore.removeChild(last);\n          last.childNodes.forEach(function (child) {\n            oneBefore.parentNode.appendChild(child);\n          });\n          stack.pop();\n        } else {\n          // Single error  <div> <h3> </div> handle: Just removes <h3>\n          oneBefore.removeChild(last);\n          last.childNodes.forEach(function (child) {\n            oneBefore.appendChild(child);\n          });\n        }\n      } else {// If it's final element just skip.\n      }\n    };\n\n    while (stack.length > 1) {\n      _loop();\n    }\n\n    response.childNodes.forEach(function (node) {\n      if (node instanceof HTMLElement) {\n        node.parentNode = null;\n      }\n    });\n    return response;\n  } else {\n    var _response = new TextNode(data);\n\n    _response.valid = valid;\n    return _response;\n  }\n}\n\nexports.parse = parse;","map":null,"metadata":{},"sourceType":"script"}