{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst he_1 = require(\"he\");\n\nvar NodeType;\n\n(function (NodeType) {\n  NodeType[NodeType[\"ELEMENT_NODE\"] = 1] = \"ELEMENT_NODE\";\n  NodeType[NodeType[\"TEXT_NODE\"] = 3] = \"TEXT_NODE\";\n})(NodeType = exports.NodeType || (exports.NodeType = {}));\n/**\n * Node Class as base class for TextNode and HTMLElement.\n */\n\n\nclass Node {\n  constructor() {\n    this.childNodes = [];\n  }\n\n}\n\nexports.Node = Node;\n/**\n * TextNode to contain a text element in DOM tree.\n * @param {string} value [description]\n */\n\nclass TextNode extends Node {\n  constructor(value) {\n    super();\n    /**\n     * Node Type declaration.\n     * @type {Number}\n     */\n\n    this.nodeType = NodeType.TEXT_NODE;\n    this.rawText = value;\n  }\n  /**\n   * Get unescaped text value of current node and its children.\n   * @return {string} text content\n   */\n\n\n  get text() {\n    return he_1.decode(this.rawText);\n  }\n  /**\n   * Detect if the node contains only white space.\n   * @return {bool}\n   */\n\n\n  get isWhitespace() {\n    return /^(\\s|&nbsp;)*$/.test(this.rawText);\n  }\n\n  toString() {\n    return this.text;\n  }\n\n}\n\nexports.TextNode = TextNode;\nconst kBlockElements = {\n  div: true,\n  p: true,\n  // ul: true,\n  // ol: true,\n  li: true,\n  // table: true,\n  // tr: true,\n  td: true,\n  section: true,\n  br: true\n};\n\nfunction arr_back(arr) {\n  return arr[arr.length - 1];\n}\n/**\n * HTMLElement, which contains a set of children.\n *\n * Note: this is a minimalist implementation, no complete tree\n *   structure provided (no parentNode, nextSibling,\n *   previousSibling etc).\n * @class HTMLElement\n * @extends {Node}\n */\n\n\nclass HTMLElement extends Node {\n  /**\n   * Creates an instance of HTMLElement.\n   * @param keyAttrs\tid and class attribute\n   * @param [rawAttrs]\tattributes in string\n   *\n   * @memberof HTMLElement\n   */\n  constructor(tagName, keyAttrs, rawAttrs = '', parentNode = null) {\n    super();\n    this.tagName = tagName;\n    this.rawAttrs = rawAttrs;\n    this.parentNode = parentNode;\n    this.classNames = [];\n    /**\n     * Node Type declaration.\n     */\n\n    this.nodeType = NodeType.ELEMENT_NODE;\n    this.rawAttrs = rawAttrs || '';\n    this.parentNode = parentNode || null;\n    this.childNodes = [];\n\n    if (keyAttrs.id) {\n      this.id = keyAttrs.id;\n    }\n\n    if (keyAttrs.class) {\n      this.classNames = keyAttrs.class.split(/\\s+/);\n    }\n  }\n  /**\n   * Remove Child element from childNodes array\n   * @param {HTMLElement} node     node to remove\n   */\n\n\n  removeChild(node) {\n    this.childNodes = this.childNodes.filter(child => {\n      return child !== node;\n    });\n  }\n  /**\n   * Exchanges given child with new child\n   * @param {HTMLElement} oldNode     node to exchange\n   * @param {HTMLElement} newNode     new node\n   */\n\n\n  exchangeChild(oldNode, newNode) {\n    let idx = -1;\n\n    for (let i = 0; i < this.childNodes.length; i++) {\n      if (this.childNodes[i] === oldNode) {\n        idx = i;\n        break;\n      }\n    }\n\n    this.childNodes[idx] = newNode;\n  }\n  /**\n   * Get escpaed (as-it) text value of current node and its children.\n   * @return {string} text content\n   */\n\n\n  get rawText() {\n    let res = '';\n\n    for (let i = 0; i < this.childNodes.length; i++) res += this.childNodes[i].rawText;\n\n    return res;\n  }\n  /**\n   * Get unescaped text value of current node and its children.\n   * @return {string} text content\n   */\n\n\n  get text() {\n    return he_1.decode(this.rawText);\n  }\n  /**\n   * Get structured Text (with '\\n' etc.)\n   * @return {string} structured text\n   */\n\n\n  get structuredText() {\n    let currentBlock = [];\n    const blocks = [currentBlock];\n\n    function dfs(node) {\n      if (node.nodeType === NodeType.ELEMENT_NODE) {\n        if (kBlockElements[node.tagName]) {\n          if (currentBlock.length > 0) {\n            blocks.push(currentBlock = []);\n          }\n\n          node.childNodes.forEach(dfs);\n\n          if (currentBlock.length > 0) {\n            blocks.push(currentBlock = []);\n          }\n        } else {\n          node.childNodes.forEach(dfs);\n        }\n      } else if (node.nodeType === NodeType.TEXT_NODE) {\n        if (node.isWhitespace) {\n          // Whitespace node, postponed output\n          currentBlock.prependWhitespace = true;\n        } else {\n          let text = node.text;\n\n          if (currentBlock.prependWhitespace) {\n            text = ' ' + text;\n            currentBlock.prependWhitespace = false;\n          }\n\n          currentBlock.push(text);\n        }\n      }\n    }\n\n    dfs(this);\n    return blocks.map(function (block) {\n      // Normalize each line's whitespace\n      return block.join('').trim().replace(/\\s{2,}/g, ' ');\n    }).join('\\n').replace(/\\s+$/, ''); // trimRight;\n  }\n\n  toString() {\n    const tag = this.tagName;\n\n    if (tag) {\n      const is_un_closed = /^meta$/i.test(tag);\n      const is_self_closed = /^(img|br|hr|area|base|input|doctype|link)$/i.test(tag);\n      const attrs = this.rawAttrs ? ' ' + this.rawAttrs : '';\n\n      if (is_un_closed) {\n        return \"<\".concat(tag).concat(attrs, \">\");\n      } else if (is_self_closed) {\n        return \"<\".concat(tag).concat(attrs, \" />\");\n      } else {\n        return \"<\".concat(tag).concat(attrs, \">\").concat(this.innerHTML, \"</\").concat(tag, \">\");\n      }\n    } else {\n      return this.innerHTML;\n    }\n  }\n\n  get innerHTML() {\n    return this.childNodes.map(child => {\n      return child.toString();\n    }).join('');\n  }\n\n  set_content(content) {\n    if (content instanceof Node) {\n      content = [content];\n    } else if (typeof content == 'string') {\n      const r = parse(content);\n      content = r.childNodes.length ? r.childNodes : [new TextNode(content)];\n    }\n\n    this.childNodes = content;\n  }\n\n  get outerHTML() {\n    return this.toString();\n  }\n  /**\n   * Trim element from right (in block) after seeing pattern in a TextNode.\n   * @param  {RegExp} pattern pattern to find\n   * @return {HTMLElement}    reference to current node\n   */\n\n\n  trimRight(pattern) {\n    for (let i = 0; i < this.childNodes.length; i++) {\n      const childNode = this.childNodes[i];\n\n      if (childNode.nodeType === NodeType.ELEMENT_NODE) {\n        childNode.trimRight(pattern);\n      } else {\n        const index = childNode.rawText.search(pattern);\n\n        if (index > -1) {\n          childNode.rawText = childNode.rawText.substr(0, index); // trim all following nodes.\n\n          this.childNodes.length = i + 1;\n        }\n      }\n    }\n\n    return this;\n  }\n  /**\n   * Get DOM structure\n   * @return {string} strucutre\n   */\n\n\n  get structure() {\n    const res = [];\n    let indention = 0;\n\n    function write(str) {\n      res.push('  '.repeat(indention) + str);\n    }\n\n    function dfs(node) {\n      const idStr = node.id ? '#' + node.id : '';\n      const classStr = node.classNames.length ? '.' + node.classNames.join('.') : '';\n      write(node.tagName + idStr + classStr);\n      indention++;\n\n      for (let i = 0; i < node.childNodes.length; i++) {\n        const childNode = node.childNodes[i];\n\n        if (childNode.nodeType === NodeType.ELEMENT_NODE) {\n          dfs(childNode);\n        } else if (childNode.nodeType === NodeType.TEXT_NODE) {\n          if (!childNode.isWhitespace) write('#text');\n        }\n      }\n\n      indention--;\n    }\n\n    dfs(this);\n    return res.join('\\n');\n  }\n  /**\n   * Remove whitespaces in this sub tree.\n   * @return {HTMLElement} pointer to this\n   */\n\n\n  removeWhitespace() {\n    let o = 0;\n\n    for (let i = 0; i < this.childNodes.length; i++) {\n      const node = this.childNodes[i];\n\n      if (node.nodeType === NodeType.TEXT_NODE) {\n        if (node.isWhitespace) continue;\n        node.rawText = node.rawText.trim();\n      } else if (node.nodeType === NodeType.ELEMENT_NODE) {\n        node.removeWhitespace();\n      }\n\n      this.childNodes[o++] = node;\n    }\n\n    this.childNodes.length = o;\n    return this;\n  }\n  /**\n   * Query CSS selector to find matching nodes.\n   * @param  {string}         selector Simplified CSS selector\n   * @param  {Matcher}        selector A Matcher instance\n   * @return {HTMLElement[]}  matching elements\n   */\n\n\n  querySelectorAll(selector) {\n    let matcher;\n\n    if (selector instanceof Matcher) {\n      matcher = selector;\n      matcher.reset();\n    } else {\n      matcher = new Matcher(selector);\n    }\n\n    const res = [];\n    const stack = [];\n\n    for (let i = 0; i < this.childNodes.length; i++) {\n      stack.push([this.childNodes[i], 0, false]);\n\n      while (stack.length) {\n        const state = arr_back(stack);\n        const el = state[0];\n\n        if (state[1] === 0) {\n          // Seen for first time.\n          if (el.nodeType !== NodeType.ELEMENT_NODE) {\n            stack.pop();\n            continue;\n          }\n\n          if (state[2] = matcher.advance(el)) {\n            if (matcher.matched) {\n              res.push(el); // no need to go further.\n\n              matcher.rewind();\n              stack.pop();\n              continue;\n            }\n          }\n        }\n\n        if (state[1] < el.childNodes.length) {\n          stack.push([el.childNodes[state[1]++], 0, false]);\n        } else {\n          if (state[2]) matcher.rewind();\n          stack.pop();\n        }\n      }\n    }\n\n    return res;\n  }\n  /**\n   * Query CSS Selector to find matching node.\n   * @param  {string}         selector Simplified CSS selector\n   * @param  {Matcher}        selector A Matcher instance\n   * @return {HTMLElement}    matching node\n   */\n\n\n  querySelector(selector) {\n    let matcher;\n\n    if (selector instanceof Matcher) {\n      matcher = selector;\n      matcher.reset();\n    } else {\n      matcher = new Matcher(selector);\n    }\n\n    const stack = [];\n\n    for (let i = 0; i < this.childNodes.length; i++) {\n      stack.push([this.childNodes[i], 0, false]);\n\n      while (stack.length) {\n        const state = arr_back(stack);\n        const el = state[0];\n\n        if (state[1] === 0) {\n          // Seen for first time.\n          if (el.nodeType !== NodeType.ELEMENT_NODE) {\n            stack.pop();\n            continue;\n          }\n\n          if (state[2] = matcher.advance(el)) {\n            if (matcher.matched) {\n              return el;\n            }\n          }\n        }\n\n        if (state[1] < el.childNodes.length) {\n          stack.push([el.childNodes[state[1]++], 0, false]);\n        } else {\n          if (state[2]) matcher.rewind();\n          stack.pop();\n        }\n      }\n    }\n\n    return null;\n  }\n  /**\n   * Append a child node to childNodes\n   * @param  {Node} node node to append\n   * @return {Node}      node appended\n   */\n\n\n  appendChild(node) {\n    // node.parentNode = this;\n    this.childNodes.push(node);\n\n    if (node instanceof HTMLElement) {\n      node.parentNode = this;\n    }\n\n    return node;\n  }\n  /**\n   * Get first child node\n   * @return {Node} first child node\n   */\n\n\n  get firstChild() {\n    return this.childNodes[0];\n  }\n  /**\n   * Get last child node\n   * @return {Node} last child node\n   */\n\n\n  get lastChild() {\n    return arr_back(this.childNodes);\n  }\n  /**\n   * Get attributes\n   * @return {Object} parsed and unescaped attributes\n   */\n\n\n  get attributes() {\n    if (this._attrs) return this._attrs;\n    this._attrs = {};\n    const attrs = this.rawAttributes;\n\n    for (const key in attrs) {\n      this._attrs[key] = he_1.decode(attrs[key]);\n    }\n\n    return this._attrs;\n  }\n  /**\n   * Get escaped (as-it) attributes\n   * @return {Object} parsed attributes\n   */\n\n\n  get rawAttributes() {\n    if (this._rawAttrs) return this._rawAttrs;\n    const attrs = {};\n\n    if (this.rawAttrs) {\n      const re = /\\b([a-z][a-z0-9\\-]*)(?:\\s*=\\s*(?:\"([^\"]*)\"|'([^']*)'|(\\S+)))?/ig;\n      let match;\n\n      while (match = re.exec(this.rawAttrs)) {\n        attrs[match[1]] = match[2] || match[3] || match[4] || \"\";\n      }\n    }\n\n    this._rawAttrs = attrs;\n    return attrs;\n  }\n\n}\n\nexports.HTMLElement = HTMLElement;\n/**\n * Cache to store generated match functions\n * @type {Object}\n */\n\nlet pMatchFunctionCache = {};\n/**\n * Function cache\n */\n\nconst functionCache = {\n  \"f145\": function (el, tagName, classes, attr_key, value) {\n    \"use strict\";\n\n    tagName = tagName || \"\";\n    classes = classes || [];\n    attr_key = attr_key || \"\";\n    value = value || \"\";\n    if (el.id != tagName.substr(1)) return false;\n\n    for (let cls = classes, i = 0; i < cls.length; i++) if (el.classNames.indexOf(cls[i]) === -1) return false;\n\n    return true;\n  },\n  \"f45\": function (el, tagName, classes, attr_key, value) {\n    \"use strict\";\n\n    tagName = tagName || \"\";\n    classes = classes || [];\n    attr_key = attr_key || \"\";\n    value = value || \"\";\n\n    for (let cls = classes, i = 0; i < cls.length; i++) if (el.classNames.indexOf(cls[i]) === -1) return false;\n\n    return true;\n  },\n  \"f15\": function (el, tagName, classes, attr_key, value) {\n    \"use strict\";\n\n    tagName = tagName || \"\";\n    classes = classes || [];\n    attr_key = attr_key || \"\";\n    value = value || \"\";\n    if (el.id != tagName.substr(1)) return false;\n    return true;\n  },\n  \"f1\": function (el, tagName, classes, attr_key, value) {\n    \"use strict\";\n\n    tagName = tagName || \"\";\n    classes = classes || [];\n    attr_key = attr_key || \"\";\n    value = value || \"\";\n    if (el.id != tagName.substr(1)) return false;\n  },\n  \"f5\": function (el, tagName, classes, attr_key, value) {\n    \"use strict\";\n\n    el = el || {};\n    tagName = tagName || \"\";\n    classes = classes || [];\n    attr_key = attr_key || \"\";\n    value = value || \"\";\n    return true;\n  },\n  \"f245\": function (el, tagName, classes, attr_key, value) {\n    \"use strict\";\n\n    tagName = tagName || \"\";\n    classes = classes || [];\n    attr_key = attr_key || \"\";\n    value = value || \"\";\n    let attrs = el.attributes;\n\n    for (let key in attrs) {\n      const val = attrs[key];\n\n      if (key == attr_key && val == value) {\n        return true;\n      }\n    }\n\n    return false; // for (let cls = classes, i = 0; i < cls.length; i++) {if (el.classNames.indexOf(cls[i]) === -1){ return false;}}\n    // return true;\n  },\n  \"f25\": function (el, tagName, classes, attr_key, value) {\n    \"use strict\";\n\n    tagName = tagName || \"\";\n    classes = classes || [];\n    attr_key = attr_key || \"\";\n    value = value || \"\";\n    let attrs = el.attributes;\n\n    for (let key in attrs) {\n      const val = attrs[key];\n\n      if (key == attr_key && val == value) {\n        return true;\n      }\n    }\n\n    return false; //return true;\n  },\n  \"f2\": function (el, tagName, classes, attr_key, value) {\n    \"use strict\";\n\n    tagName = tagName || \"\";\n    classes = classes || [];\n    attr_key = attr_key || \"\";\n    value = value || \"\";\n    let attrs = el.attributes;\n\n    for (let key in attrs) {\n      const val = attrs[key];\n\n      if (key == attr_key && val == value) {\n        return true;\n      }\n    }\n\n    return false;\n  },\n  \"f345\": function (el, tagName, classes, attr_key, value) {\n    \"use strict\";\n\n    tagName = tagName || \"\";\n    classes = classes || [];\n    attr_key = attr_key || \"\";\n    value = value || \"\";\n    if (el.tagName != tagName) return false;\n\n    for (let cls = classes, i = 0; i < cls.length; i++) if (el.classNames.indexOf(cls[i]) === -1) return false;\n\n    return true;\n  },\n  \"f35\": function (el, tagName, classes, attr_key, value) {\n    \"use strict\";\n\n    tagName = tagName || \"\";\n    classes = classes || [];\n    attr_key = attr_key || \"\";\n    value = value || \"\";\n    if (el.tagName != tagName) return false;\n    return true;\n  },\n  \"f3\": function (el, tagName, classes, attr_key, value) {\n    \"use strict\";\n\n    tagName = tagName || \"\";\n    classes = classes || [];\n    attr_key = attr_key || \"\";\n    value = value || \"\";\n    if (el.tagName != tagName) return false;\n  }\n};\n/**\n * Matcher class to make CSS match\n *\n * @class Matcher\n */\n\nclass Matcher {\n  /**\n   * Creates an instance of Matcher.\n   * @param {string} selector\n   *\n   * @memberof Matcher\n   */\n  constructor(selector) {\n    this.nextMatch = 0;\n    functionCache[\"f5\"] = functionCache[\"f5\"];\n    this.matchers = selector.split(' ').map(matcher => {\n      if (pMatchFunctionCache[matcher]) return pMatchFunctionCache[matcher];\n      const parts = matcher.split('.');\n      const tagName = parts[0];\n      const classes = parts.slice(1).sort();\n      let source = '\"use strict\";';\n      let function_name = 'f';\n      let attr_key = \"\";\n      let value = \"\";\n\n      if (tagName && tagName != '*') {\n        let matcher;\n\n        if (tagName[0] == '#') {\n          source += 'if (el.id != ' + JSON.stringify(tagName.substr(1)) + ') return false;'; //1\n\n          function_name += '1';\n        } else if (matcher = tagName.match(/^\\[\\s*(\\S+)\\s*(=|!=)\\s*(((([\"'])([^\\6]*)\\6))|(\\S*?))\\]\\s*/)) {\n          attr_key = matcher[1];\n          let method = matcher[2];\n\n          if (method !== '=' && method !== '!=') {\n            throw new Error('Selector not supported, Expect [key${op}value].op must be =,!=');\n          }\n\n          if (method === '=') {\n            method = '==';\n          }\n\n          value = matcher[7] || matcher[8];\n          source += \"let attrs = el.attributes;for (let key in attrs){const val = attrs[key]; if (key == \\\"\".concat(attr_key, \"\\\" && val == \\\"\").concat(value, \"\\\"){return true;}} return false;\"); //2\n\n          function_name += '2';\n        } else {\n          source += 'if (el.tagName != ' + JSON.stringify(tagName) + ') return false;'; //3\n\n          function_name += '3';\n        }\n      }\n\n      if (classes.length > 0) {\n        source += 'for (let cls = ' + JSON.stringify(classes) + ', i = 0; i < cls.length; i++) if (el.classNames.indexOf(cls[i]) === -1) return false;'; //4\n\n        function_name += '4';\n      }\n\n      source += 'return true;'; //5\n\n      function_name += '5';\n      let obj = {\n        func: functionCache[function_name],\n        tagName: tagName || \"\",\n        classes: classes || \"\",\n        attr_key: attr_key || \"\",\n        value: value || \"\"\n      };\n      source = source || \"\";\n      return pMatchFunctionCache[matcher] = obj;\n    });\n  }\n  /**\n   * Trying to advance match pointer\n   * @param  {HTMLElement} el element to make the match\n   * @return {bool}           true when pointer advanced.\n   */\n\n\n  advance(el) {\n    if (this.nextMatch < this.matchers.length && this.matchers[this.nextMatch].func(el, this.matchers[this.nextMatch].tagName, this.matchers[this.nextMatch].classes, this.matchers[this.nextMatch].attr_key, this.matchers[this.nextMatch].value)) {\n      this.nextMatch++;\n      return true;\n    }\n\n    return false;\n  }\n  /**\n   * Rewind the match pointer\n   */\n\n\n  rewind() {\n    this.nextMatch--;\n  }\n  /**\n   * Trying to determine if match made.\n   * @return {bool} true when the match is made\n   */\n\n\n  get matched() {\n    return this.nextMatch == this.matchers.length;\n  }\n  /**\n   * Rest match pointer.\n   * @return {[type]} [description]\n   */\n\n\n  reset() {\n    this.nextMatch = 0;\n  }\n  /**\n   * flush cache to free memory\n   */\n\n\n  flushCache() {\n    pMatchFunctionCache = {};\n  }\n\n}\n\nexports.Matcher = Matcher; // https://html.spec.whatwg.org/multipage/custom-elements.html#valid-custom-element-name\n\nconst kMarkupPattern = /<!--[^]*?(?=-->)-->|<(\\/?)([a-z][-.0-9_a-z]*)\\s*([^>]*?)(\\/?)>/ig;\nconst kAttributePattern = /(^|\\s)(id|class)\\s*=\\s*(\"([^\"]+)\"|'([^']+)'|(\\S+))/ig;\nconst kSelfClosingElements = {\n  area: true,\n  base: true,\n  br: true,\n  col: true,\n  hr: true,\n  img: true,\n  input: true,\n  link: true,\n  meta: true,\n  source: true\n};\nconst kElementsClosedByOpening = {\n  li: {\n    li: true\n  },\n  p: {\n    p: true,\n    div: true\n  },\n  b: {\n    div: true\n  },\n  td: {\n    td: true,\n    th: true\n  },\n  th: {\n    td: true,\n    th: true\n  },\n  h1: {\n    h1: true\n  },\n  h2: {\n    h2: true\n  },\n  h3: {\n    h3: true\n  },\n  h4: {\n    h4: true\n  },\n  h5: {\n    h5: true\n  },\n  h6: {\n    h6: true\n  }\n};\nconst kElementsClosedByClosing = {\n  li: {\n    ul: true,\n    ol: true\n  },\n  a: {\n    div: true\n  },\n  b: {\n    div: true\n  },\n  i: {\n    div: true\n  },\n  p: {\n    div: true\n  },\n  td: {\n    tr: true,\n    table: true\n  },\n  th: {\n    tr: true,\n    table: true\n  }\n};\nconst kBlockTextElements = {\n  script: true,\n  noscript: true,\n  style: true,\n  pre: true\n};\n/**\n * Parses HTML and returns a root element\n * Parse a chuck of HTML source.\n * @param  {string} data      html\n * @return {HTMLElement}      root element\n */\n\nfunction parse(data, options) {\n  const root = new HTMLElement(null, {});\n  let currentParent = root;\n  const stack = [root];\n  let lastTextPos = -1;\n  options = options || {};\n  let match;\n\n  while (match = kMarkupPattern.exec(data)) {\n    if (lastTextPos > -1) {\n      if (lastTextPos + match[0].length < kMarkupPattern.lastIndex) {\n        // if has content\n        const text = data.substring(lastTextPos, kMarkupPattern.lastIndex - match[0].length);\n        currentParent.appendChild(new TextNode(text));\n      }\n    }\n\n    lastTextPos = kMarkupPattern.lastIndex;\n\n    if (match[0][1] == '!') {\n      // this is a comment\n      continue;\n    }\n\n    if (options.lowerCaseTagName) match[2] = match[2].toLowerCase();\n\n    if (!match[1]) {\n      // not </ tags\n      let attrs = {};\n\n      for (let attMatch; attMatch = kAttributePattern.exec(match[3]);) {\n        attrs[attMatch[2]] = attMatch[4] || attMatch[5] || attMatch[6];\n      }\n\n      if (!match[4] && kElementsClosedByOpening[currentParent.tagName]) {\n        if (kElementsClosedByOpening[currentParent.tagName][match[2]]) {\n          stack.pop();\n          currentParent = arr_back(stack);\n        }\n      }\n\n      currentParent = currentParent.appendChild(new HTMLElement(match[2], attrs, match[3]));\n      stack.push(currentParent);\n\n      if (kBlockTextElements[match[2]]) {\n        // a little test to find next </script> or </style> ...\n        let closeMarkup = '</' + match[2] + '>';\n        let index = data.indexOf(closeMarkup, kMarkupPattern.lastIndex);\n\n        if (options[match[2]]) {\n          let text;\n\n          if (index == -1) {\n            // there is no matching ending for the text element.\n            text = data.substr(kMarkupPattern.lastIndex);\n          } else {\n            text = data.substring(kMarkupPattern.lastIndex, index);\n          }\n\n          if (text.length > 0) {\n            currentParent.appendChild(new TextNode(text));\n          }\n        }\n\n        if (index == -1) {\n          lastTextPos = kMarkupPattern.lastIndex = data.length + 1;\n        } else {\n          lastTextPos = kMarkupPattern.lastIndex = index + closeMarkup.length;\n          match[1] = 'true';\n        }\n      }\n    }\n\n    if (match[1] || match[4] || kSelfClosingElements[match[2]]) {\n      // </ or /> or <br> etc.\n      while (true) {\n        if (currentParent.tagName == match[2]) {\n          stack.pop();\n          currentParent = arr_back(stack);\n          break;\n        } else {\n          // Trying to close current tag, and move on\n          if (kElementsClosedByClosing[currentParent.tagName]) {\n            if (kElementsClosedByClosing[currentParent.tagName][match[2]]) {\n              stack.pop();\n              currentParent = arr_back(stack);\n              continue;\n            }\n          } // Use aggressive strategy to handle unmatching markups.\n\n\n          break;\n        }\n      }\n    }\n  }\n\n  const valid = !!(stack.length === 1);\n\n  if (!options.noFix) {\n    const response = root;\n    response.valid = valid;\n\n    while (stack.length > 1) {\n      // Handle each error elements.\n      const last = stack.pop();\n      const oneBefore = arr_back(stack);\n\n      if (last.parentNode && last.parentNode.parentNode) {\n        if (last.parentNode === oneBefore && last.tagName === oneBefore.tagName) {\n          // Pair error case <h3> <h3> handle : Fixes to <h3> </h3>\n          oneBefore.removeChild(last);\n          last.childNodes.forEach(child => {\n            oneBefore.parentNode.appendChild(child);\n          });\n          stack.pop();\n        } else {\n          // Single error  <div> <h3> </div> handle: Just removes <h3>\n          oneBefore.removeChild(last);\n          last.childNodes.forEach(child => {\n            oneBefore.appendChild(child);\n          });\n        }\n      } else {// If it's final element just skip.\n      }\n    }\n\n    response.childNodes.forEach(node => {\n      if (node instanceof HTMLElement) {\n        node.parentNode = null;\n      }\n    });\n    return response;\n  } else {\n    const response = new TextNode(data);\n    response.valid = valid;\n    return response;\n  }\n}\n\nexports.parse = parse;","map":null,"metadata":{},"sourceType":"script"}